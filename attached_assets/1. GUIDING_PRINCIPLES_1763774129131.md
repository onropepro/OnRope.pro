# Guiding Principles for Orange Shirt Society Licensing Portal Development
**Version**: 1.0  
**Last Updated**: August 26, 2025  
**Status**: ACTIVE - FOUNDATIONAL DOCUMENT

## Core Development Philosophy

### "It Just Works" Principle
Every feature, every interaction, every process must work reliably 100% of the time. There is no acceptable failure rate for core functionality. Users should never experience broken features, lost data, or confusing errors.

## 1. Reliability and Consistency Principles

### 1.1 Zero Data Loss
- **ALL file uploads MUST use Replit Object Storage** - Never use local filesystem for persistent data
- **Database transactions MUST be atomic** - Complete all-or-nothing operations
- **Payment processing MUST be idempotent** - Never double-charge or lose payments
- **Email delivery MUST have retry logic** - Critical communications cannot fail silently

### 1.2 Consistent State Management
- **Single source of truth** - Database is authoritative, never trust client state alone
- **Status transitions MUST be validated** - Use `status-transitions.ts` helpers
- **Payment states MUST match application states** - Never have mismatched statuses
- **Webhook processing MUST be resilient** - Handle duplicates, retries, and failures

### 1.3 Error Recovery
- **Every error MUST be recoverable** - Provide clear next steps for users
- **Failed operations MUST be retryable** - No permanent failures from transient issues
- **Data integrity MUST be maintained** - Validate and sanitize all inputs
- **Recovery scripts MUST exist** - Have tools to fix stuck states

## 2. User Experience Principles

### 2.1 Seamless Interactions
- **Loading states MUST be clear** - Never leave users wondering what's happening
- **Form validation MUST be instant** - Show errors as users type, not after submission
- **Progress MUST be visible** - Multi-step processes need clear indicators
- **Success feedback MUST be immediate** - Confirm actions with visual feedback

### 2.2 Consistent UI Patterns
- **Use semantic design tokens** - Never hardcode colors (use `border-input` not `border-gray-300`)
- **Follow established patterns** - Payment forms, modals, and workflows must be identical across pathways
- **Mobile-first responsive design** - Every feature must work on all devices
- **Accessibility is mandatory** - WCAG 2.1 AA compliance minimum

### 2.3 Error Prevention
- **Validate before submission** - Catch errors client-side when possible
- **Prevent duplicate actions** - Disable buttons during processing
- **Clear constraints upfront** - Show file size limits, character counts, requirements
- **Smart defaults** - Pre-fill logical values, remember user preferences

## 3. Holistic Development Principles

### 3.1 Holistic & Dependency-Aware by Default
Every system change must begin with comprehensive dependency analysis and system-wide impact understanding. No local fixes are permitted without verifying ripple effects across interconnected systems including taxes, payments, receipts, emails, admin views, storage, and webhooks. This principle ensures the "It Just Works" standard is maintained across all 8 license pathways and supporting infrastructure. See [dependency-awareness-instructions.md](./dependency-awareness-instructions.md) for complete implementation guidelines.

### 3.2 System-Wide Understanding
Before making ANY change:
- **Read the instruction documents** - Check `/instructions/core-functionality/` first
- **Trace the data flow** - Understand how data moves through the system
- **Identify all touchpoints** - Find every place a change might impact
- **Test all pathways** - Verify Educational, Artist, Sub-licensee, Personal Use paths

### 3.2 Dependency Awareness
- **Payment → Tax → Coupon integration** - Changes cascade through all three systems
- **Status → Email → UI updates** - Status changes trigger multiple systems
- **File upload → Storage → Serving** - End-to-end file lifecycle management
- **Application → Approval → Delivery** - Complete workflow understanding

### 3.3 Testing Requirements
Every change MUST include:
- **Unit tests** - Individual function validation
- **Integration tests** - System interaction verification
- **Edge case handling** - Zero amounts, expired items, missing data
- **Production simulation** - Test with real Stripe, real emails, real storage

## 4. Critical System Rules

### 4.1 Payment Processing
```typescript
// NEVER modify without understanding implications:
// 1. Webhook middleware configuration in server/index.ts
// 2. Payment intent creation logic
// 3. Status transition validations
// 4. Receipt generation pipeline
```

### 4.2 Tax Calculations
```typescript
// ALWAYS apply taxes in this order:
// 1. Calculate base fee
// 2. Apply coupon discount
// 3. Calculate tax on discounted amount
// 4. Never tax the tax itself
```

### 4.3 File Persistence
```typescript
// MANDATORY pattern for ALL uploads:
// 1. Receive to temp directory
// 2. Validate file integrity
// 3. Upload to Object Storage
// 4. Save storage path to database
// 5. Delete temp file
// 6. NEVER serve from local filesystem
```

### 4.4 Email Delivery
```typescript
// ALL emails MUST:
// 1. Use centralized email manager
// 2. Include retry logic
// 3. Log delivery status
// 4. Handle attachment failures gracefully
// 5. Never block application flow
```

## 5. Display vs Data Integrity Principles

### 5.1 Display Logic Rules
- **Database is authoritative** - Never modify data for display purposes
- **Conditional display logic** - Use payment status to determine how to show amounts  
- **User clarity over technical accuracy** - Show $0.00 for 100% coupons, not original fee
- **Preserve audit trail** - Keep original amounts in database, modify only display

### 5.2 Anti-Pattern Prevention
❌ **NEVER**: Use `calculatedFee` directly for 100% coupon display
❌ **NEVER**: Modify database values to match display preferences  
❌ **NEVER**: Create separate "display fee" fields in database
✅ **ALWAYS**: Use conditional logic based on payment status
✅ **ALWAYS**: Show both original and final amounts for transparency
✅ **ALWAYS**: Preserve original amounts for accounting purposes

## 6. Code Quality Standards

### 5.1 TypeScript Strictness
- **Zero TypeScript errors allowed** - Fix all diagnostics before committing
- **Proper null safety** - Handle undefined/null cases explicitly
- **Type imports correctly** - Use proper import paths, no "../../../"
- **Avoid any types** - Use proper typing throughout

### 5.2 Database Integrity
- **Foreign key constraints** - Maintain referential integrity
- **Proper indexes** - Optimize query performance
- **Migration safety** - Never lose data during schema changes
- **Backup before modifications** - Always have rollback capability

### 5.3 Security Requirements
- **Never expose secrets** - Use environment variables
- **Validate all inputs** - Prevent SQL injection, XSS
- **Authenticate all admin routes** - Use proper middleware
- **Audit sensitive operations** - Log admin actions

## 6. Development Workflow

### 6.1 Before Starting Work
1. **Read relevant instruction documents** in `/instructions/`
2. **Check recent fixes** in report documents
3. **Verify no active issues** in the area you're modifying
4. **Understand the complete flow** from user action to database

### 6.2 During Development
1. **Test as you code** - Don't wait until the end
2. **Handle errors gracefully** - Every catch block needs action
3. **Log important operations** - Aid future debugging
4. **Update documentation** - Keep instructions current

### 6.3 Before Marking Complete
1. **Test all pathways** - Every application type
2. **Verify error handling** - Try to break it
3. **Check mobile experience** - Test responsive design
4. **Confirm email delivery** - Verify all communications
5. **Validate data persistence** - Ensure nothing is lost

## 7. Anti-Patterns to Avoid

### 7.1 Never Do This
❌ Store files locally without Object Storage backup
❌ Modify payment webhook middleware without testing
❌ Create payment intents for $0 amounts
❌ Auto-approve commercial applications with 100% coupons
❌ Use hardcoded colors instead of design tokens
❌ Skip validation "because it should be fine"
❌ Assume happy path without error handling

### 7.2 Always Do This Instead
✅ Use Object Storage for ALL file persistence
✅ Test webhook signature verification after ANY server changes
✅ Skip payment processing for zero-amount applications
✅ Require admin review for all commercial applications
✅ Use semantic design tokens (border-input, text-muted, etc.)
✅ Validate everything, trust nothing
✅ Handle errors explicitly with recovery paths

## 8. System Health Checklist

### Daily Monitoring
- [ ] Stripe webhook health (100% success rate)
- [ ] Email delivery rate (>95% success)
- [ ] Payment completion rate (>99% for valid attempts)
- [ ] File upload success rate (100% for valid files)
- [ ] Application processing time (<30 seconds)

### Weekly Verification
- [ ] No stuck "processing" payments
- [ ] No orphaned file uploads
- [ ] No mismatched status states
- [ ] Certificate generation working
- [ ] Email attachments delivering

### Monthly Audit
- [ ] Tax calculations accurate
- [ ] Coupon usage tracking correct
- [ ] Receipt generation complete
- [ ] Backup systems operational
- [ ] Security updates applied

## 9. Emergency Response

### If Payment Processing Fails
1. Check webhook middleware configuration
2. Verify Stripe API keys
3. Run payment recovery script
4. Check for stuck processing states
5. Review recent code changes

### If Emails Stop Sending
1. Verify SendGrid API key
2. Check email queue status
3. Review email manager logs
4. Test with simple text email
5. Check attachment file paths

### If Files Go Missing
1. Check Object Storage connection
2. Verify upload endpoint implementation
3. Review temporary file cleanup
4. Check database path references
5. Restore from backup if needed

## 10. Continuous Improvement

### Code Reviews Focus On
- Reliability over features
- Error handling completeness
- State consistency
- User experience smoothness
- System-wide impact

### Testing Priorities
1. Payment processing accuracy
2. Data persistence reliability
3. Email delivery success
4. User workflow completion
5. Error recovery paths

### Documentation Updates
- Update instruction files when patterns change
- Document new error scenarios and fixes
- Record architectural decisions
- Maintain troubleshooting guides
- Share knowledge through clear comments

---

## Remember: Every Line of Code Affects Real Users

The Orange Shirt Society depends on this system for their mission. Every bug, every failure, every confusing experience impacts their ability to spread awareness and support reconciliation efforts. 

**Code with care. Test with thoroughness. Deploy with confidence.**

**Our standard: It Just Works. Always.**