import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { db } from "./db";
import { wsHub } from "./websocket-hub";
import { insertUserSchema, insertClientSchema, insertProjectSchema, insertDropLogSchema, insertComplaintSchema, insertComplaintNoteSchema, insertJobCommentSchema, insertHarnessInspectionSchema, insertToolboxMeetingSchema, insertFlhaFormSchema, insertIncidentReportSchema, insertMethodStatementSchema, insertPayPeriodConfigSchema, insertQuoteSchema, insertQuoteServiceSchema, insertGearItemSchema, insertGearAssignmentSchema, insertGearSerialNumberSchema, insertEquipmentDamageReportSchema, insertScheduledJobSchema, insertJobAssignmentSchema, updatePropertyManagerAccountSchema, insertFeatureRequestSchema, insertFeatureRequestMessageSchema, insertHistoricalHoursSchema, normalizeStrataPlan, type InsertGearItem, type InsertGearAssignment, type InsertGearSerialNumber, type Project, gearAssignments, gearSerialNumbers, gearItems, equipmentCatalog, jobAssignments, scheduledJobs, workSessions, nonBillableWorkSessions, licenseKeys, users, propertyManagerCompanyLinks, IRATA_TASK_TYPES, quotes, quoteServices, quoteHistory, superuserTasks, superuserTaskComments, superuserTaskAttachments, jobPostings, insertJobPostingSchema, jobApplications, technicianEmployerConnections, featureRequests, featureRequestMessages, notifications, futureIdeas, insertFutureIdeaSchema, VALID_SHORTFALL_REASONS, insertTechnicianDocumentRequestSchema, technicianDocumentRequests, technicianDocumentRequestFiles, workNotices, insertWorkNoticeSchema, customNoticeTemplates, dashboardPreferences, sidebarPreferences, projects as projectsTable, incidentReports, clients, quizAttempts, founderResources, insertFounderResourceSchema, databaseCosts, insertDatabaseCostSchema, userCertifications, insertUserCertificationSchema, csrRatingHistory } from "@shared/schema";
import { CARD_REGISTRY, getAvailableCardsForUser, getDefaultLayoutForRole, getCardsByCategory } from "@shared/dashboardCards";
import { eq, sql, and, or, isNull, not, gt, gte, lt, lte, desc, asc, inArray } from "drizzle-orm";
import { z } from "zod";
import bcrypt from "bcrypt";
import multer from "multer";
import { ObjectStorageService } from "./objectStorage";
import * as stripeService from "./stripe-service";
import Stripe from "stripe";
import { type TierName, type Currency, TIER_CONFIG, ADDON_CONFIG } from "../shared/stripe-config";
import { checkSubscriptionLimits } from "./subscription-middleware";
import { getTodayString, toLocalDateString, parseLocalDate, getStartOfWeek, getEndOfWeek } from "./dateUtils";
import { getDefaultElevation, usesPercentageProgress } from "@shared/jobTypes";
import { getProjectTimezone, sessionOverlapsDay, getZonedDayBounds } from "./timezoneUtils";
import { Resend } from "resend";
import rateLimit from "express-rate-limit";
import OpenAI from "openai";
import { generateQuizFromDocument } from "./gemini";
import helpRouter from "./routes/help";
import { startPhotoUploadWorker, runBucketHealthCheck } from "./residentPhotoWorker";
import { queryAssistant } from "./services/assistantService";
import { sendQuoteNotificationSMS } from "./services/twilio";
import { sendTeamInvitationSMS, sendInvitationAcceptedSMS } from "./services/twilioService";
import convert from "heic-convert";

// SECURITY: Rate limiting for login endpoint to prevent brute force attacks
const loginRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 login attempts per window
  message: { message: "Too many login attempts. Please try again after 15 minutes." },
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: false, // Count all attempts
});

const registrationRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // 5 registration attempts per hour per IP
  message: { message: "Too many registration attempts. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false,
});

const passwordChangeRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 password change attempts per 15 minutes
  message: { message: "Too many password change attempts. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false,
});

// SECURITY: Strict rate limiting for IRATA verification (resource-intensive Playwright operation)
const irataVerificationRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // 10 verification attempts per hour per IP
  message: { message: "Too many verification attempts. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false,
});

// SECURITY: Password strength validation
function validatePasswordStrength(password: string): { valid: boolean; message: string } {
  if (!password || password.length < 8) {
    return { valid: false, message: "Password must be at least 8 characters long" };
  }
  
  // Check for at least one uppercase letter
  if (!/[A-Z]/.test(password)) {
    return { valid: false, message: "Password must contain at least one uppercase letter" };
  }
  
  // Check for at least one lowercase letter
  if (!/[a-z]/.test(password)) {
    return { valid: false, message: "Password must contain at least one lowercase letter" };
  }
  
  // Check for at least one number
  if (!/[0-9]/.test(password)) {
    return { valid: false, message: "Password must contain at least one number" };
  }
  
  return { valid: true, message: "" };
}

// Initialize Stripe for direct API calls
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia' as any,
});

// Authentication middleware with activity tracking
export function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized - Please log in" });
  }
  
  // Update last activity timestamp asynchronously (fire and forget)
  // Skip for superuser to avoid noise
  if (req.session.userId !== 'superuser') {
    db.update(users)
      .set({ lastActivityAt: sql`NOW()` })
      .where(eq(users.id, req.session.userId))
      .execute()
      .catch(err => console.error('Failed to update lastActivityAt:', err));
  }
  
  next();
}

// Role-based access middleware
export function requireRole(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.session.userId || !req.session.role) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    if (!roles.includes(req.session.role)) {
      return res.status(403).json({ message: "Forbidden - Insufficient permissions" });
    }
    
    next();
  };
}

// Helper to normalize permissions to array format (handles string, array, or null)
function normalizePermissions(permissions: any): string[] {
  if (!permissions) return [];
  if (Array.isArray(permissions)) return permissions;
  // Handle stringified JSON array (e.g., "[\"view_inventory\"]")
  if (typeof permissions === 'string') {
    if (permissions.startsWith('[')) {
      try { return JSON.parse(permissions); } catch { return []; }
    }
    // Handle PostgreSQL array format as string (e.g., "{view_inventory,log_drops}")
    if (permissions.startsWith('{') && permissions.endsWith('}')) {
      return permissions.slice(1, -1).split(',').map(s => s.trim()).filter(Boolean);
    }
  }
  return [];
}

// Helper function to check if user can view safety documents
function canViewSafetyDocuments(user: any): boolean {
  if (!user) return false;
  
  // Company role always has access
  if (user.role === 'company') return true;
  
  // All other roles need explicit permission
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('view_safety_documents');
}

// Helper function to check if user can view Company Safety Rating (CSR)
function canViewCSR(user: any): boolean {
  if (!user) return false;
  
  // Company role always has access
  if (user.role === 'company') return true;
  
  // All other roles need explicit permission
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('view_csr');
}

// Helper function to check if user can manage clients
function canManageClients(user: any): boolean {
  if (!user) return false;
  
  // Company role always has access
  if (user.role === 'company') return true;
  
  // All other roles need explicit permission
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('manage_clients');
}

// Helper function to get CSR rating label and color based on percentage
// Per SCR.RATING.md: 90-100% Green (Excellent), 70-89% Yellow (Good), 50-69% Orange (Needs Improvement), <50% Red (Poor)
function getCsrRatingInfo(percentage: number): { label: string; color: string } {
  if (percentage >= 90) {
    return { label: 'Excellent', color: 'green' };
  } else if (percentage >= 70) {
    return { label: 'Good', color: 'yellow' };
  } else if (percentage >= 50) {
    return { label: 'Needs Improvement', color: 'orange' };
  } else {
    return { label: 'Poor', color: 'red' };
  }
}

// Shared CSR calculation function - used by both company and property manager endpoints
// This ensures consistent CSR values across all views
// Exported for use in assistantService
export async function calculateCompanyCSR(companyId: string, storage: any, skipHistoryRecording: boolean = false): Promise<any> {
  // 1. Company Documentation Points
  const companyDocuments = await storage.getCompanyDocuments(companyId);
  const hasHealthSafety = companyDocuments.some((doc: any) => doc.documentType === 'health_safety_manual');
  const hasCompanyPolicy = companyDocuments.some((doc: any) => doc.documentType === 'company_policy');
  const hasInsurance = companyDocuments.some((doc: any) => doc.documentType === 'certificate_of_insurance');
  
  const companyDocsUploaded = (hasHealthSafety ? 1 : 0) + (hasCompanyPolicy ? 1 : 0) + (hasInsurance ? 1 : 0);
  const companyDocumentationPoints = Math.round((companyDocsUploaded / 3) * 100) / 100;
  const documentationRating = Math.round((companyDocsUploaded / 3) * 100);
  
  // 2. Toolbox Meeting Compliance
  const TOOLBOX_COVERAGE_DAYS = 7;
  const projects = await storage.getProjectsByCompany(companyId);
  const meetings = await storage.getToolboxMeetingsByCompany(companyId);
  
  const allWorkSessions: any[] = [];
  for (const project of projects) {
    const projectSessions = await storage.getWorkSessionsByProject(project.id, companyId);
    allWorkSessions.push(...projectSessions);
  }
  
  const projectMeetingDates: Map<string, Date[]> = new Map();
  const otherMeetingDates: Date[] = [];
  
  meetings.forEach((meeting: any) => {
    if (meeting.meetingDate) {
      const meetingDate = new Date(meeting.meetingDate);
      if (meeting.projectId === 'other') {
        otherMeetingDates.push(meetingDate);
      } else if (meeting.projectId) {
        if (!projectMeetingDates.has(meeting.projectId)) {
          projectMeetingDates.set(meeting.projectId, []);
        }
        projectMeetingDates.get(meeting.projectId)!.push(meetingDate);
      }
    }
  });
  
  const isDateCovered = (projectId: string, workDateStr: string): boolean => {
    const workDate = new Date(workDateStr);
    const projectMeetings = projectMeetingDates.get(projectId) || [];
    for (const meetingDate of projectMeetings) {
      const daysDiff = Math.abs(Math.floor((workDate.getTime() - meetingDate.getTime()) / (1000 * 60 * 60 * 24)));
      if (daysDiff <= TOOLBOX_COVERAGE_DAYS) return true;
    }
    for (const meetingDate of otherMeetingDates) {
      const daysDiff = Math.abs(Math.floor((workDate.getTime() - meetingDate.getTime()) / (1000 * 60 * 60 * 24)));
      if (daysDiff <= TOOLBOX_COVERAGE_DAYS) return true;
    }
    return false;
  };
  
  const workSessionDays = new Set<string>();
  allWorkSessions.forEach((session: any) => {
    if (session.projectId && session.workDate) {
      workSessionDays.add(`${session.projectId}|${session.workDate}`);
    }
  });
  
  let toolboxDaysWithMeeting = 0;
  let toolboxTotalDays = 0;
  workSessionDays.forEach((dayKey) => {
    toolboxTotalDays++;
    const [projectId, workDate] = dayKey.split('|');
    if (isDateCovered(projectId, workDate)) toolboxDaysWithMeeting++;
  });
  
  const toolboxMeetingRating = toolboxTotalDays > 0 ? Math.round((toolboxDaysWithMeeting / toolboxTotalDays) * 100) : 100;
  
  // 3. Harness Inspection Points
  const harnessInspections = await storage.getHarnessInspectionsByCompany(companyId);
  
  const normalizeDateToString = (date: any): string => {
    if (!date) return '';
    if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) return date;
    const d = new Date(date);
    if (isNaN(d.getTime())) return '';
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
  };
  
  let harnessInspectionPoints = 0;
  let harnessRequiredInspections = 0;
  let harnessCompletedInspections = 0;
  const harnessProjectBreakdown: any[] = [];
  
  for (const project of projects) {
    if (project.status === 'deleted') continue;
    const projectSessions = allWorkSessions.filter((s: any) => s.projectId === project.id);
    
    if (projectSessions.length === 0) continue;
    
    let completedInspectionsForProject = 0;
    let applicableWorkSessionsForProject = 0;
    
    for (const session of projectSessions) {
      if (!session.employeeId || !session.workDate) continue;
      const dateStr = normalizeDateToString(session.workDate);
      
      // Find any inspection for this worker on this date
      const workerInspection = harnessInspections.find((insp: any) =>
        insp.workerId === session.employeeId && 
        normalizeDateToString(insp.inspectionDate) === dateStr
      );
      
      // Skip work sessions where inspection is not_applicable (ground crew, ground-level work)
      if (workerInspection?.overallStatus === "not_applicable") {
        continue;
      }
      
      // Count this as an applicable work session that requires inspection
      applicableWorkSessionsForProject++;
      
      // Count as completed if there's a pass or fail inspection
      if (workerInspection && (workerInspection.overallStatus === "pass" || workerInspection.overallStatus === "fail")) {
        completedInspectionsForProject++;
      }
    }
    
    harnessRequiredInspections += applicableWorkSessionsForProject;
    harnessCompletedInspections += completedInspectionsForProject;
    
    const projectPoints = applicableWorkSessionsForProject > 0 ? completedInspectionsForProject / applicableWorkSessionsForProject : 0;
    harnessInspectionPoints += projectPoints;
    
    harnessProjectBreakdown.push({
      projectId: project.id,
      projectName: project.name,
      workSessions: applicableWorkSessionsForProject,
      inspections: completedInspectionsForProject,
      points: Math.round(projectPoints * 100) / 100
    });
  }
  
  harnessInspectionPoints = Math.round(harnessInspectionPoints * 100) / 100;
  const harnessInspectionRating = harnessRequiredInspections > 0 ? Math.round((harnessCompletedInspections / harnessRequiredInspections) * 100) : 100;
  
  // 4. Employee Document Review Points
  const documentReviews = await storage.getDocumentReviewSignaturesByCompany(companyId);
  const companyEmployees = await storage.getAllEmployees(companyId);
  const companyOwner = await storage.getUserById(companyId);
  const totalEmployees = companyOwner ? companyEmployees.length + 1 : companyEmployees.length;
  
  const requiredDocTypes = ['health_safety_manual', 'company_policy', 'safe_work_procedure', 'safe_work_practice'];
  const now = new Date();
  
  const requiredDocs = companyDocuments.filter((doc: any) => {
    if (!requiredDocTypes.includes(doc.documentType)) return false;
    if (!doc.graceEndsAt) return true;
    const graceEnd = new Date(doc.graceEndsAt);
    return graceEnd <= now;
  });
  
  const totalRequiredDocs = requiredDocs.length;
  const totalRequiredSignatures = totalEmployees * totalRequiredDocs;
  const signedReviews = documentReviews.filter((r: any) => r.signedAt).length;
  const pendingReviews = totalRequiredSignatures - signedReviews;
  const documentReviewRating = totalRequiredSignatures > 0 ? Math.round((signedReviews / totalRequiredSignatures) * 100) : 100;
  
  let employeeDocReviewPoints = 0;
  const allStaffIds = companyOwner ? [companyOwner.id, ...companyEmployees.map((e: any) => e.id)] : companyEmployees.map((e: any) => e.id);
  
  for (const staffId of allStaffIds) {
    if (totalRequiredDocs === 0) {
      employeeDocReviewPoints += 1;
      continue;
    }
    const signedByEmployee = documentReviews.filter((r: any) => r.employeeId === staffId && r.signedAt).length;
    const employeePoints = signedByEmployee / totalRequiredDocs;
    employeeDocReviewPoints += employeePoints;
  }
  employeeDocReviewPoints = Math.round(employeeDocReviewPoints * 100) / 100;
  
  // 5. Quiz Completion Points
  const companyQuizzes = await storage.getQuizzesByCompanyId(companyId);
  const allQuizAttempts = await storage.getAllQuizAttemptsByCompanyId(companyId);
  
  let quizCompletionPoints = 0;
  const totalQuizzes = companyQuizzes.length;
  const totalQuizRequirements = totalQuizzes * totalEmployees;
  
  const passedQuizzes: Map<string, Set<string>> = new Map();
  for (const attempt of allQuizAttempts) {
    if (attempt.passed && attempt.employeeId && attempt.quizId) {
      if (!passedQuizzes.has(attempt.employeeId)) passedQuizzes.set(attempt.employeeId, new Set());
      passedQuizzes.get(attempt.employeeId)!.add(attempt.quizId);
    }
  }
  
  for (const staffId of allStaffIds) {
    const passedByEmployee = passedQuizzes.get(staffId);
    if (passedByEmployee) {
      for (const quiz of companyQuizzes) {
        if (passedByEmployee.has(quiz.id)) quizCompletionPoints += 1;
      }
    }
  }
  
  quizCompletionPoints = Math.round(quizCompletionPoints * 100) / 100;
  const quizCompletionRating = totalQuizRequirements > 0 ? Math.round((quizCompletionPoints / totalQuizRequirements) * 100) : 100;
  
  // 6. Project Documentation Points
  const flhaForms = await storage.getFlhaFormsByCompany(companyId);
  
  let projectDocumentationPoints = 0;
  let projectsWithAnchorInspection = 0;
  let projectsWithRopeAccessPlan = 0;
  let projectsWithFLHA = 0;
  let projectsWithToolboxMeeting = 0;
  let activeProjectCount = 0;
  let elevationProjectCount = 0;
  const projectDocBreakdown: any[] = [];
  
  for (const project of projects) {
    if (project.status === 'deleted') continue;
    activeProjectCount++;
    const requiresElevation = project.requiresElevation === true;
    if (requiresElevation) elevationProjectCount++;
    
    let docsPresent = 0;
    const docsRequired = requiresElevation ? 4 : 2;
    
    const hasFlha = flhaForms.some((f: any) => f.projectId === project.id);
    if (hasFlha) { docsPresent++; projectsWithFLHA++; }
    
    const hasToolbox = meetings.some((m: any) => m.projectId === project.id);
    if (hasToolbox) { docsPresent++; projectsWithToolboxMeeting++; }
    
    if (requiresElevation) {
      const hasRopeAccessPlan = companyDocuments.some((doc: any) => doc.documentType === 'rope_access_plan' && doc.projectId === project.id);
      if (hasRopeAccessPlan) { docsPresent++; projectsWithRopeAccessPlan++; }
      
      // Anchor inspection is stored on the project itself as a certificate URL
      if (project.anchorInspectionCertificateUrl) { docsPresent++; projectsWithAnchorInspection++; }
    }
    
    const projectPoints = docsPresent / docsRequired;
    projectDocumentationPoints += projectPoints;
    
    projectDocBreakdown.push({
      projectId: project.id,
      projectName: project.name,
      isElevation: requiresElevation,
      docsRequired,
      docsPresent,
      points: Math.round(projectPoints * 100) / 100
    });
  }
  
  projectDocumentationPoints = Math.round(projectDocumentationPoints * 100) / 100;
  const totalProjectDocsRequired = (elevationProjectCount * 4) + ((activeProjectCount - elevationProjectCount) * 2);
  const totalProjectDocsPresent = projectsWithAnchorInspection + projectsWithRopeAccessPlan + projectsWithFLHA + projectsWithToolboxMeeting;
  const projectDocumentationRating = totalProjectDocsRequired > 0 ? Math.round((totalProjectDocsPresent / totalProjectDocsRequired) * 100) : 100;
  
  // Calculate overall CSR
  const totalEarned = Math.round((harnessInspectionPoints + projectDocumentationPoints + companyDocumentationPoints + employeeDocReviewPoints + quizCompletionPoints) * 100) / 100;
  
  const maxHarnessPoints = harnessProjectBreakdown.filter((p: any) => p.workSessions > 0).length;
  const maxProjectDocPoints = projectDocBreakdown.length;
  const maxCompanyDocPoints = 1;
  const maxEmployeeDocPoints = totalEmployees;
  const maxQuizPoints = totalQuizRequirements;
  
  const totalMax = maxHarnessPoints + maxProjectDocPoints + maxCompanyDocPoints + maxEmployeeDocPoints + maxQuizPoints;
  const csrRating = totalMax > 0 ? Math.round((totalEarned / totalMax) * 100) : 100;
  const { label: csrLabel, color: csrColor } = getCsrRatingInfo(csrRating);
  
  // Record CSR history only for company view (not PM view)
  if (!skipHistoryRecording) {
    const lastHistory = await storage.getLatestCsrRatingHistory(companyId);
    if (!lastHistory || lastHistory.newScore !== csrRating) {
      const previousScore = lastHistory ? lastHistory.newScore : 100;
      const delta = csrRating - previousScore;
      
      const breakdownDetails: string[] = [];
      breakdownDetails.push(`Company Documents: ${companyDocumentationPoints.toFixed(2)} / ${maxCompanyDocPoints} (${companyDocsUploaded}/3 uploaded)`);
      breakdownDetails.push(`Harness Inspections: ${harnessInspectionPoints.toFixed(2)} / ${maxHarnessPoints} (${harnessCompletedInspections} of ${harnessRequiredInspections} completed)`);
      breakdownDetails.push(`Document Reviews: ${employeeDocReviewPoints.toFixed(2)} / ${maxEmployeeDocPoints} (${signedReviews}/${totalRequiredSignatures} signatures)`);
      breakdownDetails.push(`Project Docs: ${projectDocumentationPoints.toFixed(2)} / ${maxProjectDocPoints}`);
      if (totalQuizzes > 0) {
        breakdownDetails.push(`Quiz Completion: ${quizCompletionPoints.toFixed(2)} / ${maxQuizPoints} (${quizCompletionPoints}/${totalQuizRequirements} passed)`);
      }
      
      const reason = !lastHistory 
        ? `Initial safety rating recorded: ${csrRating}% (${csrLabel})\n\nBreakdown (earned/max):\n${breakdownDetails.join('\n')}\n\nTotal: ${totalEarned.toFixed(2)} / ${totalMax}`
        : `CSR updated: ${previousScore}% -> ${csrRating}%\n\nBreakdown:\n${breakdownDetails.join('\n')}`;
      
      await storage.createCsrRatingHistory({
        companyId,
        previousScore,
        newScore: csrRating,
        delta,
        category: !lastHistory ? 'initial' : 'update',
        reason
      });
    }
  }
  
  return {
    csrRating,
    csrLabel,
    csrColor,
    overallCSR: totalEarned,
    breakdown: {
      harnessInspection: { earned: harnessInspectionPoints, max: maxHarnessPoints },
      projectDocumentation: { earned: projectDocumentationPoints, max: maxProjectDocPoints },
      companyDocumentation: { earned: companyDocumentationPoints, max: maxCompanyDocPoints },
      employeeDocumentReview: { earned: employeeDocReviewPoints, max: maxEmployeeDocPoints },
      quizCompletion: { earned: quizCompletionPoints, max: maxQuizPoints },
      harnessInspectionPoints,
      projectDocumentationPoints,
      companyDocumentationPoints,
      employeeDocReviewPoints,
      quizCompletionPoints,
      documentationRating,
      toolboxMeetingRating,
      harnessInspectionRating,
      documentReviewRating,
      projectDocumentationRating,
      quizCompletionRating
    },
    totalEarned,
    totalMax,
    details: {
      hasHealthSafety,
      hasCompanyPolicy,
      hasInsurance,
      companyDocsUploaded,
      toolboxDaysWithMeeting,
      toolboxTotalDays,
      harnessCompletedInspections,
      harnessRequiredInspections,
      harnessProjectBreakdown,
      documentReviewsSigned: signedReviews,
      documentReviewsPending: pendingReviews,
      documentReviewsTotal: totalRequiredSignatures,
      documentReviewsTotalEmployees: totalEmployees,
      documentReviewsTotalDocs: totalRequiredDocs,
      projectsWithAnchorInspection,
      projectsWithRopeAccessPlan,
      projectsWithFLHA,
      projectsWithToolboxMeeting,
      activeProjectCount,
      elevationProjectCount,
      projectDocBreakdown,
      quizCompletionsPassed: quizCompletionPoints,
      quizCompletionsRequired: totalQuizRequirements,
      totalQuizzes,
      totalEmployeesForQuizzes: totalEmployees
    }
  };
}

// Helper function to check if user can view sensitive documents
// (Incident Reports, Damage Reports, COI, Equipment Inspections)
function canViewSensitiveDocuments(user: any): boolean {
  if (!user) return false;
  
  // Company role always has access
  if (user.role === 'company') return true;
  
  // All other roles need explicit permission
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('view_sensitive_documents');
}

// ============================================================================
// INVENTORY PERMISSION HELPERS
// ============================================================================

// Helper function to check if user can view inventory
// All employees can view inventory to manage their own kit
// Residents and property managers are NOT allowed access
const EMPLOYEE_ROLES = [
  'company', 'owner_ceo', 'human_resources', 'accounting', 'operations_manager',
  'general_supervisor', 'rope_access_supervisor', 'account_manager',
  'rope_access_tech', 'manager', 'ground_crew', 'ground_crew_supervisor', 'labourer', 'supervisor'
];

function canViewInventory(user: any): boolean {
  if (!user) return false;
  // Only employees (including all worker and management roles) can view inventory
  return EMPLOYEE_ROLES.includes(user.role);
}

// Helper function to check if user can manage inventory (add/edit/delete)
function canManageInventory(user: any): boolean {
  if (!user) return false;
  if (user.role === 'company') return true;
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('manage_inventory');
}

// Helper function to check if user can assign gear to employees
function canAssignGear(user: any): boolean {
  if (!user) return false;
  if (user.role === 'company') return true;
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('assign_gear');
}

// Helper function to check if user can view all gear assignments
function canViewGearAssignments(user: any): boolean {
  if (!user) return false;
  if (user.role === 'company') return true;
  const permissions = normalizePermissions(user.permissions);
  return permissions.includes('view_gear_assignments');
}

// Overtime calculation utility
interface OvertimeBreakdown {
  regularHours: number;
  overtimeHours: number;
  doubleTimeHours: number;
  totalHours: number;
}

async function calculateOvertimeHours(
  companyId: string,
  employeeId: string,
  workDate: Date,
  startTime: Date,
  endTime: Date
): Promise<OvertimeBreakdown> {
  // Calculate total hours for this session
  const totalHours = (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);
  
  // Get payroll configuration for the company
  const payrollConfig = await storage.getPayPeriodConfig(companyId);
  
  // If no config exists, all hours are regular (no overtime)
  if (!payrollConfig) {
    console.log(`[OVERTIME CALC] No payroll config found for company ${companyId}. All hours are regular.`);
    return {
      regularHours: parseFloat(totalHours.toFixed(2)),
      overtimeHours: 0,
      doubleTimeHours: 0,
      totalHours: parseFloat(totalHours.toFixed(2))
    };
  }
  
  const overtimeThreshold = parseFloat(payrollConfig.overtimeHoursThreshold || '8');
  const doubleTimeThreshold = parseFloat(payrollConfig.doubleTimeHoursThreshold || '12');
  const overtimeTrigger = payrollConfig.overtimeTriggerType || 'daily';
  const doubleTimeTrigger = payrollConfig.doubleTimeTriggerType || 'daily';
  
  // If overtime is disabled (set to "none"), all hours are regular
  if (overtimeTrigger === 'none') {
    console.log(`[OVERTIME CALC] Overtime disabled for company ${companyId}. All hours are regular.`);
    return {
      regularHours: parseFloat(totalHours.toFixed(2)),
      overtimeHours: 0,
      doubleTimeHours: 0,
      totalHours: parseFloat(totalHours.toFixed(2))
    };
  }
  
  let applicableHours = totalHours;
  
  // If weekly triggers are used, calculate total hours for the week
  if (overtimeTrigger === 'weekly' || doubleTimeTrigger === 'weekly') {
    const workDateObj = new Date(workDate);
    const dayOfWeek = workDateObj.getDay();
    const startOfWeek = new Date(workDateObj);
    startOfWeek.setDate(workDateObj.getDate() - dayOfWeek);
    startOfWeek.setHours(0, 0, 0, 0);
    
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6);
    endOfWeek.setHours(23, 59, 59, 999);
    
    // Get all sessions for this employee across all projects (we'll filter by date manually)
    // Note: getWorkSessionsByEmployee only takes employeeId and projectId
    // For weekly overtime calc, we need all sessions regardless of project
    const allSessions = await db.select().from(workSessions)
      .where(eq(workSessions.employeeId, employeeId));
    
    // Filter sessions to this week's date range
    const weekSessions = allSessions.filter(session => {
      const sessionDate = new Date(session.workDate);
      return sessionDate >= startOfWeek && sessionDate <= endOfWeek;
    });
    
    // Calculate existing hours this week
    let existingHours = 0;
    for (const session of weekSessions) {
      if (session.endTime && session.id !== 'CURRENT') {
        const sessionHours = (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
        existingHours += sessionHours;
      }
    }
    
    applicableHours = existingHours + totalHours;
  }
  
  let regularHours = 0;
  let overtimeHours = 0;
  let doubleTimeHours = 0;
  
  // Calculate breakdown based on thresholds
  if (applicableHours <= overtimeThreshold) {
    // All regular time
    regularHours = totalHours;
  } else if (doubleTimeTrigger === 'none' || applicableHours <= doubleTimeThreshold) {
    // Mix of regular and overtime (no double time or not reached double time threshold)
    const hoursIntoOvertime = applicableHours - overtimeThreshold;
    if (totalHours <= hoursIntoOvertime) {
      // This entire session is overtime
      overtimeHours = totalHours;
    } else {
      // Part regular, part overtime
      regularHours = totalHours - hoursIntoOvertime;
      overtimeHours = hoursIntoOvertime;
    }
  } else {
    // Mix of regular, overtime, and double time
    const hoursIntoDoubleTime = applicableHours - doubleTimeThreshold;
    const overtimeRange = doubleTimeThreshold - overtimeThreshold;
    
    if (totalHours <= hoursIntoDoubleTime) {
      // This entire session is double time
      doubleTimeHours = totalHours;
    } else if (applicableHours - totalHours >= doubleTimeThreshold) {
      // This session starts after double time threshold
      doubleTimeHours = totalHours;
    } else if (applicableHours - totalHours >= overtimeThreshold) {
      // This session starts in overtime range
      const hoursBeforeDoubleTime = doubleTimeThreshold - (applicableHours - totalHours);
      overtimeHours = hoursBeforeDoubleTime;
      doubleTimeHours = totalHours - hoursBeforeDoubleTime;
    } else {
      // This session spans all three categories
      const regularPortion = overtimeThreshold - (applicableHours - totalHours);
      regularHours = regularPortion > 0 ? regularPortion : 0;
      
      const remainingAfterRegular = totalHours - regularHours;
      if (remainingAfterRegular <= overtimeRange) {
        overtimeHours = remainingAfterRegular;
      } else {
        overtimeHours = overtimeRange;
        doubleTimeHours = remainingAfterRegular - overtimeRange;
      }
    }
  }
  
  const result = {
    regularHours: parseFloat(regularHours.toFixed(2)),
    overtimeHours: parseFloat(overtimeHours.toFixed(2)),
    doubleTimeHours: parseFloat(doubleTimeHours.toFixed(2)),
    totalHours: parseFloat(totalHours.toFixed(2))
  };
  
  console.log(`[OVERTIME CALC] Employee ${employeeId}, Date ${workDate.toISOString().split('T')[0]}`);
  console.log(`[OVERTIME CALC] Session: ${totalHours.toFixed(2)}h total`);
  console.log(`[OVERTIME CALC] Thresholds: OT=${overtimeThreshold}h (${overtimeTrigger}), DT=${doubleTimeThreshold}h (${doubleTimeTrigger})`);
  console.log(`[OVERTIME CALC] Breakdown: Regular=${result.regularHours}h, OT=${result.overtimeHours}h, DT=${result.doubleTimeHours}h`);
  
  return result;
}

// Generate unique 10-character resident code using cryptographically secure randomness
// Provides ~50 bits of entropy (32^10 â‰ˆ 2^50) to resist brute-force attacks
async function generateResidentCode(): Promise<string> {
  const crypto = await import('crypto');
  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excluding confusing characters like 0, O, 1, I
  const codeLength = 10;
  const maxAttempts = 10; // Prevent infinite loops in case of database issues
  
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    // Generate 10-character code using crypto.randomBytes for security
    const randomBytes = crypto.randomBytes(codeLength);
    let code = '';
    
    for (let i = 0; i < codeLength; i++) {
      const randomIndex = randomBytes[i] % characters.length;
      code += characters.charAt(randomIndex);
    }
    
    // Check if code already exists
    const existing = await storage.getUserByResidentCode(code);
    if (!existing) {
      return code;
    }
  }
  
  throw new Error('Failed to generate unique resident code after maximum attempts');
}

async function generatePropertyManagerCode(): Promise<string> {
  const crypto = await import('crypto');
  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excluding confusing characters like 0, O, 1, I
  const codeLength = 10;
  const maxAttempts = 10; // Prevent infinite loops in case of database issues
  
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    // Generate 10-character code using crypto.randomBytes for security
    const randomBytes = crypto.randomBytes(codeLength);
    let code = '';
    
    for (let i = 0; i < codeLength; i++) {
      const randomIndex = randomBytes[i] % characters.length;
      code += characters.charAt(randomIndex);
    }
    
    // Check if code already exists
    const existing = await storage.getUserByPropertyManagerCode(code);
    if (!existing) {
      return code;
    }
  }
  
  // If we couldn't generate a unique code after max attempts, throw error
  throw new Error('Unable to generate unique property manager code. Please try again.');
}

// Generate unique 12-character referral code for technicians using cryptographically secure randomness
async function generateReferralCode(): Promise<string> {
  const crypto = await import('crypto');
  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excluding confusing characters like 0, O, 1, I
  const codeLength = 12;
  const maxAttempts = 10; // Prevent infinite loops in case of database issues
  
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    // Generate 12-character code using crypto.randomBytes for security
    const randomBytes = crypto.randomBytes(codeLength);
    let code = '';
    
    for (let i = 0; i < codeLength; i++) {
      const randomIndex = randomBytes[i] % characters.length;
      code += characters.charAt(randomIndex);
    }
    
    // Check if code already exists
    const existing = await storage.getUserByReferralCode(code);
    if (!existing) {
      return code;
    }
  }
  
  throw new Error('Failed to generate unique referral code after maximum attempts');
}

// Generate unique 10-character PM code for property managers using cryptographically secure randomness
async function generatePmCode(): Promise<string> {
  const crypto = await import('crypto');
  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excluding confusing characters like 0, O, 1, I
  const codeLength = 10;
  const maxAttempts = 10;
  
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const randomBytes = crypto.randomBytes(codeLength);
    let code = '';
    
    for (let i = 0; i < codeLength; i++) {
      const randomIndex = randomBytes[i] % characters.length;
      code += characters.charAt(randomIndex);
    }
    
    // Check if code already exists
    const [existing] = await db.select().from(users).where(eq(users.pmCode, code)).limit(1);
    if (!existing) {
      return code;
    }
  }
  
  throw new Error('Failed to generate unique PM code after maximum attempts');
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Helper function to check if user is superuser or staff with specific permission
  const isSuperuserOrHasPermission = (req: Request, permission: string): boolean => {
    if (req.session.userId === 'superuser') return true;
    if (req.session.role === 'staff' && req.session.staffPermissions?.includes(permission)) return true;
    return false;
  };
  // ==================== HELP CENTER ROUTES ====================
  app.use('/api/help', helpRouter);
  
  // ==================== DASHBOARD ASSISTANT SEARCH ====================
  app.post("/api/assistant/query", async (req: Request, res: Response) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      
      const { query } = req.body;
      if (!query || typeof query !== 'string' || query.length < 2) {
        return res.json({ 
          response: "", 
          results: [], 
          suggestions: [] 
        });
      }
      
      // Get user for company ID and permissions
      const user = await storage.getUserById(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      
      // Extract company ID based on role
      const companyId = user.role === 'company' ? user.id : user.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "No company context available" });
      }
      
      // Normalize permissions - handle both array and string cases
      let permissions: string[] = [];
      if (Array.isArray(user.permissions)) {
        permissions = user.permissions;
      } else if (typeof user.permissions === 'string') {
        try {
          permissions = JSON.parse(user.permissions);
        } catch {
          permissions = [];
        }
      }
      
      const result = await queryAssistant(query, companyId, user.id, user.role || 'employee', permissions);
      return res.json(result);
    } catch (error) {
      console.error("Assistant query error:", error);
      return res.status(500).json({ message: "Search failed" });
    }
  });
  
  // ==================== ADDRESS AUTOCOMPLETE ====================
  
  // Address autocomplete endpoint using Geoapify API
  app.get("/api/address-autocomplete", async (req: Request, res: Response) => {
    try {
      const { query } = req.query;
      
      if (!query || typeof query !== 'string' || query.length < 3) {
        return res.json({ results: [] });
      }
      
      const apiKey = process.env.GEOAPIFY_API_KEY;
      if (!apiKey) {
        console.error("GEOAPIFY_API_KEY not configured");
        return res.status(500).json({ message: "Address service not configured" });
      }
      
      // Filter to include both Canada (ca) and USA (us) for North American addresses
      const response = await fetch(
        `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(query)}&filter=countrycode:ca,us&format=json&apiKey=${apiKey}`
      );
      
      if (!response.ok) {
        console.error("Geoapify API error:", response.status);
        return res.status(500).json({ message: "Address lookup failed" });
      }
      
      const data = await response.json();
      
      const results = (data.results || []).map((result: any) => ({
        formatted: result.formatted || "",
        street: result.street || "",
        houseNumber: result.housenumber || "",
        city: result.city || result.town || result.village || "",
        state: result.state || result.province || "",
        country: result.country || "",
        postcode: result.postcode || "",
        latitude: result.lat || null,
        longitude: result.lon || null
      }));
      
      return res.json({ results });
    } catch (error) {
      console.error("Address autocomplete error:", error);
      return res.status(500).json({ message: "Address lookup failed" });
    }
  });

  // ==================== AUTH ROUTES ====================
  
  // Check if a unit is already linked to a resident account
  // Used during registration to detect potential unit conflicts (previous resident moved out)
  app.get("/api/check-unit-availability", async (req: Request, res: Response) => {
    try {
      const { strataPlanNumber, unitNumber } = req.query;
      
      if (!strataPlanNumber || !unitNumber) {
        return res.status(400).json({ message: "Strata plan number and unit number are required" });
      }
      
      // Find any existing resident with this strata plan + unit combination
      const existingResident = await db.select({
        id: users.id,
        name: users.name,
      }).from(users)
        .where(
          and(
            eq(users.role, 'resident'),
            eq(users.strataPlanNumber, strataPlanNumber as string),
            eq(users.unitNumber, unitNumber as string)
          )
        )
        .limit(1);
      
      if (existingResident.length > 0) {
        // Unit is already linked - return conflict info (no sensitive data)
        return res.json({
          available: false,
          unitConflict: true,
          message: "This unit is already linked to another resident account"
        });
      }
      
      // Unit is available
      return res.json({ available: true });
    } catch (error) {
      console.error("Error checking unit availability:", error);
      return res.status(500).json({ message: "Error checking unit availability" });
    }
  });
  
  // Registration endpoint - SECURITY: Rate limited to prevent abuse
  app.post("/api/register", registrationRateLimiter, async (req: Request, res: Response) => {
    try {
      const { confirmPassword, ...userData } = req.body;
      
      console.log('[Register] Received data:', JSON.stringify(userData, null, 2));
      
      // Convert empty strings to null for numeric fields
      if (userData.hourlyRate === '' || userData.hourlyRate === undefined) {
        userData.hourlyRate = null;
      }
      
      // Validate input
      const validatedData = insertUserSchema.parse(userData);
      
      // SECURITY: Check if user already exists - use generic message to prevent account enumeration
      if (validatedData.email && typeof validatedData.email === 'string') {
        const existingUser = await storage.getUserByEmail(validatedData.email);
        if (existingUser) {
          return res.status(400).json({ message: "Unable to create account with these details. If you already have an account, please try logging in." });
        }
      }
      
      if (validatedData.companyName && typeof validatedData.companyName === 'string') {
        const existingCompany = await storage.getUserByCompanyName(validatedData.companyName);
        if (existingCompany) {
          return res.status(400).json({ message: "Unable to create account with these details. If you already have an account, please try logging in." });
        }
      }
      
      let user;
      
      // For property managers: use a transaction to create user AND company link atomically
      if (validatedData.role === 'property_manager' && req.body.companyCode) {
        // Validate property manager code BEFORE starting transaction
        const company = await storage.getUserByPropertyManagerCode(req.body.companyCode);
        if (!company || company.role !== 'company') {
          return res.status(400).json({ message: "Invalid property manager code. Please check with the rope access company and try again." });
        }
        
        // Hash password before transaction (CRITICAL for security)
        const hashedPassword = await bcrypt.hash(validatedData.passwordHash, 10);
        
        // Atomic transaction: create user AND link to company
        try {
          user = await db.transaction(async (tx) => {
            // Create user with hashed password
            const [newUser] = await tx.insert(users).values({
              ...validatedData,
              passwordHash: hashedPassword,
            }).returning();
            
            // Create company link
            await tx.insert(propertyManagerCompanyLinks).values({
              propertyManagerId: newUser.id,
              companyCode: req.body.companyCode,
              companyId: company.id,
            });
            
            return newUser;
          });
        } catch (error) {
          console.error('Error creating property manager account:', error);
          // Check for PostgreSQL unique constraint violation (code 23505)
          if (error && typeof error === 'object' && 'code' in error && error.code === '23505') {
            return res.status(400).json({ message: "You are already linked to this company." });
          }
          return res.status(500).json({ message: "Failed to create account. Please try again." });
        }
      } else if (validatedData.role === 'resident' && validatedData.strataPlanNumber && validatedData.unitNumber) {
        // For residents: always use unified path with conflict detection
        // Check for existing resident with same strata + unit
        const existingResident = await db.select({
          id: users.id,
        }).from(users)
          .where(
            and(
              eq(users.role, 'resident'),
              eq(users.strataPlanNumber, validatedData.strataPlanNumber),
              eq(users.unitNumber, validatedData.unitNumber)
            )
          )
          .limit(1);
        
        const hasConflict = existingResident.length > 0;
        
        // Validate confirmUnitTakeover flag (must be boolean true if provided)
        const confirmTakeover = req.body.confirmUnitTakeover === true;
        
        if (hasConflict && !confirmTakeover) {
          // Unit is linked to another resident - ask for confirmation
          return res.status(409).json({
            message: "This unit is already linked to another resident account",
            unitConflict: true,
            requiresConfirmation: true,
            field: "unitNumber"
          });
        }
        
        // Hash password once for all resident registrations
        const hashedPassword = await bcrypt.hash(validatedData.passwordHash, 10);
        
        try {
          // Use transaction for all resident registrations to ensure atomic operations
          user = await db.transaction(async (tx) => {
            // If there's a conflict and user confirmed, unlink the old resident
            if (hasConflict && confirmTakeover) {
              await tx.update(users)
                .set({ unitNumber: null })
                .where(eq(users.id, existingResident[0].id));
            }
            
            // Create the new resident
            const [newUser] = await tx.insert(users).values({
              ...validatedData,
              passwordHash: hashedPassword,
            }).returning();
            
            return newUser;
          });
        } catch (error) {
          console.error('Error during resident registration:', error);
          // Check for unique constraint violation (e.g., duplicate email)
          if (error && typeof error === 'object' && 'code' in error && error.code === '23505') {
            return res.status(400).json({ 
              message: "Unable to create account with these details. If you already have an account, please try logging in.",
              field: "email"
            });
          }
          return res.status(500).json({ message: "Failed to create account. Please try again." });
        }
      } else {
        // For all other roles, create user normally
        user = await storage.createUser(validatedData);
      }
      
      // If this is a company user, create default payroll config and generate periods
      if (user.role === 'company') {
        try {
          // Create default semi-monthly payroll config (1st and 15th)
          await storage.createPayPeriodConfig({
            companyId: user.id,
            periodType: 'semi-monthly',
            firstPayDay: 1,
            secondPayDay: 15,
          });
          
          // Generate initial 6 pay periods
          await storage.generatePayPeriods(user.id, 6);
        } catch (error) {
          console.error('Error creating default payroll config:', error);
          // Don't fail registration if payroll setup fails
        }
      }
      
      // Create session and auto-login the user
      req.session.userId = user.id;
      req.session.role = user.role;
      
      console.log(`[Register] Session created for ${user.role}: ${user.id}, email: ${user.email}`);
      
      // Save session before responding (critical for production)
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error(`[Register] Session save error:`, err);
            reject(err);
          } else {
            console.log(`[Register] Session saved successfully for ${user.email}`);
            resolve();
          }
        });
      });
      
      // Return user without password
      const { passwordHash, ...userWithoutPassword } = user;
      console.log(`[Register] Returning success response for ${user.role}: ${user.email}`);
      res.json({ user: userWithoutPassword });
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error('[Register] Validation errors:', JSON.stringify(error.errors, null, 2));
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Registration error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Registration with license (for new customers after Stripe checkout) - SECURITY: Rate limited
  app.post("/api/register-with-license", registrationRateLimiter, async (req: Request, res: Response) => {
    try {
      const { 
        companyName, 
        email, 
        password, 
        licenseKey, 
        stripeCustomerId, 
        stripeSubscriptionId, 
        tier 
      } = req.body;

      console.log('[Register-License] Creating account with license:', { companyName, email, licenseKey });

      // Validation
      if (!companyName || !email || !password || !licenseKey) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      // CRITICAL SECURITY: Use database transaction with row-level locking to prevent race conditions
      // ALL database operations must happen within this transaction
      const result = await db.transaction(async (tx) => {
        // Lock the license row with SELECT FOR UPDATE to prevent concurrent access
        const validLicense = await tx.execute(
          sql`SELECT * FROM ${licenseKeys} WHERE ${licenseKeys.licenseKey} = ${licenseKey} FOR UPDATE`
        );

        if (!validLicense.rows || validLicense.rows.length === 0) {
          console.error('[Register-License] Invalid license key:', licenseKey);
          throw new Error("Invalid license key");
        }

        const license = validLicense.rows[0] as any;

        // Check if license has already been used (while holding the lock)
        if (license.used === true) {
          console.error('[Register-License] License key already used:', licenseKey);
          throw new Error("License key has already been used");
        }

        // Verify the tier and Stripe IDs match the license record
        if (license.tier !== tier) {
          console.error('[Register-License] Tier mismatch:', { provided: tier, expected: license.tier });
          throw new Error("License tier does not match");
        }

        if (license.stripe_customer_id !== stripeCustomerId || 
            license.stripe_subscription_id !== stripeSubscriptionId) {
          console.error('[Register-License] Stripe ID mismatch');
          throw new Error("Stripe information does not match license");
        }

        // SECURITY: Check if user already exists - use generic message to prevent account enumeration
        const existingUserByEmail = await tx.query.users.findFirst({
          where: eq(users.email, email),
        });

        if (existingUserByEmail) {
          throw new Error("Unable to create account with these details. If you already have an account, please try logging in.");
        }

        const existingUserByCompanyName = await tx.query.users.findFirst({
          where: eq(users.companyName, companyName),
        });

        if (existingUserByCompanyName) {
          throw new Error("Unable to create account with these details. If you already have an account, please try logging in.");
        }

        // Hash password
        const passwordHash = await bcrypt.hash(password, 10);

        // Get tier configuration
        const tierConfig = TIER_CONFIG[license.tier as TierName];

        // Create user with subscription data (using transaction client)
        const [user] = await tx.insert(users).values({
          companyName,
          email,
          passwordHash,
          role: 'company',
          stripeCustomerId: license.stripe_customer_id,
          stripeSubscriptionId: license.stripe_subscription_id,
          subscriptionTier: license.tier,
          subscriptionStatus: 'trialing',
          licenseKey: licenseKey, // Store license key in users table
        }).returning();

        if (!user) {
          throw new Error("Failed to create user");
        }

        console.log('[Register-License] User created:', user.id);

        // Mark license key as used (within the same transaction)
        await tx.update(licenseKeys)
          .set({ 
            used: true, 
            usedByUserId: user.id,
            usedAt: new Date(),
          })
          .where(eq(licenseKeys.licenseKey, licenseKey));
        
        console.log('[Register-License] License key marked as used:', licenseKey);

        return user;
      });

      // Create default payroll config (outside transaction - not critical if it fails)
      try {
        await storage.createPayPeriodConfig({
          companyId: result.id,
          periodType: 'semi-monthly',
          firstPayDay: 1,
          secondPayDay: 15,
        });
        await storage.generatePayPeriods(result.id, 6);
        console.log('[Register-License] Payroll config created');
      } catch (error) {
        console.error('[Register-License] Payroll setup error:', error);
        // Don't fail registration
      }

      // Create session
      req.session.userId = result.id;
      req.session.role = result.role;

      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      console.log('[Register-License] Registration complete for:', email);

      // Return user without password
      const { passwordHash: _, ...userWithoutPassword } = result;
      res.json({ user: userWithoutPassword });
    } catch (error: any) {
      console.error('[Register-License] Error:', error);
      // Check for specific error messages from transaction
      const message = error.message || "Registration failed";
      res.status(400).json({ message });
    }
  });

  // Technician Self-Registration - SECURITY: Rate limited, public endpoint
  const technicianUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max per file
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
        cb(null, true);
      } else {
        cb(new Error('Only image or PDF files are allowed'));
      }
    }
  }).fields([
    { name: 'certificationCard', maxCount: 1 },
    { name: 'voidCheque', maxCount: 1 },
    { name: 'driversLicense', maxCount: 1 },
    { name: 'driversAbstract', maxCount: 1 },
    { name: 'firstAidCertificate', maxCount: 1 },
  ]);

  app.post("/api/technician-register", registrationRateLimiter, technicianUpload, async (req: Request, res: Response) => {
    try {
      const {
        firstName,
        lastName,
        certification,
        irataLevel,
        irataLicenseNumber,
        spratLevel,
        spratLicenseNumber,
        logbookTotalHours,
        ropeAccessStartDate,
        streetAddress,
        city,
        provinceState,
        country,
        postalCode,
        email,
        phone,
        password,
        emergencyContactName,
        emergencyContactPhone,
        emergencyContactRelationship,
        socialInsuranceNumber,
        bankTransitNumber,
        bankInstitutionNumber,
        bankAccountNumber,
        driversLicenseNumber,
        driversLicenseIssuedDate,
        driversLicenseExpiry,
        birthday,
        specialMedicalConditions,
        hasFirstAid,
        firstAidType,
        firstAidExpiry,
        companyCode, // Optional - code to link to a specific company
        referralCodeInput, // Optional - referral code from another technician
      } = req.body;

      console.log('[Technician-Register] Received registration:', { firstName, lastName, email, certification, referralCodeInput });

      // Validate required fields
      if (!firstName || !lastName) {
        return res.status(400).json({ message: "First and last name are required" });
      }
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ message: "Invalid email format" });
      }
      if (!phone) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      if (!password) {
        return res.status(400).json({ message: "Password is required" });
      }

      // Validate password strength
      const passwordValidation = validatePasswordStrength(password);
      if (!passwordValidation.valid) {
        return res.status(400).json({ message: passwordValidation.message });
      }

      // Validate certification and license numbers
      if (certification === 'irata' || certification === 'both') {
        if (!irataLevel || !irataLicenseNumber) {
          return res.status(400).json({ message: "IRATA level and license number are required" });
        }
      }
      if (certification === 'sprat' || certification === 'both') {
        if (!spratLevel || !spratLicenseNumber) {
          return res.status(400).json({ message: "SPRAT level and license number are required" });
        }
      }

      // CRITICAL: Check for duplicate certification numbers to prevent data integrity issues
      if (irataLicenseNumber) {
        const existingIrataTech = await storage.getTechnicianByIrataLicense(irataLicenseNumber);
        if (existingIrataTech) {
          console.log(`[Technician-Register] Duplicate IRATA license rejected: ${irataLicenseNumber}`);
          return res.status(400).json({ 
            message: "An account with this IRATA license number already exists. If this is your license, please log in to your existing account or contact support." 
          });
        }
      }
      if (spratLicenseNumber) {
        const existingSpratTech = await storage.getTechnicianBySpratLicense(spratLicenseNumber);
        if (existingSpratTech) {
          console.log(`[Technician-Register] Duplicate SPRAT license rejected: ${spratLicenseNumber}`);
          return res.status(400).json({ 
            message: "An account with this SPRAT license number already exists. If this is your license, please log in to your existing account or contact support." 
          });
        }
      }

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "An account with this email already exists. Please log in instead." });
      }

      // Validate referral code if provided and get referrer info
      let referredByUserId: string | null = null;
      let referredByCode: string | null = null;
      
      if (referralCodeInput && referralCodeInput.trim()) {
        const referrer = await storage.getUserByReferralCode(referralCodeInput.trim().toUpperCase());
        if (!referrer) {
          return res.status(400).json({ message: "Invalid referral code. Please check and try again." });
        }
        // Verify the referrer is an active technician
        if (referrer.role !== 'rope_access_tech') {
          return res.status(400).json({ message: "Invalid referral code. Please check and try again." });
        }
        referredByUserId = referrer.id;
        referredByCode = referralCodeInput.trim().toUpperCase();
        console.log(`[Technician-Register] Valid referral code from ${referrer.name} (${referrer.id})`);
      }

      // Generate unique referral code for the new technician
      const newReferralCode = await generateReferralCode();
      console.log(`[Technician-Register] Generated referral code: ${newReferralCode}`);

      // Handle file uploads
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };
      const uploadedUrls: { [key: string]: string } = {};
      const objectStorageService = new ObjectStorageService();

      if (files) {
        for (const [fieldName, fileArray] of Object.entries(files)) {
          if (fileArray && fileArray.length > 0) {
            const file = fileArray[0];
            const timestamp = Date.now();
            const extension = file.mimetype === 'application/pdf' ? 'pdf' : file.mimetype.split('/')[1];
            const filename = `technician-${fieldName}-${timestamp}.${extension}`;
            
            try {
              const url = await objectStorageService.uploadPublicFile(filename, file.buffer, file.mimetype);
              uploadedUrls[fieldName] = url;
              console.log(`[Technician-Register] Uploaded ${fieldName}:`, url);
            } catch (uploadError) {
              console.error(`[Technician-Register] Failed to upload ${fieldName}:`, uploadError);
            }
          }
        }
      }

      // Build IRATA documents array
      const irataDocuments: string[] = [];
      if (uploadedUrls.certificationCard) {
        irataDocuments.push(uploadedUrls.certificationCard);
      }

      // Build driver's license documents array
      const driversLicenseDocuments: string[] = [];
      if (uploadedUrls.driversLicense) {
        driversLicenseDocuments.push(uploadedUrls.driversLicense);
      }
      if (uploadedUrls.driversAbstract) {
        driversLicenseDocuments.push(uploadedUrls.driversAbstract);
      }

      // Build bank documents array
      const bankDocuments: string[] = [];
      if (uploadedUrls.voidCheque) {
        bankDocuments.push(uploadedUrls.voidCheque);
      }

      // Build first aid documents array
      const firstAidDocuments: string[] = [];
      if (uploadedUrls.firstAidCertificate) {
        firstAidDocuments.push(uploadedUrls.firstAidCertificate);
      }

      // Determine tech level from IRATA or SPRAT
      let techLevel = null;
      if (certification === 'irata' || certification === 'both') {
        techLevel = `Level ${irataLevel}`;
      } else if (certification === 'sprat') {
        techLevel = `Level ${spratLevel}`;
      }

      // Format IRATA license number with prefix (e.g., "1/123456")
      const formattedIrataLicense = irataLevel && irataLicenseNumber 
        ? `${irataLevel}/${irataLicenseNumber}` 
        : null;

      // Create the technician user (pending company approval)
      const user = await storage.createUser({
        name: `${firstName} ${lastName}`,
        email,
        role: 'rope_access_tech',
        passwordHash: password, // storage.createUser will hash this
        techLevel,
        companyId: null, // Will be linked to company after approval
        
        // Address fields
        employeeStreetAddress: streetAddress,
        employeeCity: city,
        employeeProvinceState: provinceState,
        employeeCountry: country,
        employeePostalCode: postalCode,
        
        // Contact info
        employeePhoneNumber: phone,
        smsNotificationsEnabled: true,
        emergencyContactName,
        emergencyContactPhone,
        emergencyContactRelationship: emergencyContactRelationship || null,
        
        // Sensitive data
        socialInsuranceNumber: socialInsuranceNumber || null,
        
        // Bank info
        bankTransitNumber: bankTransitNumber || null,
        bankInstitutionNumber: bankInstitutionNumber || null,
        bankAccountNumber: bankAccountNumber || null,
        bankDocuments: bankDocuments.length > 0 ? bankDocuments : [],
        
        // Driver's license
        driversLicenseNumber: driversLicenseNumber || null,
        driversLicenseExpiry: driversLicenseExpiry || null,
        driversLicenseDocuments: driversLicenseDocuments.length > 0 ? driversLicenseDocuments : [],
        
        // Personal info
        birthday: birthday || null,
        specialMedicalConditions: specialMedicalConditions || null,
        
        // IRATA certification
        irataLevel: irataLevel ? `Level ${irataLevel}` : null,
        irataLicenseNumber: formattedIrataLicense,
        irataDocuments: irataDocuments.length > 0 ? irataDocuments : [],
        
        // SPRAT certification
        spratLevel: spratLevel ? `Level ${spratLevel}` : null,
        spratLicenseNumber: spratLicenseNumber || null,
        
        // First aid certification
        hasFirstAid: hasFirstAid === 'true',
        firstAidType: firstAidType || null,
        firstAidExpiry: firstAidExpiry || null,
        firstAidDocuments: firstAidDocuments.length > 0 ? firstAidDocuments : [],
        
        // Baseline logbook hours (optional - for future hour tracking accuracy)
        irataBaselineHours: logbookTotalHours ? logbookTotalHours : "0",
        
        // Rope access career start date (for experience calculation)
        ropeAccessStartDate: ropeAccessStartDate || null,
        
        // Start date - use timezone-safe utility
        startDate: getTodayString(),
        
        // Referral tracking
        referralCode: newReferralCode,
        referredByUserId: referredByUserId,
        referredByCode: referredByCode,
      });

      console.log('[Technician-Register] User created:', user.id);

      // Create session and auto-login the technician
      req.session.userId = user.id;
      req.session.role = user.role;
      
      console.log(`[Technician-Register] Session created for technician: ${user.id}, email: ${user.email}`);
      
      // Save session before responding
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error(`[Technician-Register] Session save error:`, err);
            reject(err);
          } else {
            console.log(`[Technician-Register] Session saved successfully for ${user.email}`);
            resolve();
          }
        });
      });

      // Return success with referral code and user data
      const { passwordHash, ...userWithoutPassword } = user;
      res.json({ 
        success: true,
        message: "Registration completed successfully.",
        referralCode: newReferralCode,
        user: userWithoutPassword,
      });
    } catch (error: any) {
      console.error('[Technician-Register] Error:', error);
      res.status(500).json({ message: error.message || "Registration failed" });
    }
  });

  // Ground crew self-registration endpoint - SECURITY: Rate limited to prevent abuse
  app.post("/api/ground-crew-register", registrationRateLimiter, async (req: Request, res: Response) => {
    try {
      const {
        firstName,
        lastName,
        email,
        password,
        phone,
        streetAddress,
        city,
        provinceState,
        country,
        postalCode,
        emergencyContactName,
        emergencyContactPhone,
        emergencyContactRelationship,
        employerCode,
      } = req.body;

      // Validate required fields
      if (!firstName || !lastName || !email || !password || !phone || !emergencyContactName || !emergencyContactPhone) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      console.log(`[Ground-Crew-Register] Starting registration for ${email}`);

      // Case-insensitive email check for existing user
      const normalizedEmail = email.toLowerCase();
      const existingUser = await storage.getUserByEmail(email);
      
      if (existingUser) {
        console.log(`[Ground-Crew-Register] Email already exists: ${email}`);
        return res.status(400).json({ message: "Email already registered" });
      }

      // If employer code is provided, validate it
      let invitingEmployer = null;
      if (employerCode) {
        // Look up the employer by their company's property manager code (used for invitations)
        const companyResults = await db.select().from(users).where(
          and(
            eq(users.role, 'company'),
            sql`LOWER(${users.propertyManagerCode}) = ${employerCode.toLowerCase()}`
          )
        ).limit(1);
        
        if (companyResults.length === 0) {
          console.log(`[Ground-Crew-Register] Invalid employer code: ${employerCode}`);
          return res.status(400).json({ message: "Invalid employer code" });
        }
        invitingEmployer = companyResults[0];
        console.log(`[Ground-Crew-Register] Valid employer code found for company: ${invitingEmployer.companyName}`);
      }

      // Create the ground crew user (pending company approval)
      const user = await storage.createUser({
        name: `${firstName} ${lastName}`,
        email,
        role: 'ground_crew',
        passwordHash: password, // storage.createUser will hash this
        companyId: invitingEmployer ? invitingEmployer.id : null,
        
        // Address fields
        employeeStreetAddress: streetAddress || null,
        employeeCity: city || null,
        employeeProvinceState: provinceState || null,
        employeeCountry: country || null,
        employeePostalCode: postalCode || null,
        
        // Contact info
        employeePhoneNumber: phone,
        smsNotificationsEnabled: true,
        emergencyContactName,
        emergencyContactPhone,
        emergencyContactRelationship: emergencyContactRelationship || null,
        
        // Start date - use timezone-safe utility
        startDate: getTodayString(),
      });

      console.log('[Ground-Crew-Register] User created:', user.id);

      // Create session and auto-login the ground crew member
      req.session.userId = user.id;
      req.session.role = user.role;
      
      console.log(`[Ground-Crew-Register] Session created for ground crew: ${user.id}, email: ${user.email}`);
      
      // Save session before responding
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error(`[Ground-Crew-Register] Session save error:`, err);
            reject(err);
          } else {
            console.log(`[Ground-Crew-Register] Session saved successfully for ${user.email}`);
            resolve();
          }
        });
      });

      // Return success with user data
      const { passwordHash, ...userWithoutPassword } = user;
      res.json({ 
        success: true,
        message: "Registration completed successfully.",
        user: userWithoutPassword,
      });
    } catch (error: any) {
      console.error('[Ground-Crew-Register] Error:', error);
      res.status(500).json({ message: error.message || "Registration failed" });
    }
  });

  // Login endpoint - SECURITY: Rate limited to prevent brute force attacks
  app.post("/api/login", loginRateLimiter, async (req: Request, res: Response) => {
    try {
      const { identifier, password } = req.body;
      
      if (!identifier || !password) {
        return res.status(400).json({ message: "Identifier and password are required" });
      }
      
      // SUPERUSER CHECK - Short-circuit before database lookup
      const superuserUsername = process.env.SUPERUSER_USERNAME || 'SuperUser';
      const superuserPasswordHash = process.env.SUPERUSER_PASSWORD_HASH;
      
      if (identifier === superuserUsername && superuserPasswordHash) {
        const isValidSuperuserPassword = await bcrypt.compare(password, superuserPasswordHash);
        
        if (isValidSuperuserPassword) {
          // Create superuser session
          req.session.userId = 'superuser';
          req.session.role = 'superuser';
          
          await new Promise<void>((resolve, reject) => {
            req.session.save((err) => {
              if (err) reject(err);
              else resolve();
            });
          });
          
          // Return superuser payload
          return res.json({
            user: {
              id: 'superuser',
              name: 'Super User',
              email: 'superuser@system',
              role: 'superuser',
              companyName: 'System Admin',
            }
          });
        }
      }
      
      // STAFF ACCOUNT CHECK - Check if this is a staff account login
      const staffAccount = await storage.verifyStaffAccountPassword(identifier, password);
      if (staffAccount) {
        // Create staff session
        req.session.userId = staffAccount.id;
        req.session.role = 'staff';
        req.session.staffPermissions = staffAccount.permissions as string[];
        
        await new Promise<void>((resolve, reject) => {
          req.session.save((err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Return staff account payload
        return res.json({
          user: {
            id: staffAccount.id,
            name: `${staffAccount.firstName} ${staffAccount.lastName}`,
            email: staffAccount.email,
            role: 'staff',
            permissions: staffAccount.permissions,
          }
        });
      }
      
      // Try to find user by email, company name, or rope access license number
      let user = await storage.getUserByEmail(identifier);
      
      if (!user) {
        user = await storage.getUserByCompanyName(identifier);
      }
      
      // Also check for IRATA/SPRAT license number (for technician login)
      if (!user) {
        user = await storage.getUserByRopeAccessLicense(identifier);
      }
      
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Verify password
      const isValidPassword = await storage.verifyPassword(password, user.passwordHash);
      
      if (!isValidPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Check if user has been terminated (only applies to non-technicians and non-ground-crew)
      // Technicians can still access their portal even if terminated from a company
      // Self-resigned users (technicians who voluntarily left) are ALWAYS allowed to log in
      const isLinkableEmployee = user.role === 'rope_access_tech' || user.role === 'ground_crew' || !!(user.ropeAccessLicenseNumber || user.irataCertNumber || user.spratCertNumber);
      const isSelfResigned = user.terminationReason === "Self-resigned";
      
      if (user.terminatedDate && !isLinkableEmployee && !isSelfResigned) {
        return res.status(403).json({ message: "Your employment has been terminated. Please contact your administrator for more information." });
      }
      
      // Check if user's seat has been suspended (company removed their seat)
      // Technicians can still access their portal even when suspended from a company
      // They just lose access to that specific company's dashboard
      if (user.suspendedAt && !isLinkableEmployee) {
        return res.status(403).json({ message: "Your account access has been suspended. Please contact your employer for more information." });
      }
      
      // Check if account has been disabled by SuperUser (this blocks everyone)
      if (user.isDisabled) {
        return res.status(403).json({ message: "Your account has been suspended. Please contact support for more information." });
      }
      
      // GENERATE CODES ON FIRST LOGIN (company role only)
      if (user.role === 'company') {
        const updates: any = {};
        
        // Generate resident code if missing
        if (!user.residentCode) {
          try {
            console.log('[Login] Generating resident code for company on first login...');
            const residentCode = await generateResidentCode();
            updates.residentCode = residentCode;
            console.log(`[Login] Resident code generated: ${residentCode}`);
          } catch (error) {
            console.error('[Login] Failed to generate resident code:', error);
          }
        }
        
        // Generate property manager code if missing
        if (!user.propertyManagerCode) {
          try {
            console.log('[Login] Generating property manager code for company on first login...');
            const propertyManagerCode = await generatePropertyManagerCode();
            updates.propertyManagerCode = propertyManagerCode;
            console.log(`[Login] Property manager code generated: ${propertyManagerCode}`);
          } catch (error) {
            console.error('[Login] Failed to generate property manager code:', error);
          }
        }
        
        // Update user if any codes were generated
        if (Object.keys(updates).length > 0) {
          await storage.updateUser(user.id, updates);
          // Refetch user from database to ensure codes are persisted
          const updatedUser = await storage.getUserById(user.id);
          if (updatedUser) {
            user = updatedUser;
          }
        }
      }
      
      // Create session
      req.session.userId = user.id;
      req.session.role = user.role;
      
      // Save session before responding (critical for production)
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      // Return user without sensitive fields (passwordHash and licenseKey)
      const { passwordHash,  ...userWithoutSensitiveData } = user;
      res.json({ user: userWithoutSensitiveData });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Logout endpoint
  app.post("/api/logout", (req: Request, res: Response) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ message: "Logged out successfully" });
    });
  });

  // Forgot Password endpoint - generates reset token and sends email
  app.post("/api/forgot-password", loginRateLimiter, async (req: Request, res: Response) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      
      // Find user by email
      const user = await storage.getUserByEmail(email);
      
      // Always return success for security (don't reveal if email exists)
      if (!user) {
        console.log(`[Forgot-Password] No user found for email: ${email}`);
        return res.json({ message: "If an account exists with that email, you will receive password reset instructions." });
      }
      
      // Generate a secure random token
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now
      
      // Hash the token before storing (for security)
      const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');
      
      // Store the hashed token and expiry in the database
      await storage.updateUser(user.id, {
        passwordResetToken: hashedToken,
        passwordResetExpires: resetExpires,
      });
      
      // Get the base URL for the reset link - prioritize custom domain
      const baseUrl = process.env.APP_URL 
        || (process.env.REPLIT_DEPLOYMENT_URL ? `https://${process.env.REPLIT_DEPLOYMENT_URL}` : null)
        || (process.env.REPL_SLUG ? `https://${process.env.REPL_SLUG}.replit.app` : null)
        || 'http://localhost:5000';
      
      const resetLink = `${baseUrl}/reset-password?token=${resetToken}&email=${encodeURIComponent(email)}`;
      
      // Send email via SendGrid (Replit connector)
      try {
        const { sendPasswordResetEmail } = await import('./sendgrid');
        const userName = user.name || user.companyName || 'there';
        
        const result = await sendPasswordResetEmail(email, resetLink, userName);
        
        if (result.success) {
          console.log(`[Forgot-Password] Reset email sent to: ${email}`);
        } else {
          console.error('[Forgot-Password] Email send error:', result.error);
        }
      } catch (emailError) {
        console.error('[Forgot-Password] Failed to send email:', emailError);
      }
      
      res.json({ message: "If an account exists with that email, you will receive password reset instructions." });
    } catch (error) {
      console.error("[Forgot-Password] Error:", error);
      res.status(500).json({ message: "An error occurred. Please try again." });
    }
  });

  // Reset Password endpoint - verifies token and updates password
  app.post("/api/reset-password", loginRateLimiter, async (req: Request, res: Response) => {
    try {
      const { token, email, newPassword } = req.body;
      
      if (!token || !email || !newPassword) {
        return res.status(400).json({ message: "Token, email, and new password are required" });
      }
      
      // Validate password strength using existing validation function
      const passwordValidation = validatePasswordStrength(newPassword);
      if (!passwordValidation.valid) {
        return res.status(400).json({ message: passwordValidation.message });
      }
      
      // Find user by email
      const user = await storage.getUserByEmail(email);
      
      if (!user) {
        return res.status(400).json({ message: "Invalid or expired reset link" });
      }
      
      // Hash the provided token to compare with stored hash
      const crypto = await import('crypto');
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
      
      // Check if token matches and hasn't expired
      if (user.passwordResetToken !== hashedToken) {
        return res.status(400).json({ message: "Invalid or expired reset link" });
      }
      
      if (!user.passwordResetExpires || new Date(user.passwordResetExpires) < new Date()) {
        return res.status(400).json({ message: "Reset link has expired. Please request a new one." });
      }
      
      // Hash the new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);
      
      // Update user with new password and clear reset token
      await storage.updateUser(user.id, {
        passwordHash: newPasswordHash,
        passwordResetToken: null,
        passwordResetExpires: null,
        isTempPassword: false,
      });
      
      console.log(`[Reset-Password] Password reset successful for: ${email}`);
      
      res.json({ message: "Your password has been reset successfully. You can now sign in with your new password." });
    } catch (error) {
      console.error("[Reset-Password] Error:", error);
      res.status(500).json({ message: "An error occurred. Please try again." });
    }
  });

  // IRATA License Verification endpoint (public - for technician registration)
  // SECURITY: Rate limited due to resource-intensive Playwright browser automation
  app.post("/api/verify-irata", irataVerificationRateLimiter, async (req: Request, res: Response) => {
    try {
      const { lastName, irataNumber } = req.body;
      
      if (!lastName || !irataNumber) {
        return res.status(400).json({ 
          success: false,
          message: "Last name and IRATA number are required" 
        });
      }
      
      // Validate IRATA number format (typically numeric)
      const cleanedNumber = irataNumber.toString().trim();
      if (!/^\d+$/.test(cleanedNumber)) {
        return res.status(400).json({ 
          success: false,
          message: "IRATA number should contain only digits" 
        });
      }
      
      // Import and call the verification service
      const { verifyIrataLicense } = await import('./services/irataVerification');
      const result = await verifyIrataLicense(lastName.trim(), cleanedNumber);
      
      res.json(result);
    } catch (error) {
      console.error("IRATA verification error:", error);
      res.status(500).json({ 
        success: false,
        verified: false,
        error: "Verification service temporarily unavailable" 
      });
    }
  });
  
  // Link resident account to company using resident code
  app.post("/api/link-resident-code", requireAuth, async (req: Request, res: Response) => {
    try {
      const { residentCode } = req.body;
      
      if (!residentCode || typeof residentCode !== 'string') {
        return res.status(400).json({ message: "Resident code is required" });
      }
      
      const normalizedCode = residentCode.trim().toUpperCase();
      
      if (normalizedCode.length !== 10) {
        return res.status(400).json({ message: "Invalid code format" });
      }
      
      // Find company with this resident code
      const company = await storage.getUserByResidentCode(normalizedCode);
      
      if (!company) {
        return res.status(404).json({ message: "Invalid code - no company found with this code" });
      }
      
      // Update resident's companyId
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (currentUser.role !== 'resident') {
        return res.status(403).json({ message: "Only residents can link using a company code" });
      }
      
      console.log(`[link-resident-code] Resident ${currentUser.email} linking to company ${company.companyName} (${company.id})`);
      console.log(`[link-resident-code] Previous companyId: ${currentUser.companyId}`);
      
      // Save BOTH the companyId AND the code they used to link
      await storage.updateUser(currentUser.id, { 
        companyId: company.id,
        linkedResidentCode: normalizedCode // Store the code for future validation
      });
      
      // Verify the update
      const updatedUser = await storage.getUserById(currentUser.id);
      console.log(`[link-resident-code] New companyId: ${updatedUser?.companyId}, linkedCode: ${updatedUser?.linkedResidentCode}`);
      
      res.json({ 
        message: "Account linked successfully", 
        companyName: company.companyName 
      });
    } catch (error) {
      console.error("Link resident code error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Unlink resident from company
  app.post("/api/unlink-resident", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (currentUser.role !== 'resident') {
        return res.status(403).json({ message: "Only residents can unlink their account" });
      }
      
      console.log(`[unlink-resident] Resident ${currentUser.email} unlinking from company ${currentUser.companyId}`);
      
      await storage.updateUser(currentUser.id, { 
        companyId: null,
        linkedResidentCode: null
      });
      
      res.json({ message: "Account unlinked successfully" });
    } catch (error) {
      console.error("Unlink resident error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update resident profile (strata/HOA/LMS number, unit number, phone)
  app.patch("/api/resident/profile", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (currentUser.role !== 'resident') {
        return res.status(403).json({ message: "Only residents can update their profile" });
      }
      
      const { strataPlanNumber, unitNumber, phoneNumber, name } = req.body;
      
      // Validate that at least one field is provided
      if (!strataPlanNumber && !unitNumber && !phoneNumber && !name) {
        return res.status(400).json({ message: "At least one field to update is required" });
      }
      
      // If changing strata+unit, check for duplicates (excludes current user)
      if (strataPlanNumber && unitNumber) {
        // Check if another resident already claims this strata+unit (with normalization)
        const existingResident = await storage.getResidentByStrataAndUnit(
          strataPlanNumber, 
          unitNumber,
          currentUser.id  // Exclude current user from duplicate check
        );
        
        if (existingResident) {
          return res.status(409).json({ 
            message: "This unit is already registered to another resident account",
            conflict: true
          });
        }
      }
      
      const updates: Partial<typeof currentUser> = {};
      if (strataPlanNumber !== undefined) updates.strataPlanNumber = strataPlanNumber;
      if (unitNumber !== undefined) updates.unitNumber = unitNumber;
      if (phoneNumber !== undefined) updates.phoneNumber = phoneNumber;
      if (name !== undefined) updates.name = name;
      
      console.log(`[resident-profile] Updating profile for ${currentUser.email}:`, updates);
      
      await storage.updateUser(currentUser.id, updates);
      
      const updatedUser = await storage.getUserById(currentUser.id);
      
      res.json({ 
        message: "Profile updated successfully",
        user: {
          strataPlanNumber: updatedUser?.strataPlanNumber,
          unitNumber: updatedUser?.unitNumber,
          phoneNumber: updatedUser?.phoneNumber,
          name: updatedUser?.name
        }
      });
    } catch (error) {
      console.error("Update resident profile error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // OLD LICENSE VERIFICATION ENDPOINT REMOVED - Now using Stripe subscriptions
  // See /api/stripe/* endpoints for subscription management
  
  // =====================================================================
  // STRIPE SUBSCRIPTION MANAGEMENT ENDPOINTS
  // Following "It Just Works" principle - zero-failure tolerance
  // =====================================================================
  
  /**
   * SUPERUSER ONLY: Create new Stripe prices at $99/month
   * This endpoint creates new prices in Stripe and returns the price IDs
   * POST /api/stripe/create-new-prices
   */
  app.post("/api/stripe/create-new-prices", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user || user.role !== 'superuser') {
        return res.status(403).json({ message: "SuperUser access required" });
      }

      console.log('[Stripe] Creating new $99/month prices for OnRopePro plan...');

      // First, find or create the product
      let product: any;
      const existingProducts = await stripe.products.list({ limit: 100 });
      product = existingProducts.data.find(p => p.name === 'OnRopePro');
      
      if (!product) {
        product = await stripe.products.create({
          name: 'OnRopePro',
          description: 'OnRopePro - Building Maintenance Management Platform. Unlimited projects included.',
        });
        console.log('[Stripe] Created new product:', product.id);
      } else {
        console.log('[Stripe] Using existing product:', product.id);
      }

      // Create USD price at $99/month
      const usdPrice = await stripe.prices.create({
        product: product.id,
        unit_amount: 9900, // $99.00 in cents
        currency: 'usd',
        recurring: { interval: 'month' },
        nickname: 'OnRopePro Monthly - USD',
      });
      console.log('[Stripe] Created USD price:', usdPrice.id);

      // Create CAD price at $99/month
      const cadPrice = await stripe.prices.create({
        product: product.id,
        unit_amount: 9900, // $99.00 in cents
        currency: 'cad',
        recurring: { interval: 'month' },
        nickname: 'OnRopePro Monthly - CAD',
      });
      console.log('[Stripe] Created CAD price:', cadPrice.id);

      // Return the new price IDs
      res.json({
        success: true,
        message: 'New prices created successfully at $99/month',
        productId: product.id,
        prices: {
          usd: usdPrice.id,
          cad: cadPrice.id,
        },
        instructions: 'Update STRIPE_PRICE_IDS in shared/stripe-config.ts with these new price IDs'
      });
    } catch (error: any) {
      console.error('[Stripe] Failed to create new prices:', error);
      res.status(500).json({ message: error.message || 'Failed to create new prices' });
    }
  });

  /**
   * Upgrade/downgrade existing subscription with proration
   * POST /api/stripe/upgrade-subscription
   */
  app.post("/api/stripe/upgrade-subscription", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can upgrade subscriptions" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      const { tier } = req.body;

      if (!tier || !['basic', 'starter', 'premium', 'enterprise'].includes(tier)) {
        return res.status(400).json({ message: "Invalid subscription tier" });
      }

      // Check if user is already on this tier
      if (user.subscriptionTier === tier) {
        return res.status(400).json({ message: "You are already on this tier" });
      }

      // Get current subscription to determine currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      
      // Use Stripe's subscription currency (authoritative source)
      const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';
      
      // Validate currency is supported
      if (currency !== 'usd' && currency !== 'cad') {
        return res.status(400).json({ 
          message: `Unsupported currency: ${currency}. Only USD and CAD are supported.` 
        });
      }

      // Get new price ID
      const tierConfig = TIER_CONFIG[tier as TierName];
      const newPriceId = currency === 'usd' ? tierConfig.priceIdUSD : tierConfig.priceIdCAD;

      console.log(`[Stripe] Upgrading subscription ${user.stripeSubscriptionId} from ${user.subscriptionTier} to ${tier}`);

      // Update subscription with proration
      const updatedSubscription = await stripe.subscriptions.update(user.stripeSubscriptionId, {
        items: [
          {
            id: subscription.items.data[0].id,
            price: newPriceId,
          },
        ],
        proration_behavior: 'create_prorations', // Automatically calculate and charge/credit difference
      });

      // Generate new license key with correct tier suffix
      const oldLicenseKey = user.licenseKey!;
      const tierSuffix: Record<string, string> = { basic: '1', starter: '2', premium: '3', enterprise: '4' };
      const newLicenseKey = oldLicenseKey.substring(0, oldLicenseKey.lastIndexOf('-') + 1) + tierSuffix[tier];

      console.log(`[License] Replacing license key: ${oldLicenseKey} â†’ ${newLicenseKey}`);

      // Update license key in database (create new entry)
      await db.insert(licenseKeys).values({
        licenseKey: newLicenseKey,
        stripeSessionId: `upgrade-${Date.now()}`, // Unique identifier for upgrade
        stripeCustomerId: user.stripeCustomerId!,
        stripeSubscriptionId: user.stripeSubscriptionId,
        tier: tier,
        currency: currency,
        used: true,
        usedByUserId: user.id,
        usedAt: new Date(),
      });

      // Update user with new tier and license key
      await storage.updateUser(user.id, {
        tier: tier as any,
        licenseKey: newLicenseKey,
      });

      console.log(`[Stripe] Subscription upgraded successfully. New tier: ${tier}`);
      res.json({
        success: true,
        message: "Subscription upgraded successfully",
        newTier: tier,
        newLicenseKey: newLicenseKey,
        proratedAmount: updatedSubscription.latest_invoice,
      });
    } catch (error: any) {
      console.error('[Stripe] Upgrade subscription error:', error);
      res.status(500).json({ message: error.message || "Failed to upgrade subscription" });
    }
  });

  /**
   * Add extra seats to subscription
   * POST /api/stripe/add-seats
   */
  app.post("/api/stripe/add-seats", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can purchase add-ons" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      // Get quantity from request body (default to 1 for backwards compatibility)
      const seatsToAdd = Math.max(1, Math.min(100, parseInt(req.body.quantity) || 1));

      // Get current subscription to determine currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      
      // Use Stripe's subscription currency (authoritative source)
      const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';
      
      // Validate currency is supported
      if (currency !== 'usd' && currency !== 'cad') {
        return res.status(400).json({ 
          message: `Unsupported currency: ${currency}. Only USD and CAD are supported.` 
        });
      }

      // Get extra seats price ID (current price)
      const addonConfig = ADDON_CONFIG.extra_seats;
      const addonPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;
      
      // Legacy price IDs (for counting existing seats from old pricing)
      const legacySeatPriceIds = [
        'price_1SWDH4BzDsOltscrMxt5u3ij',  // Old USD seat price
        'price_1SZG7KBzDsOltscrAcGW9Vuw',  // Old CAD seat price
      ];

      console.log(`[Stripe] Adding ${seatsToAdd} extra seat(s) to subscription ${user.stripeSubscriptionId}`);

      // Count ALL existing seats across current and legacy prices
      let totalExistingSeats = 0;
      for (const item of subscription.items.data) {
        if (item.price.id === addonPriceId || legacySeatPriceIds.includes(item.price.id)) {
          totalExistingSeats += item.quantity || 0;
        }
      }

      // Check if current price already exists on subscription
      const existingItem = subscription.items.data.find(item => item.price.id === addonPriceId);

      if (existingItem) {
        // Update quantity of existing subscription item
        const currentQuantity = existingItem.quantity || 0;
        const targetQuantity = currentQuantity + seatsToAdd;
        console.log(`[Stripe] Extra seats already on subscription. Updating quantity from ${currentQuantity} to ${targetQuantity}`);
        await stripe.subscriptionItems.update(existingItem.id, {
          quantity: targetQuantity,
          proration_behavior: 'create_prorations',
        });
      } else {
        // Create new subscription item with requested quantity
        console.log(`[Stripe] Adding ${seatsToAdd} extra seat(s) as new subscription item`);
        await stripe.subscriptionItems.create({
          subscription: user.stripeSubscriptionId,
          price: addonPriceId,
          quantity: seatsToAdd,
          proration_behavior: 'create_prorations',
        });
      }

      // CRITICAL: Re-fetch subscription to count ALL seats across ALL price tiers (Stripe is source of truth)
      const verifySubscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      let totalSeats = 0;
      for (const item of verifySubscription.items.data) {
        if (item.price.id === addonPriceId || legacySeatPriceIds.includes(item.price.id)) {
          totalSeats += item.quantity || 0;
        }
      }

      // Update user's additional seats count in database to match Stripe's verified total
      await storage.updateUser(user.id, {
        additionalSeatsCount: totalSeats,
      });

      console.log(`[Stripe] ${seatsToAdd} extra seat(s) added successfully. Total seats across all tiers: ${totalSeats}`);
      res.json({
        success: true,
        message: `${seatsToAdd} seat(s) added successfully`,
        seatsAdded: seatsToAdd,
        additionalSeats: totalSeats,
        totalExtraSeats: totalSeats,
      });
    } catch (error: any) {
      console.error('[Stripe] Add seats error:', error);
      res.status(500).json({ message: error.message || "Failed to add extra seats" });
    }
  });

  /**
   * Add extra project to subscription
   * POST /api/stripe/add-project
   * DEPRECATED: New pricing model includes unlimited projects
   */
  app.post("/api/stripe/add-project", requireAuth, async (req: Request, res: Response) => {
    // DEPRECATED: This endpoint is no longer needed as the new pricing model includes unlimited projects
    return res.status(400).json({ 
      message: "Project add-ons are no longer available. Your subscription includes unlimited projects." 
    });
  });

  /**
   * Add white label branding to subscription
   * POST /api/stripe/add-branding
   * 
   * During trial period: Enables white label for free, marks as pending billing
   * After trial: Adds white label to Stripe subscription with proration
   */
  app.post("/api/stripe/add-branding", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can purchase add-ons" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      // Get current subscription to determine status and currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      
      // Check if user is in trial period
      const isTrialing = subscription.status === 'trialing';
      
      // Use Stripe's subscription currency (authoritative source)
      const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';
      
      // Validate currency is supported
      if (currency !== 'usd' && currency !== 'cad') {
        return res.status(400).json({ 
          message: `Unsupported currency: ${currency}. Only USD and CAD are supported.` 
        });
      }

      // Get white label price ID
      const addonConfig = ADDON_CONFIG.white_label;
      const addonPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;

      console.log(`[Stripe] Adding white label branding to subscription ${user.stripeSubscriptionId} (trialing: ${isTrialing})`);

      if (isTrialing) {
        // During trial: Enable white label for FREE, mark as pending billing
        // When trial ends, the webhook will add it to the subscription
        await storage.updateUser(user.id, {
          whitelabelBrandingActive: true,
          whitelabelPendingBilling: true, // Will be billed when trial ends
        });

        console.log(`[Stripe] White label branding enabled for free during trial, pending billing after trial ends`);
        res.json({
          success: true,
          message: "White label branding unlocked! Free during your trial period, will be added to your subscription when billing starts.",
          whiteLabelEnabled: true,
          freeTrialBenefit: true,
        });
      } else {
        // After trial: Add to Stripe subscription with proration

        // Check if white label branding is already on the subscription
        let hasWhiteLabel = false;
        let startingAfter: string | undefined = undefined;
        
        do {
          const itemsPage = await stripe.subscriptionItems.list({
            subscription: user.stripeSubscriptionId,
            limit: 100,
            ...(startingAfter && { starting_after: startingAfter }),
          });
          
          hasWhiteLabel = itemsPage.data.some(item => item.price.id === addonPriceId);
          
          if (hasWhiteLabel || !itemsPage.has_more) break;
          
          startingAfter = itemsPage.data[itemsPage.data.length - 1]?.id;
        } while (true);

        if (!hasWhiteLabel) {
          // Add white label branding to subscription
          await stripe.subscriptionItems.create({
            subscription: user.stripeSubscriptionId,
            price: addonPriceId,
            proration_behavior: 'create_prorations',
          });
        }

        // Update user to enable white label in database
        await storage.updateUser(user.id, {
          whitelabelBrandingActive: true,
          whitelabelPendingBilling: false, // Already billed
        });

        console.log(`[Stripe] White label branding ${hasWhiteLabel ? 'already active' : 'added successfully'}`);
        res.json({
          success: true,
          message: "White label branding unlocked successfully",
          whiteLabelEnabled: true,
        });
      }
    } catch (error: any) {
      console.error('[Stripe] Add branding error:', error);
      res.status(500).json({ message: error.message || "Failed to add white label branding" });
    }
  });

  /**
   * Get subscription details including add-ons
   * GET /api/subscription/details
   */
  app.get("/api/subscription/details", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(404).json({ message: "No active subscription found" });
      }

      // Get subscription from Stripe
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      const currentPriceId = subscription.items.data[0]?.price.id;
      
      // Determine currency
      let currency: 'usd' | 'cad' = 'usd';
      for (const [, config] of Object.entries(TIER_CONFIG)) {
        if (config.priceIdUSD === currentPriceId) {
          currency = 'usd';
          break;
        } else if (config.priceIdCAD === currentPriceId) {
          currency = 'cad';
          break;
        }
      }

      res.json({
        tier: user.subscriptionTier,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        whitelabelBrandingActive: user.whitelabelBrandingActive || false,
        additionalSeatsCount: user.additionalSeatsCount || 0,
        giftedSeatsCount: user.giftedSeatsCount || 0,
        additionalProjectsCount: user.additionalProjectsCount || 0,
        currency,
        trialEnd: subscription.trial_end,
      });
    } catch (error: any) {
      console.error('[Stripe] Get subscription details error:', error);
      res.status(500).json({ message: error.message || "Failed to fetch subscription details" });
    }
  });

  /**
   * Cancel white label branding add-on
   * POST /api/stripe/cancel-whitelabel
   */
  app.post("/api/stripe/cancel-whitelabel", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      if (!user.whitelabelBrandingActive) {
        return res.status(400).json({ message: "White label branding is not active" });
      }

      // Get current subscription to determine currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      const currentPriceId = subscription.items.data[0]?.price.id;
      
      // Determine currency
      let currency: 'usd' | 'cad' = 'usd';
      for (const [, config] of Object.entries(TIER_CONFIG)) {
        if (config.priceIdUSD === currentPriceId) {
          currency = 'usd';
          break;
        } else if (config.priceIdCAD === currentPriceId) {
          currency = 'cad';
          break;
        }
      }

      // Get white label price ID
      const addonConfig = ADDON_CONFIG.white_label;
      const addonPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;

      console.log(`[Stripe] Cancelling white label branding from subscription ${user.stripeSubscriptionId}`);

      // Find and remove the white label subscription item
      let itemToRemove: string | null = null;
      let startingAfter: string | undefined = undefined;
      
      do {
        const itemsPage = await stripe.subscriptionItems.list({
          subscription: user.stripeSubscriptionId,
          limit: 100,
          ...(startingAfter && { starting_after: startingAfter }),
        });
        
        const whitelabelItem = itemsPage.data.find(item => item.price.id === addonPriceId);
        if (whitelabelItem) {
          itemToRemove = whitelabelItem.id;
          break;
        }
        
        if (!itemsPage.has_more) break;
        
        startingAfter = itemsPage.data[itemsPage.data.length - 1]?.id;
      } while (true);

      if (itemToRemove) {
        // Remove the subscription item (will take effect at period end)
        await stripe.subscriptionItems.del(itemToRemove, {
          proration_behavior: 'none', // No proration on cancellation
        });
      }

      // Update user to disable white label in database
      await storage.updateUser(user.id, {
        whitelabelBrandingActive: false,
      });

      console.log(`[Stripe] White label branding cancelled successfully`);
      res.json({
        success: true,
        message: "White label branding will be cancelled at the end of your billing period",
      });
    } catch (error: any) {
      console.error('[Stripe] Cancel white label error:', error);
      res.status(500).json({ message: error.message || "Failed to cancel white label branding" });
    }
  });

  /**
   * Remove one extra seat from subscription
   * POST /api/stripe/remove-addon-seats
   * 
   * IMPORTANT: Supports both current and legacy seat price IDs
   * After update, re-fetches Stripe to count ALL seats (source of truth)
   */
  app.post("/api/stripe/remove-addon-seats", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      if ((user.additionalSeatsCount || 0) === 0) {
        return res.status(400).json({ message: "No extra seats to remove" });
      }

      // Get current subscription to determine currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';

      // Get current extra seats price ID
      const addonConfig = ADDON_CONFIG.extra_seats;
      const currentPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;
      
      // Legacy seat price IDs (must support for existing customers)
      const legacyPriceId = currency === 'usd' 
        ? 'price_1SWDH4BzDsOltscrMxt5u3ij'  // Old USD seat price ($19/month)
        : 'price_1SZG7KBzDsOltscrAcGW9Vuw'; // Old CAD seat price ($19/month)
      
      // All seat price IDs to check
      const allSeatPriceIds = [currentPriceId, legacyPriceId];

      console.log(`[Stripe] Removing one extra seat from subscription ${user.stripeSubscriptionId}`);

      // Find ANY seat subscription item (current or legacy)
      let existingItem = subscription.items.data.find(item => item.price.id === currentPriceId);
      let isLegacy = false;
      
      if (!existingItem) {
        existingItem = subscription.items.data.find(item => item.price.id === legacyPriceId);
        isLegacy = true;
      }

      if (!existingItem) {
        console.error('[Stripe] No seat item found. Available items:', 
          subscription.items.data.map(item => ({ id: item.id, priceId: item.price.id, quantity: item.quantity }))
        );
        return res.status(404).json({ message: "Extra seats subscription item not found" });
      }

      const currentQuantity = existingItem.quantity || 1;
      console.log(`[Stripe] Found seat item on ${isLegacy ? 'legacy' : 'current'} price. Quantity: ${currentQuantity}`);

      if (currentQuantity > 1) {
        // Decrement quantity by 1
        console.log(`[Stripe] Reducing seats from ${currentQuantity} to ${currentQuantity - 1}`);
        await stripe.subscriptionItems.update(existingItem.id, {
          quantity: currentQuantity - 1,
          proration_behavior: 'create_prorations',
        });
      } else {
        // Remove the subscription item entirely
        console.log(`[Stripe] Removing last seat from this price tier`);
        await stripe.subscriptionItems.del(existingItem.id, {
          proration_behavior: 'create_prorations',
        });
      }

      // CRITICAL: Re-fetch subscription to count ALL seats across ALL price tiers (Stripe is source of truth)
      const verifySubscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      let totalSeatsInStripe = 0;
      for (const item of verifySubscription.items.data) {
        if (allSeatPriceIds.includes(item.price.id)) {
          totalSeatsInStripe += item.quantity || 0;
        }
      }

      // Update database to match Stripe's verified total
      await storage.updateUser(user.id, {
        additionalSeatsCount: totalSeatsInStripe,
      });

      console.log(`[Stripe] Extra seat removed successfully. Total remaining seats across all tiers: ${totalSeatsInStripe}`);
      res.json({
        success: true,
        message: "Extra seat removed successfully",
        remainingSeats: totalSeatsInStripe,
        totalExtraSeats: totalSeatsInStripe,
      });
    } catch (error: any) {
      console.error('[Stripe] Remove seat error:', error);
      res.status(500).json({ message: error.message || "Failed to remove extra seat" });
    }
  });

  /**
   * Remove one extra project from subscription
   * POST /api/stripe/remove-addon-projects
   * DEPRECATED: New pricing model includes unlimited projects
   */
  app.post("/api/stripe/remove-addon-projects", requireAuth, async (req: Request, res: Response) => {
    // DEPRECATED: This endpoint is no longer needed as the new pricing model includes unlimited projects
    return res.status(400).json({ 
      message: "Project add-ons are no longer available. Your subscription includes unlimited projects." 
    });
  });

  /**
   * Remove multiple seats with employee suspension
   * POST /api/stripe/remove-seats
   * 
   * TRANSACTION SAFETY: Operations are ordered to ensure consistency:
   * 1. Validate all inputs
   * 2. Suspend employees in DB (reversible)
   * 3. Update seat count in DB (reversible)
   * 4. Update Stripe subscription (if this fails, rollback DB changes)
   */
  app.post("/api/stripe/remove-seats", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can remove seats" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription found" });
      }

      const { quantity, employeeIds } = req.body;
      
      if (!quantity || quantity < 1) {
        return res.status(400).json({ message: "Invalid quantity" });
      }

      if (!employeeIds || !Array.isArray(employeeIds)) {
        return res.status(400).json({ message: "Employee IDs must be provided as an array" });
      }

      // CRITICAL FIX: Deduplicate employee IDs to prevent seat count mismatch
      const uniqueEmployeeIds = [...new Set(employeeIds as string[])];
      if (uniqueEmployeeIds.length !== quantity) {
        return res.status(400).json({ 
          message: `Must select ${quantity} unique employees to remove ${quantity} seat(s). You selected ${uniqueEmployeeIds.length} unique employee(s).` 
        });
      }

      const paidSeats = user.additionalSeatsCount || 0;
      if (quantity > paidSeats) {
        return res.status(400).json({ message: `Cannot remove more seats than you have paid for (${paidSeats})` });
      }

      // Validate all employees belong to this company and are active (not suspended or terminated)
      // Uses checkEmployeeBelongsToCompany to handle both primary and secondary (PLUS) connections
      const employeesToSuspend: { id: string; name: string }[] = [];
      for (const empId of uniqueEmployeeIds) {
        const emp = await storage.getUserById(empId);
        if (!emp) {
          return res.status(400).json({ message: `Employee ${empId} not found` });
        }
        
        // Check if employee belongs to this company (either primary or secondary connection)
        const membership = await storage.checkEmployeeBelongsToCompany(empId, user.id);
        if (!membership.belongs) {
          return res.status(400).json({ message: "Cannot suspend employees from another company" });
        }
        
        if (emp.suspendedAt) {
          return res.status(400).json({ message: `Employee ${emp.name} is already suspended` });
        }
        if (emp.terminatedDate) {
          return res.status(400).json({ message: `Employee ${emp.name} is terminated and cannot be suspended` });
        }
        employeesToSuspend.push({ id: emp.id, name: emp.name });
      }

      // Get current subscription to determine currency
      const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
      const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';

      // CRITICAL FIX: Support both current AND legacy seat price IDs
      // Current prices: $34.95/seat (new pricing model)
      // Legacy prices: $19/seat (old pricing model - some customers may still have these)
      const addonConfig = ADDON_CONFIG.extra_seats;
      const currentPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;
      
      // Legacy seat price IDs from scratchpad
      const legacyPriceIds = {
        usd: 'price_1SWDH4BzDsOltscrMxt5u3ij', // $19/month legacy USD
        cad: 'price_1SZG7KBzDsOltscrAcGW9Vuw', // $19/month legacy CAD
      };
      const legacyPriceId = currency === 'usd' ? legacyPriceIds.usd : legacyPriceIds.cad;

      console.log(`[Stripe] Removing ${quantity} extra seats from subscription ${user.stripeSubscriptionId}`);

      // Find the subscription item for extra seats (check both current and legacy price IDs)
      let existingItem = subscription.items.data.find(item => item.price.id === currentPriceId);
      let isLegacyPrice = false;
      let actualPricePerSeat = 34.95;
      
      if (!existingItem) {
        // Try legacy price ID
        existingItem = subscription.items.data.find(item => item.price.id === legacyPriceId);
        if (existingItem) {
          isLegacyPrice = true;
          actualPricePerSeat = 19.00; // Legacy price
          console.log(`[Stripe] Found legacy seat price ID: ${legacyPriceId}`);
        }
      }

      if (!existingItem) {
        // Log all subscription items for debugging
        console.error('[Stripe] Could not find seat subscription item. Available items:', 
          subscription.items.data.map(item => ({ id: item.id, priceId: item.price.id, quantity: item.quantity }))
        );
        return res.status(404).json({ 
          message: "Extra seats subscription item not found. Please contact support if you believe this is an error." 
        });
      }

      const currentQuantity = existingItem.quantity || 0;
      const newQuantity = Math.max(0, currentQuantity - quantity);

      // Calculate estimated credit (prorated) using actual price
      const now = new Date();
      const periodEnd = new Date(subscription.current_period_end * 1000);
      const daysRemaining = Math.max(0, Math.ceil((periodEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      const dailyRate = actualPricePerSeat / 30;
      const creditAmount = Math.round(quantity * dailyRate * daysRemaining * 100) / 100;

      // TRANSACTION SAFETY: 
      // 1. Suspend employees in DB first (reversible)
      // 2. Update Stripe (with fresh data check)
      // 3. Update DB seat count to match Stripe (source of truth)
      // 4. Rollback employees if Stripe fails
      const suspendedAt = new Date();
      const previousSeatCount = user.additionalSeatsCount || 0;
      let finalSeatCount = previousSeatCount; // Will be updated after Stripe succeeds

      // Step 1: Suspend all employees in DB (do this first, it's reversible)
      // Uses suspendEmployeeConnection to handle both primary and secondary (PLUS) connections
      console.log(`[Stripe] Step 1: Suspending ${employeesToSuspend.length} employees in DB`);
      for (const emp of employeesToSuspend) {
        await storage.suspendEmployeeConnection(emp.id, user.id);
        // Also set suspendedBy for audit trail on primary connections
        const membership = await storage.checkEmployeeBelongsToCompany(emp.id, user.id);
        if (membership.connectionType === 'primary') {
          await db.update(users)
            .set({ suspendedBy: user.id })
            .where(eq(users.id, emp.id));
        }
        console.log(`[Stripe] Suspended employee ${emp.id} (${emp.name}) - ${membership.connectionType} connection`);
      }

      // Step 2: Update Stripe subscription
      // CRITICAL: Re-fetch subscription to get LATEST quantity to prevent race conditions
      try {
        const freshSubscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
        
        // Find the seat item again in the fresh subscription
        let freshSeatItem = freshSubscription.items.data.find(item => item.price.id === currentPriceId);
        if (!freshSeatItem) {
          freshSeatItem = freshSubscription.items.data.find(item => item.price.id === legacyPriceId);
        }
        
        if (!freshSeatItem) {
          throw new Error("Seat subscription item no longer exists. Subscription may have been modified.");
        }
        
        // Calculate the new quantity based on FRESH data
        const freshCurrentQuantity = freshSeatItem.quantity || 0;
        const freshNewQuantity = Math.max(0, freshCurrentQuantity - quantity);
        
        console.log(`[Stripe] Step 2: Fresh check - Current Stripe quantity: ${freshCurrentQuantity}, removing: ${quantity}, new: ${freshNewQuantity}`);
        
        // Verify we're not trying to remove more seats than available
        if (freshCurrentQuantity < quantity) {
          throw new Error(`Race condition detected: Only ${freshCurrentQuantity} seats available in Stripe, but trying to remove ${quantity}. Please try again.`);
        }
        
        if (freshNewQuantity > 0) {
          console.log(`[Stripe] Reducing Stripe seats from ${freshCurrentQuantity} to ${freshNewQuantity}`);
          await stripe.subscriptionItems.update(freshSeatItem.id, {
            quantity: freshNewQuantity,
            proration_behavior: 'create_prorations',
          });
        } else {
          console.log(`[Stripe] Removing all seats from Stripe subscription`);
          await stripe.subscriptionItems.del(freshSeatItem.id, {
            proration_behavior: 'create_prorations',
          });
        }
        
        // Step 3: Post-update verification - get ACTUAL Stripe state as source of truth
        const verifySubscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
        let verifySeatItem = verifySubscription.items.data.find(item => item.price.id === currentPriceId);
        if (!verifySeatItem) {
          verifySeatItem = verifySubscription.items.data.find(item => item.price.id === legacyPriceId);
        }
        const verifyQuantity = verifySeatItem?.quantity || 0;
        
        // Log if there's any unexpected variance (concurrent updates)
        if (verifyQuantity !== freshNewQuantity) {
          console.warn(`[Stripe] NOTE: Expected ${freshNewQuantity} seats, Stripe shows ${verifyQuantity} (likely concurrent update)`);
        }
        
        // Step 4: Update DB to match Stripe (Stripe is always source of truth)
        finalSeatCount = verifyQuantity;
        console.log(`[Stripe] Step 4: Updating DB seat count to match Stripe: ${finalSeatCount}`);
        await storage.updateUser(user.id, {
          additionalSeatsCount: finalSeatCount,
        });
        
        console.log(`[Stripe] Verification complete. DB synced to Stripe quantity: ${verifyQuantity}`);
        
      } catch (stripeError: any) {
        // ROLLBACK: Stripe failed or race condition detected, revert employee suspensions
        console.error('[Stripe] Stripe update failed, rolling back employee suspensions:', stripeError.message);
        
        // Rollback employee suspensions only (we haven't updated DB seat count yet)
        for (const emp of employeesToSuspend) {
          await db.update(users)
            .set({
              suspendedAt: null,
              suspendedBy: null,
            })
            .where(eq(users.id, emp.id));
          console.log(`[Stripe] Rollback: Unsuspended employee ${emp.id}`);
        }
        
        throw new Error(`Stripe update failed: ${stripeError.message}. All changes have been rolled back.`);
      }

      console.log(`[Stripe] ${quantity} seats removed successfully. Remaining paid seats: ${finalSeatCount}. Credit: $${creditAmount}. Legacy price: ${isLegacyPrice}`);
      
      // Send real-time notifications to suspended employees
      // Technicians get a suspension notification (can still access portal)
      // Non-technicians get terminated (no portal access)
      for (const emp of employeesToSuspend) {
        const empData = await storage.getUserById(emp.id);
        const empIsTechnician = !!(empData?.ropeAccessLicenseNumber || empData?.irataCertNumber || empData?.spratCertNumber);
        
        if (empIsTechnician) {
          // Technician: notify of suspension but don't logout (they can still access their portal)
          wsHub.notifyEmployerSuspension(emp.id, user.id, user.companyName || 'Unknown Company');
          console.log(`[WebSocket] Sent employer suspension notification to technician ${emp.id}`);
        } else {
          // Non-technician: terminate session completely
          await wsHub.terminateUser(emp.id);
          console.log(`[WebSocket] Sent termination signal to non-technician employee ${emp.id}`);
        }
      }
      
      res.json({
        success: true,
        message: `${quantity} seat(s) removed successfully`,
        seatsRemoved: quantity,
        remainingPaidSeats: finalSeatCount,
        suspendedEmployees: employeesToSuspend.length,
        creditAmount: creditAmount.toFixed(2),
        isLegacyPrice,
      });
    } catch (error: any) {
      console.error('[Stripe] Remove seats error:', error);
      res.status(500).json({ message: error.message || "Failed to remove seats" });
    }
  });

  /**
   * Reactivate a suspended employee (requires available seat)
   * POST /api/employees/:id/reactivate-suspended
   */
  app.post("/api/employees/:id/reactivate-suspended", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can reactivate employees" });
      }

      const { id } = req.params;
      const employee = await storage.getUserById(id);

      if (!employee) {
        return res.status(404).json({ message: "Employee not found" });
      }

      // Check if employee belongs to this company (primary or secondary)
      // includeSuspended=true to find suspended connections for reactivation
      const membership = await storage.checkEmployeeBelongsToCompany(id, user.id, true);
      if (!membership.belongs) {
        return res.status(403).json({ message: "Cannot reactivate employees from another company" });
      }

      // Validate that the employee is actually suspended
      if (membership.connectionType === 'primary') {
        if (!employee.suspendedAt) {
          return res.status(400).json({ message: "Employee is not suspended" });
        }
      } else if (membership.connectionType === 'secondary' && membership.connectionId) {
        // For secondary connections, check the connection status
        const connection = await db.select().from(technicianEmployerConnections)
          .where(eq(technicianEmployerConnections.id, membership.connectionId)).limit(1);
        if (!connection.length || connection[0].status !== 'suspended') {
          return res.status(400).json({ message: "Employee connection is not suspended" });
        }
      }

      // Check if there's an available seat OR if we need to add one via Stripe
      const employees = await storage.getAllEmployees(user.id);
      const activeCount = employees.filter((e: any) => !e.terminatedDate && !e.suspendedAt).length;
      const paidSeats = user.additionalSeatsCount || 0;
      const giftedSeats = user.giftedSeatsCount || 0;
      const totalSeats = paidSeats + giftedSeats;

      // Track if we need to add a seat
      let seatWasAdded = false;

      // If no available seats, add one via Stripe
      if (activeCount >= totalSeats) {
        if (!user.stripeSubscriptionId) {
          return res.status(400).json({ 
            message: "No available seats and no active subscription to add seats.",
            activeCount,
            totalSeats 
          });
        }

        // Add a seat via Stripe (with dedicated error handling)
        try {
          console.log(`[Employees] No available seats (${activeCount}/${totalSeats}), adding seat via Stripe`);
          
          const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
          const currency = subscription.currency.toLowerCase() as 'usd' | 'cad';
          
          const addonConfig = ADDON_CONFIG.extra_seats;
          const addonPriceId = currency === 'usd' ? addonConfig.priceIdUSD : addonConfig.priceIdCAD;
          const legacySeatPriceIds = [
            'price_1SWDH4BzDsOltscrMxt5u3ij',
            'price_1SZG7KBzDsOltscrAcGW9Vuw',
          ];

          // Check if there's an existing seat item to update
          let existingItem = subscription.items.data.find(item => item.price.id === addonPriceId);
          if (!existingItem) {
            existingItem = subscription.items.data.find(item => legacySeatPriceIds.includes(item.price.id));
          }

          if (existingItem) {
            // Update existing item
            await stripe.subscriptionItems.update(existingItem.id, {
              quantity: (existingItem.quantity || 0) + 1,
              proration_behavior: 'create_prorations',
            });
          } else {
            // Add new item
            await stripe.subscriptionItems.create({
              subscription: user.stripeSubscriptionId,
              price: addonPriceId,
              quantity: 1,
              proration_behavior: 'create_prorations',
            });
          }

          // Only update local seat count after Stripe succeeds
          await storage.updateUser(user.id, {
            additionalSeatsCount: (user.additionalSeatsCount || 0) + 1,
          });

          seatWasAdded = true;
          console.log(`[Employees] Added 1 seat via Stripe for reactivation`);
        } catch (stripeError: any) {
          console.error('[Employees] Failed to add seat via Stripe:', stripeError);
          return res.status(500).json({ 
            message: `Failed to add seat to subscription: ${stripeError.message || 'Stripe error'}` 
          });
        }
      }

      // Reactivate the employee based on connection type
      if (membership.connectionType === 'secondary' && membership.connectionId) {
        await db.update(technicianEmployerConnections)
          .set({ status: "active" })
          .where(eq(technicianEmployerConnections.id, membership.connectionId));
      } else {
        await db.update(users)
          .set({
            suspendedAt: null,
            suspendedBy: null,
          })
          .where(eq(users.id, id));
      }

      console.log(`[Employees] Reactivated suspended employee ${id}`);
      res.json({
        success: true,
        message: "Employee reactivated successfully",
        employeeId: id,
        seatAdded: seatWasAdded,
      });
    } catch (error: any) {
      console.error('[Employees] Reactivate suspended error:', error);
      res.status(500).json({ message: error.message || "Failed to reactivate employee" });
    }
  });

  /**
   * Create Stripe checkout session for subscription purchase
   * POST /api/stripe/create-checkout-session
   */
  app.post("/api/stripe/create-checkout-session", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can purchase subscriptions" });
      }

      const { tier, currency = 'usd' } = req.body;

      if (!tier || !['basic', 'starter', 'premium', 'enterprise'].includes(tier)) {
        return res.status(400).json({ message: "Invalid subscription tier" });
      }

      if (!['usd', 'cad'].includes(currency)) {
        return res.status(400).json({ message: "Invalid currency. Must be 'usd' or 'cad'" });
      }

      // Get or create Stripe customer
      const customerId = await stripeService.getOrCreateCustomer(user);

      // Update user with customer ID if new
      if (customerId !== user.stripeCustomerId) {
        await storage.updateUser(user.id, { stripeCustomerId: customerId });
      }

      // Get price ID for selected tier and currency
      const tierConfig = TIER_CONFIG[tier as TierName];
      const priceId = currency === 'usd' ? tierConfig.priceIdUSD : tierConfig.priceIdCAD;

      // Construct base URL from request (works in both dev and production)
      const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Create checkout session
      const session = await stripeService.createCheckoutSession({
        customerId,
        priceId,
        mode: 'subscription',
        successUrl: `${baseUrl}/profile?subscription=success`,
        cancelUrl: `${baseUrl}/profile?subscription=canceled`,
        metadata: {
          userId: user.id.toString(),
          tier,
          currency,
        },
      });

      console.log(`[Stripe] Checkout session created for user ${user.id}: ${session.id}`);
      res.json({ url: session.url });
    } catch (error: any) {
      console.error('[Stripe] Create checkout session error:', error);
      res.status(500).json({ message: error.message || "Failed to create checkout session" });
    }
  });

  /**
   * Create Stripe embedded checkout session for in-app payment
   * POST /api/stripe/create-embedded-checkout
   * Returns clientSecret for Stripe EmbeddedCheckout component
   */
  app.post("/api/stripe/create-embedded-checkout", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can purchase subscriptions" });
      }

      const { tier, currency = 'usd' } = req.body;

      if (!tier || !['basic', 'starter', 'premium', 'enterprise'].includes(tier)) {
        return res.status(400).json({ message: "Invalid subscription tier" });
      }

      if (!['usd', 'cad'].includes(currency)) {
        return res.status(400).json({ message: "Invalid currency. Must be 'usd' or 'cad'" });
      }

      // Get or create Stripe customer
      const customerId = await stripeService.getOrCreateCustomer(user);

      // Update user with customer ID if new
      if (customerId !== user.stripeCustomerId) {
        await storage.updateUser(user.id, { stripeCustomerId: customerId });
      }

      // Get price ID for selected tier and currency
      const tierConfig = TIER_CONFIG[tier as TierName];
      const priceId = currency === 'usd' ? tierConfig.priceIdUSD : tierConfig.priceIdCAD;

      // Construct base URL from request
      const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Create embedded checkout session with ui_mode: 'embedded'
      const session = await stripe.checkout.sessions.create({
        customer: customerId,
        mode: 'subscription',
        payment_method_types: ['card'],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        ui_mode: 'embedded',
        return_url: `${baseUrl}/profile?subscription=success&session_id={CHECKOUT_SESSION_ID}`,
        metadata: {
          userId: user.id.toString(),
          tier,
          currency,
        },
        subscription_data: {
          trial_period_days: 30,
          metadata: {
            userId: user.id.toString(),
            tier,
            currency,
          },
        },
        allow_promotion_codes: true,
        billing_address_collection: 'auto',
      });

      console.log(`[Stripe] Embedded checkout session created for user ${user.id}: ${session.id}`);
      res.json({ clientSecret: session.client_secret });
    } catch (error: any) {
      console.error('[Stripe] Create embedded checkout error:', error);
      res.status(500).json({ message: error.message || "Failed to create embedded checkout" });
    }
  });

  /**
   * Create Stripe embedded checkout for NEW customers (no auth required)
   * POST /api/stripe/create-embedded-license-checkout
   */
  app.post("/api/stripe/create-embedded-license-checkout", async (req: Request, res: Response) => {
    try {
      const { tier, currency = 'usd' } = req.body;

      if (!tier || !['basic', 'starter', 'premium', 'enterprise'].includes(tier)) {
        return res.status(400).json({ message: "Invalid subscription tier" });
      }

      if (!['usd', 'cad'].includes(currency)) {
        return res.status(400).json({ message: "Invalid currency. Must be 'usd' or 'cad'" });
      }

      // Get price ID for selected tier and currency
      const tierConfig = TIER_CONFIG[tier as TierName];
      const priceId = currency === 'usd' ? tierConfig.priceIdUSD : tierConfig.priceIdCAD;

      // Construct base URL from request
      const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Create embedded checkout session
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        payment_method_types: ['card'],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        ui_mode: 'embedded',
        return_url: `${baseUrl}/complete-registration?session_id={CHECKOUT_SESSION_ID}`,
        metadata: {
          tier,
          currency,
          newCustomer: 'true',
        },
        subscription_data: {
          trial_period_days: 30,
          metadata: {
            tier,
            currency,
          },
        },
        allow_promotion_codes: true,
        billing_address_collection: 'required',
      });

      console.log(`[Stripe] Embedded license checkout session created: ${session.id}`);
      res.json({ clientSecret: session.client_secret });
    } catch (error: any) {
      console.error('[Stripe] Create embedded license checkout error:', error);
      res.status(500).json({ message: error.message || "Failed to create embedded checkout" });
    }
  });

  /**
   * Create Stripe checkout session for NEW customers (license purchase)
   * POST /api/stripe/create-license-checkout
   * No authentication required - this is for new customers
   */
  app.post("/api/stripe/create-license-checkout", async (req: Request, res: Response) => {
    try {
      const { tier, currency = 'usd' } = req.body;

      if (!tier || !['basic', 'starter', 'premium', 'enterprise'].includes(tier)) {
        return res.status(400).json({ message: "Invalid subscription tier" });
      }

      if (!['usd', 'cad'].includes(currency)) {
        return res.status(400).json({ message: "Invalid currency. Must be 'usd' or 'cad'" });
      }

      // Get price ID for selected tier and currency
      const tierConfig = TIER_CONFIG[tier as TierName];
      const priceId = currency === 'usd' ? tierConfig.priceIdUSD : tierConfig.priceIdCAD;

      // Construct base URL from request (works in both dev and production)
      const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Create checkout session (customer created automatically for subscription mode)
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        payment_method_types: ['card'],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        success_url: `${baseUrl}/complete-registration?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/get-license?canceled=true`,
        metadata: {
          tier,
          currency,
          newCustomer: 'true', // Flag to indicate this is a new customer purchase
        },
        subscription_data: {
          trial_period_days: 30, // 1-month free trial
          metadata: {
            tier,
            currency,
          },
        },
        allow_promotion_codes: true,
        billing_address_collection: 'auto',
      });

      console.log(`[Stripe] License checkout session created: ${session.id}`);
      res.json({ sessionUrl: session.url });
    } catch (error: any) {
      console.error('[Stripe] Create license checkout error:', error);
      res.status(500).json({ message: error.message || "Failed to create checkout session" });
    }
  });

  /**
   * Retrieve checkout session and generate license key
   * GET /api/stripe/checkout-session/:sessionId
   * Used by complete-registration page to get license details
   */
  app.get("/api/stripe/checkout-session/:sessionId", async (req: Request, res: Response) => {
    try {
      const { sessionId } = req.params;
      console.log(`[Stripe] Retrieving checkout session: ${sessionId}`);

      // Check if we already generated a license key for this session
      const existingLicense = await db.query.licenseKeys.findFirst({
        where: eq(licenseKeys.stripeSessionId, sessionId),
      });

      if (existingLicense) {
        console.log(`[Stripe] Found existing license for session ${sessionId}: ${existingLicense.licenseKey}`);
        // Return existing license key
        const tierConfig = TIER_CONFIG[existingLicense.tier as TierName];
        const subscription = await stripe.subscriptions.retrieve(existingLicense.stripeSubscriptionId);
        
        return res.json({
          licenseKey: existingLicense.licenseKey,
          tier: existingLicense.tier,
          tierName: tierConfig.name,
          currency: existingLicense.currency,
          maxProjects: tierConfig.maxProjects,
          maxSeats: tierConfig.maxSeats,
          stripeCustomerId: existingLicense.stripeCustomerId,
          stripeSubscriptionId: existingLicense.stripeSubscriptionId,
          trialEnd: subscription.trial_end,
        });
      }

      console.log(`[Stripe] No existing license found, retrieving session from Stripe...`);

      // Retrieve the session from Stripe
      const session = await stripe.checkout.sessions.retrieve(sessionId, {
        expand: ['subscription', 'customer'],
      });

      console.log(`[Stripe] Session retrieved: status=${session.status}, customer=${session.customer ? 'present' : 'missing'}`);

      if (!session) {
        console.error(`[Stripe] Session ${sessionId} not found in Stripe`);
        return res.status(404).json({ message: "Session not found in Stripe. Please verify you're using the correct Stripe account (test or live mode)." });
      }

      // Verify session is completed
      if (session.status !== 'complete') {
        console.error(`[Stripe] Session ${sessionId} status is ${session.status}, expected 'complete'`);
        return res.status(400).json({ message: `Checkout session not completed. Current status: ${session.status}` });
      }

      // Get tier from metadata
      const tier = session.metadata?.tier;
      const currency = session.metadata?.currency || 'usd';

      if (!tier) {
        console.error(`[Stripe] Session ${sessionId} missing tier metadata`);
        return res.status(400).json({ message: "Missing tier information in session metadata" });
      }

      // Get customer and subscription IDs
      const stripeCustomerId = typeof session.customer === 'string' ? session.customer : session.customer?.id;
      const subscription = session.subscription as Stripe.Subscription;
      const stripeSubscriptionId = typeof subscription === 'string' ? subscription : subscription?.id;

      if (!stripeCustomerId || !stripeSubscriptionId) {
        console.error(`[Stripe] Session ${sessionId} missing customer or subscription data`);
        return res.status(400).json({ message: "Missing customer or subscription data" });
      }

      // Generate license key with tier suffix
      // Format: COMPANY-XXXXX-XXXXX-XXXXX-[TIER]
      // -1 = Basic, -2 = Starter, -3 = Premium, -4 = Enterprise
      const tierSuffix = tier === 'basic' ? '1' : tier === 'starter' ? '2' : tier === 'premium' ? '3' : '4';
      const licenseKey = `COMPANY-${generateRandomSegment()}-${generateRandomSegment()}-${generateRandomSegment()}-${tierSuffix}`;

      // Store license key in database
      await db.insert(licenseKeys).values({
        licenseKey,
        stripeSessionId: sessionId,
        stripeCustomerId,
        stripeSubscriptionId,
        tier,
        currency,
        used: false,
      });

      console.log(`[License] Generated and stored license key: ${licenseKey} for session ${sessionId}`);

      const tierConfig = TIER_CONFIG[tier as TierName];

      res.json({
        licenseKey,
        tier,
        tierName: tierConfig.name,
        currency,
        maxProjects: tierConfig.maxProjects,
        maxSeats: tierConfig.maxSeats,
        stripeCustomerId,
        stripeSubscriptionId,
        trialEnd: subscription && typeof subscription !== 'string' ? subscription.trial_end : null,
      });
    } catch (error: any) {
      console.error('[Stripe] Get checkout session error:', error);
      console.error('[Stripe] Error details:', {
        message: error.message,
        type: error.type,
        code: error.code,
        statusCode: error.statusCode,
      });
      
      // Provide more helpful error messages
      let userMessage = "Failed to retrieve session";
      if (error.type === 'StripeInvalidRequestError') {
        userMessage = "Invalid session ID or session not found in Stripe. Please verify your Stripe account settings.";
      } else if (error.code === 'resource_missing') {
        userMessage = "Session not found. The checkout session may have expired or you're using different Stripe accounts between environments.";
      }
      
      res.status(500).json({ 
        message: userMessage,
        details: error.message 
      });
    }
  });

  // Helper function to generate random license key segment
  function generateRandomSegment(): string {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excluding similar-looking characters
    let segment = '';
    for (let i = 0; i < 5; i++) {
      segment += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return segment;
  }

  /**
   * Stripe webhook handler
   * POST /api/stripe/webhook
   * Processes subscription lifecycle events
   */
  app.post("/api/stripe/webhook", async (req: Request, res: Response) => {
    const sig = req.headers['stripe-signature'];

    if (!sig) {
      console.error('[Stripe Webhook] Missing signature');
      return res.status(400).send('Missing signature');
    }

    try {
      // Construct event from webhook payload
      const event = stripeService.constructWebhookEvent(
        req.body,
        sig as string,
        process.env.STRIPE_WEBHOOK_SECRET || ''
      );

      // Handle the event with database update callback
      await stripeService.handleWebhookEvent(event, async (params) => {
        await storage.updateUser(params.userId.toString(), {
          stripeCustomerId: params.stripeCustomerId,
          stripeSubscriptionId: params.subscriptionId,
          subscriptionTier: params.tier,
          subscriptionStatus: params.status,
          subscriptionEndDate: params.currentPeriodEnd,
          whitelabelBrandingActive: params.whitelabelBrandingActive,
        });
      });

      res.json({ received: true });
    } catch (error: any) {
      console.error('[Stripe Webhook] Error:', error);
      res.status(400).send(`Webhook Error: ${error.message}`);
    }
  });

  /**
   * Get subscription status for current user
   * GET /api/stripe/subscription-status
   */
  app.get("/api/stripe/subscription-status", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts have subscriptions" });
      }

      if (!user.stripeCustomerId) {
        return res.json({
          hasActiveSubscription: false,
          message: "No subscription found",
        });
      }

      // Get subscription status from Stripe
      const status = await stripeService.getSubscriptionStatus(user.stripeCustomerId);

      res.json(status);
    } catch (error: any) {
      console.error('[Stripe] Get subscription status error:', error);
      res.status(500).json({ message: error.message || "Failed to retrieve subscription status" });
    }
  });

  /**
   * Cancel subscription (at period end)
   * POST /api/stripe/cancel-subscription
   */
  app.post("/api/stripe/cancel-subscription", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can manage subscriptions" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active subscription to cancel" });
      }

      // Cancel subscription at period end
      await stripeService.cancelSubscription(user.stripeSubscriptionId);

      console.log(`[Stripe] Subscription canceled for user ${user.id}`);
      res.json({ 
        message: "Subscription will be canceled at the end of the current billing period",
        success: true 
      });
    } catch (error: any) {
      console.error('[Stripe] Cancel subscription error:', error);
      res.status(500).json({ message: error.message || "Failed to cancel subscription" });
    }
  });

  /**
   * Reactivate a subscription scheduled for cancellation
   * POST /api/stripe/reactivate-subscription
   */
  app.post("/api/stripe/reactivate-subscription", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'company') {
        return res.status(403).json({ message: "Only company accounts can manage subscriptions" });
      }

      if (!user.stripeSubscriptionId) {
        return res.status(400).json({ message: "No subscription to reactivate" });
      }

      // Reactivate subscription
      await stripeService.reactivateSubscription(user.stripeSubscriptionId);

      console.log(`[Stripe] Subscription reactivated for user ${user.id}`);
      res.json({ 
        message: "Subscription reactivated successfully",
        success: true 
      });
    } catch (error: any) {
      console.error('[Stripe] Reactivate subscription error:', error);
      res.status(500).json({ message: error.message || "Failed to reactivate subscription" });
    }
  });
  
  // =====================================================================
  // END STRIPE ENDPOINTS
  // =====================================================================

  // =====================================================================
  // DASHBOARD PREFERENCES ENDPOINTS
  // =====================================================================

  // Get available cards for user (permission-filtered)
  app.get("/api/dashboard/available-cards", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const availableCards = getAvailableCardsForUser(user);
      const groupedCards = getCardsByCategory();
      
      // Filter grouped cards by user permissions
      const filteredGrouped: Record<string, any[]> = {};
      for (const [category, cards] of Object.entries(groupedCards)) {
        const filtered = cards.filter(card => {
          if (card.permission === null) return true;
          if (user.role === 'company') return true;
          // Convert camelCase permission to snake_case (e.g., viewProjects -> view_projects)
          const snakeCasePermission = card.permission.replace(/([A-Z])/g, '_$1').toLowerCase();
          return user.permissions?.includes(snakeCasePermission);
        });
        if (filtered.length > 0) {
          filteredGrouped[category] = filtered.map(c => ({
            id: c.id,
            name: c.name,
            description: c.description,
            category: c.category,
          }));
        }
      }

      res.json({ 
        cards: availableCards.map(c => ({
          id: c.id,
          name: c.name,
          category: c.category,
        })),
        grouped: filteredGrouped,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get available cards error:', error);
      res.status(500).json({ message: error.message || "Failed to get available cards" });
    }
  });

  // Get user's dashboard layout
  app.get("/api/dashboard/layout", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get saved preferences
      const prefs = await db.select()
        .from(dashboardPreferences)
        .where(eq(dashboardPreferences.userId, userId))
        .orderBy(asc(dashboardPreferences.position));

      if (prefs.length === 0) {
        // Return default layout for role
        const defaultCards = getDefaultLayoutForRole(user.role);
        return res.json({ 
          cards: defaultCards.map((id, idx) => ({ id, position: idx })),
          isDefault: true,
        });
      }

      res.json({ 
        cards: prefs.map(p => ({ id: p.cardId, position: p.position })),
        isDefault: false,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get layout error:', error);
      res.status(500).json({ message: error.message || "Failed to get dashboard layout" });
    }
  });

  // Save user's dashboard layout
  app.put("/api/dashboard/layout", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { cards } = req.body;

      if (!Array.isArray(cards)) {
        return res.status(400).json({ message: "cards must be an array of card IDs" });
      }

      // Validate all card IDs exist
      const validCardIds = CARD_REGISTRY.map(c => c.id);
      for (const cardId of cards) {
        if (!validCardIds.includes(cardId)) {
          return res.status(400).json({ message: `Invalid card ID: ${cardId}` });
        }
      }

      // Delete existing preferences
      await db.delete(dashboardPreferences)
        .where(eq(dashboardPreferences.userId, userId));

      // Insert new preferences
      if (cards.length > 0) {
        const inserts = cards.map((cardId: string, idx: number) => ({
          userId,
          cardId,
          position: idx,
        }));
        await db.insert(dashboardPreferences).values(inserts);
      }

      res.json({ success: true, cards });
    } catch (error: any) {
      console.error('[Dashboard] Save layout error:', error);
      res.status(500).json({ message: error.message || "Failed to save dashboard layout" });
    }
  });

  // =====================================================================
  // END DASHBOARD PREFERENCES ENDPOINTS
  // =====================================================================

  // =====================================================================
  // SIDEBAR PREFERENCES ENDPOINTS
  // =====================================================================

  // Get user's sidebar preferences for a specific dashboard variant
  app.get("/api/sidebar/preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { variant } = req.query;

      if (!variant || typeof variant !== 'string') {
        return res.status(400).json({ message: "variant query parameter is required" });
      }

      const validVariants = ['employer', 'technician', 'property-manager', 'resident', 'building-manager', 'ground-crew'];
      if (!validVariants.includes(variant)) {
        return res.status(400).json({ message: `Invalid variant. Must be one of: ${validVariants.join(', ')}` });
      }

      const prefs = await db.select()
        .from(sidebarPreferences)
        .where(and(
          eq(sidebarPreferences.userId, userId),
          eq(sidebarPreferences.dashboardVariant, variant)
        ))
        .orderBy(asc(sidebarPreferences.groupId), asc(sidebarPreferences.position));

      // Group by groupId for easier frontend consumption
      const grouped: Record<string, { itemId: string; position: number }[]> = {};
      for (const pref of prefs) {
        if (!grouped[pref.groupId]) {
          grouped[pref.groupId] = [];
        }
        grouped[pref.groupId].push({
          itemId: pref.itemId,
          position: pref.position,
        });
      }

      res.json({ 
        preferences: grouped,
        variant,
        isDefault: prefs.length === 0,
      });
    } catch (error: any) {
      console.error('[Sidebar] Get preferences error:', error);
      res.status(500).json({ message: error.message || "Failed to get sidebar preferences" });
    }
  });

  // Save user's sidebar preferences for a specific dashboard variant
  app.put("/api/sidebar/preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { variant, groups } = req.body;

      if (!variant || typeof variant !== 'string') {
        return res.status(400).json({ message: "variant is required" });
      }

      const validVariants = ['employer', 'technician', 'property-manager', 'resident', 'building-manager', 'ground-crew'];
      if (!validVariants.includes(variant)) {
        return res.status(400).json({ message: `Invalid variant. Must be one of: ${validVariants.join(', ')}` });
      }

      if (!groups || typeof groups !== 'object') {
        return res.status(400).json({ message: "groups must be an object with groupId keys" });
      }

      // Validate structure: groups is Record<string, { itemId: string; position: number }[]>
      const inserts: { userId: string; dashboardVariant: string; groupId: string; itemId: string; position: number }[] = [];
      for (const [groupId, items] of Object.entries(groups)) {
        if (!Array.isArray(items)) {
          return res.status(400).json({ message: `Group ${groupId} must contain an array of items` });
        }
        for (const item of items as any[]) {
          if (!item.itemId || typeof item.position !== 'number') {
            return res.status(400).json({ message: `Each item must have itemId and position` });
          }
          inserts.push({
            userId,
            dashboardVariant: variant,
            groupId,
            itemId: item.itemId,
            position: item.position,
          });
        }
      }

      // Delete existing preferences for this variant
      await db.delete(sidebarPreferences)
        .where(and(
          eq(sidebarPreferences.userId, userId),
          eq(sidebarPreferences.dashboardVariant, variant)
        ));

      // Insert new preferences
      if (inserts.length > 0) {
        await db.insert(sidebarPreferences).values(inserts);
      }

      res.json({ success: true, variant, groupCount: Object.keys(groups).length });
    } catch (error: any) {
      console.error('[Sidebar] Save preferences error:', error);
      res.status(500).json({ message: error.message || "Failed to save sidebar preferences" });
    }
  });

  // Reset sidebar preferences to default for a specific variant
  app.delete("/api/sidebar/preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { variant } = req.query;

      if (!variant || typeof variant !== 'string') {
        return res.status(400).json({ message: "variant query parameter is required" });
      }

      await db.delete(sidebarPreferences)
        .where(and(
          eq(sidebarPreferences.userId, userId),
          eq(sidebarPreferences.dashboardVariant, variant)
        ));

      res.json({ success: true, message: "Sidebar preferences reset to default" });
    } catch (error: any) {
      console.error('[Sidebar] Reset preferences error:', error);
      res.status(500).json({ message: error.message || "Failed to reset sidebar preferences" });
    }
  });

  // =====================================================================
  // END SIDEBAR PREFERENCES ENDPOINTS
  // =====================================================================

  // =====================================================================
  // DASHBOARD CARD DATA ENDPOINTS
  // =====================================================================

  // Get my time status (for technician's "My Time Today" card)
  app.get("/api/my-time-status", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ isClockedIn: false, hoursToday: 0 });
      }

      const today = getTodayString(companyId);
      
      // Find active work session (no end time)
      const activeSessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.employeeId, userId),
          eq(workSessions.companyId, companyId),
          isNull(workSessions.endTime)
        ))
        .limit(1);

      // Calculate hours worked today
      const todaySessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.employeeId, userId),
          eq(workSessions.companyId, companyId),
          eq(workSessions.workDate, today)
        ));

      let hoursToday = 0;
      for (const session of todaySessions) {
        if (session.startTime && session.endTime) {
          const diff = new Date(session.endTime).getTime() - new Date(session.startTime).getTime();
          hoursToday += diff / (1000 * 60 * 60);
        }
      }

      const activeSession = activeSessions[0];
      let projectName: string | undefined;
      if (activeSession) {
        const project = await storage.getProjectById(activeSession.projectId);
        projectName = project?.buildingName || undefined;
      }

      res.json({
        isClockedIn: !!activeSession,
        currentSessionStart: activeSession?.startTime?.toISOString(),
        hoursToday: Math.round(hoursToday * 10) / 10,
        projectName,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get my time status error:', error);
      res.status(500).json({ message: error.message || "Failed to get time status" });
    }
  });

  // Get active work sessions (for "Active Workers" card)
  app.get("/api/active-work-sessions", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ sessions: [], count: 0 });
      }

      // Find all active work sessions (no end time)
      const activeSessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          isNull(workSessions.endTime)
        ));

      const sessionsWithDetails = await Promise.all(activeSessions.map(async (session) => {
        const employee = await storage.getUserById(session.employeeId);
        const project = await storage.getProjectById(session.projectId);
        return {
          id: session.id,
          employeeName: employee ? `${employee.firstName} ${employee.lastName}` : "Unknown",
          projectName: project?.buildingName || "Unknown Project",
          startTime: session.startTime?.toISOString(),
        };
      }));

      res.json({
        sessions: sessionsWithDetails,
        count: activeSessions.length,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get active work sessions error:', error);
      res.status(500).json({ message: error.message || "Failed to get active sessions" });
    }
  });

  // Get my schedule (for technician's "My Schedule" card)
  app.get("/api/my-schedule", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ jobs: [] });
      }

      const now = new Date();
      const endOfWeek = new Date(now);
      endOfWeek.setDate(endOfWeek.getDate() + 7);

      // Get job assignments for this employee
      const assignments = await db.select()
        .from(jobAssignments)
        .where(eq(jobAssignments.employeeId, userId));

      const jobIds = assignments.map(a => a.jobId);
      if (jobIds.length === 0) {
        return res.json({ jobs: [] });
      }

      // Get scheduled jobs (upcoming within next 7 days)
      const jobs = await db.select()
        .from(scheduledJobs)
        .where(and(
          inArray(scheduledJobs.id, jobIds),
          eq(scheduledJobs.companyId, companyId),
          gte(scheduledJobs.startDate, now),
          lte(scheduledJobs.startDate, endOfWeek)
        ))
        .orderBy(asc(scheduledJobs.startDate))
        .limit(5);

      const jobsData = jobs.map(job => ({
        id: job.id,
        title: job.title,
        date: job.startDate?.toISOString().split('T')[0],
        time: job.startDate?.toISOString().split('T')[1]?.substring(0, 5) || "09:00",
        location: job.location || "",
        status: job.status,
      }));

      res.json({ jobs: jobsData });
    } catch (error: any) {
      console.error('[Dashboard] Get my schedule error:', error);
      res.status(500).json({ message: error.message || "Failed to get schedule" });
    }
  });

  // Get week summary (for "Week at a Glance" card)
  app.get("/api/schedule/week-summary", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ days: [] });
      }

      const today = new Date();
      const weekStart = new Date(today);
      weekStart.setDate(today.getDate() - today.getDay() + 1); // Monday
      weekStart.setHours(0, 0, 0, 0);
      
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);

      const weekStartStr = weekStart.toISOString().split('T')[0];
      const weekEndStr = weekEnd.toISOString().split('T')[0];

      // Get active projects that overlap with this week
      // Includes: projects with startDate <= weekEnd AND (endDate >= weekStart OR endDate is null for ongoing projects)
      // Status "active" means project is in progress, "completed" means finished
      const activeProjects = await db.select()
        .from(projectsTable)
        .where(and(
          eq(projectsTable.companyId, companyId),
          eq(projectsTable.status, "active"),
          eq(projectsTable.deleted, false),
          not(isNull(projectsTable.startDate)),
          lte(projectsTable.startDate, weekEndStr),
          or(
            gte(projectsTable.endDate, weekStartStr),
            isNull(projectsTable.endDate)
          )
        ));

      const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      const days = [];

      for (let i = 0; i < 7; i++) {
        const date = new Date(weekStart);
        date.setDate(weekStart.getDate() + i);
        const dateStr = date.toISOString().split('T')[0];
        
        // Count projects active on this day
        // Project is active if: startDate <= day AND (endDate >= day OR endDate is null)
        // Note: Drizzle returns date columns as strings in "YYYY-MM-DD" format
        const projectCount = activeProjects.filter(project => {
          const projectStart = project.startDate as string | null;
          const projectEnd = project.endDate as string | null;
          if (!projectStart || projectStart > dateStr) return false;
          if (!projectEnd) return true; // Ongoing project (no end date set)
          return projectEnd >= dateStr;
        }).length;

        days.push({
          date: dateStr,
          dayName: dayNames[i],
          jobCount: projectCount,
          isToday: dateStr === today.toISOString().split('T')[0],
        });
      }

      res.json({ days, uniqueJobCount: activeProjects.length });
    } catch (error: any) {
      console.error('[Dashboard] Get week summary error:', error);
      res.status(500).json({ message: error.message || "Failed to get week summary" });
    }
  });

  // Get toolbox coverage (for "Toolbox Coverage" card)
  app.get("/api/toolbox-coverage", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ lastMeetingDate: null, daysSinceMeeting: 999, totalMeetingsThisMonth: 0 });
      }

      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      // Get toolbox meetings for this company
      const meetings = await storage.getToolboxMeetings(companyId);
      
      // Sort by date descending to get most recent
      const sortedMeetings = [...meetings].sort((a, b) => 
        new Date(b.meetingDate).getTime() - new Date(a.meetingDate).getTime()
      );

      const lastMeeting = sortedMeetings[0];
      let daysSinceMeeting = 999;
      let lastMeetingDate: string | null = null;

      if (lastMeeting) {
        lastMeetingDate = lastMeeting.meetingDate;
        const lastDate = new Date(lastMeeting.meetingDate);
        daysSinceMeeting = Math.floor((now.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
      }

      // Count meetings this month
      const monthlyMeetings = meetings.filter(m => 
        new Date(m.meetingDate) >= startOfMonth
      );

      res.json({
        lastMeetingDate,
        daysSinceMeeting,
        totalMeetingsThisMonth: monthlyMeetings.length,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get toolbox coverage error:', error);
      res.status(500).json({ message: error.message || "Failed to get toolbox coverage" });
    }
  });

  // Get overtime alerts (for "Overtime Alert" card)
  app.get("/api/overtime-alerts", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ hasOvertime: false, employeesWithOvertime: 0, totalOvertimeHours: 0 });
      }

      // Get this week's work sessions
      const today = new Date();
      const weekStart = new Date(today);
      weekStart.setDate(today.getDate() - today.getDay());
      weekStart.setHours(0, 0, 0, 0);

      const sessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          gt(workSessions.startTime, weekStart)
        ));

      // Calculate hours per employee
      const employeeHours: Record<string, number> = {};
      for (const session of sessions) {
        if (session.startTime && session.endTime) {
          const hours = (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
          employeeHours[session.employeeId] = (employeeHours[session.employeeId] || 0) + hours;
        }
      }

      // Count employees with overtime (>40 hours/week)
      let employeesWithOvertime = 0;
      let totalOvertimeHours = 0;
      for (const [, hours] of Object.entries(employeeHours)) {
        if (hours > 40) {
          employeesWithOvertime++;
          totalOvertimeHours += hours - 40;
        }
      }

      res.json({
        hasOvertime: employeesWithOvertime > 0,
        employeesWithOvertime,
        totalOvertimeHours: Math.round(totalOvertimeHours * 10) / 10,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get overtime alerts error:', error);
      res.status(500).json({ message: error.message || "Failed to get overtime alerts" });
    }
  });

  // Get current pay period (for "Pay Period Summary" card)
  app.get("/api/current-pay-period", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ startDate: null, endDate: null, daysRemaining: 0, totalHours: 0 });
      }

      // Get pay period config
      const config = await storage.getPayPeriodConfig(companyId);
      
      const today = new Date();
      let startDate: Date;
      let endDate: Date;
      
      if (config) {
        // Calculate based on config
        const periodStart = new Date(config.periodStartDate);
        const periodLength = config.periodType === 'weekly' ? 7 : 
                           config.periodType === 'biweekly' ? 14 : 
                           config.periodType === 'semi_monthly' ? 15 : 30;
        
        // Find current period
        const daysSinceStart = Math.floor((today.getTime() - periodStart.getTime()) / (1000 * 60 * 60 * 24));
        const periodsElapsed = Math.floor(daysSinceStart / periodLength);
        
        startDate = new Date(periodStart);
        startDate.setDate(periodStart.getDate() + (periodsElapsed * periodLength));
        
        endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + periodLength - 1);
        endDate.setHours(23, 59, 59, 999); // Include full final day
      } else {
        // Default to biweekly
        const dayOfMonth = today.getDate();
        if (dayOfMonth <= 15) {
          startDate = new Date(today.getFullYear(), today.getMonth(), 1);
          endDate = new Date(today.getFullYear(), today.getMonth(), 15, 23, 59, 59, 999);
        } else {
          startDate = new Date(today.getFullYear(), today.getMonth(), 16);
          endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59, 999);
        }
      }

      const daysRemaining = Math.max(0, Math.ceil((endDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)));

      // Get work sessions in this period (inclusive bounds)
      const sessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          gte(workSessions.startTime, startDate),
          lte(workSessions.startTime, endDate)
        ));

      let totalHours = 0;
      for (const session of sessions) {
        if (session.startTime && session.endTime) {
          totalHours += (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
        }
      }

      res.json({
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        daysRemaining,
        totalHours: Math.round(totalHours * 10) / 10,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get current pay period error:', error);
      res.status(500).json({ message: error.message || "Failed to get pay period" });
    }
  });

  // Get quote summary (for "Outstanding Quotes" card)
  app.get("/api/quote-summary", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ pendingCount: 0, totalValue: 0, oldestDays: 0 });
      }

      // Get pending quotes
      const pendingQuotes = await db.select()
        .from(quotes)
        .where(and(
          eq(quotes.companyId, companyId),
          inArray(quotes.status, ['draft', 'sent', 'pending'])
        ));

      let totalValue = 0;
      let oldestDate: Date | null = null;

      for (const quote of pendingQuotes) {
        totalValue += Number(quote.totalAmount) || 0;
        if (quote.createdAt && (!oldestDate || quote.createdAt < oldestDate)) {
          oldestDate = quote.createdAt;
        }
      }

      const oldestDays = oldestDate 
        ? Math.floor((Date.now() - oldestDate.getTime()) / (1000 * 60 * 60 * 24))
        : 0;

      res.json({
        pendingCount: pendingQuotes.length,
        totalValue: Math.round(totalValue * 100) / 100,
        oldestDays,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get quote summary error:', error);
      res.status(500).json({ message: error.message || "Failed to get quote summary" });
    }
  });

  // Get my performance (for technician's "My Performance" card)
  app.get("/api/my-performance", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ completedJobs: 0, hoursThisMonth: 0, avgHoursPerJob: 0 });
      }

      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      // Get completed work sessions this month for this employee
      const sessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.employeeId, userId),
          eq(workSessions.companyId, companyId),
          gt(workSessions.startTime, startOfMonth)
        ));

      // Calculate total hours and count unique projects
      let hoursThisMonth = 0;
      const projectIds = new Set<string>();

      for (const session of sessions) {
        if (session.startTime && session.endTime) {
          hoursThisMonth += (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
        }
        projectIds.add(session.projectId);
      }

      const completedJobs = projectIds.size;
      const avgHoursPerJob = completedJobs > 0 ? hoursThisMonth / completedJobs : 0;

      res.json({
        completedJobs,
        hoursThisMonth: Math.round(hoursThisMonth * 10) / 10,
        avgHoursPerJob: Math.round(avgHoursPerJob * 10) / 10,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get my performance error:', error);
      res.status(500).json({ message: error.message || "Failed to get performance" });
    }
  });

  // Get today's hours (company-wide total for "Today's Hours" card)
  // Permission: viewWorkSessions
  app.get("/api/todays-hours", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: viewWorkSessions
      const hasPermission = user.role === 'company' || user.permissions?.includes('view_work_sessions');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ totalHours: 0, activeCount: 0, completedSessions: 0 });
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      const sessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          gte(workSessions.startTime, today),
          lt(workSessions.startTime, tomorrow)
        ));

      let totalHours = 0;
      let activeCount = 0;
      let completedSessions = 0;

      for (const session of sessions) {
        if (session.startTime && session.endTime) {
          totalHours += (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
          completedSessions++;
        } else if (session.startTime && !session.endTime) {
          activeCount++;
          totalHours += (Date.now() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
        }
      }

      res.json({
        totalHours: Math.round(totalHours * 10) / 10,
        activeCount,
        completedSessions,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get todays hours error:', error);
      res.status(500).json({ message: error.message || "Failed to get today's hours" });
    }
  });

  // Get employees not clocked in (for "Not Clocked In" card)
  // Permission: manageEmployees
  app.get("/api/not-clocked-in", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: manageEmployees
      const hasPermission = user.role === 'company' || user.permissions?.includes('manage_employees');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ employees: [], count: 0 });
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const endOfDay = new Date(today);
      endOfDay.setHours(23, 59, 59, 999);

      // Get today's scheduled jobs
      const todaysJobs = await db.select()
        .from(scheduledJobs)
        .where(and(
          eq(scheduledJobs.companyId, companyId),
          gte(scheduledJobs.startDate, today),
          lte(scheduledJobs.startDate, endOfDay)
        ));

      const jobIds = todaysJobs.map(j => j.id);
      if (jobIds.length === 0) {
        return res.json({ employees: [], count: 0 });
      }

      // Get assigned employees for today's jobs
      const assignments = await db.select()
        .from(jobAssignments)
        .where(inArray(jobAssignments.jobId, jobIds));

      const scheduledEmployeeIds = [...new Set(assignments.map(a => a.employeeId))];
      if (scheduledEmployeeIds.length === 0) {
        return res.json({ employees: [], count: 0 });
      }

      // Get active work sessions
      const activeSessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          gte(workSessions.startTime, today),
          isNull(workSessions.endTime)
        ));

      const clockedInEmployeeIds = new Set(activeSessions.map(s => s.employeeId));

      // Find employees who are scheduled but not clocked in
      const notClockedIn: Array<{ id: string; name: string; scheduledTime: string }> = [];
      
      for (const empId of scheduledEmployeeIds) {
        if (!clockedInEmployeeIds.has(empId)) {
          const emp = await storage.getUserById(empId);
          if (emp) {
            const empAssignment = assignments.find(a => a.employeeId === empId);
            const job = todaysJobs.find(j => j.id === empAssignment?.jobId);
            notClockedIn.push({
              id: empId,
              name: emp.name || emp.email,
              scheduledTime: job?.startDate ? new Date(job.startDate).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : 'Today',
            });
          }
        }
      }

      res.json({ employees: notClockedIn, count: notClockedIn.length });
    } catch (error: any) {
      console.error('[Dashboard] Get not clocked in error:', error);
      res.status(500).json({ message: error.message || "Failed to get not clocked in" });
    }
  });

  // Get overdue projects (for "Overdue Projects" card)
  // Permission: viewProjects
  app.get("/api/overdue-projects", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: viewProjects
      const hasPermission = user.role === 'company' || user.permissions?.includes('view_projects');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ projects: [], count: 0 });
      }

      const allProjects = await storage.getProjectsByCompanyId(companyId);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const overdueProjects = allProjects
        .filter(p => {
          if (p.status === 'completed' || p.status === 'cancelled') return false;
          if (!p.endDate) return false;
          const endDate = new Date(p.endDate);
          return endDate < today;
        })
        .map(p => {
          const endDate = new Date(p.endDate!);
          const daysOverdue = Math.floor((today.getTime() - endDate.getTime()) / (1000 * 60 * 60 * 24));
          return {
            id: p.id,
            name: p.name,
            daysOverdue,
          };
        })
        .sort((a, b) => b.daysOverdue - a.daysOverdue);

      res.json({ projects: overdueProjects, count: overdueProjects.length });
    } catch (error: any) {
      console.error('[Dashboard] Get overdue projects error:', error);
      res.status(500).json({ message: error.message || "Failed to get overdue projects" });
    }
  });

  // Get pending approvals (for "Pending Approvals" card)
  // Permission: canAccessFinancials
  app.get("/api/pending-approvals", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: canAccessFinancials
      const hasPermission = user.role === 'company' || user.permissions?.includes('view_financial_data');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ timesheetCount: 0, totalHours: 0 });
      }

      // Get work sessions that need approval (completed but not approved)
      const pendingSessions = await db.select()
        .from(workSessions)
        .where(and(
          eq(workSessions.companyId, companyId),
          eq(workSessions.approved, false),
          isNull(workSessions.endTime).not()
        ));

      let totalHours = 0;
      for (const session of pendingSessions) {
        if (session.startTime && session.endTime) {
          totalHours += (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
        }
      }

      res.json({
        timesheetCount: pendingSessions.length,
        totalHours: Math.round(totalHours * 10) / 10,
      });
    } catch (error: any) {
      console.error('[Dashboard] Get pending approvals error:', error);
      res.status(500).json({ message: error.message || "Failed to get pending approvals" });
    }
  });

  // Get expiring certifications (for "Expiring Certs" card)
  // Permission: viewSafetyDocuments
  app.get("/api/expiring-certs", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: viewSafetyDocuments
      const hasPermission = user.role === 'company' || user.permissions?.includes('view_safety_documents');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ certs: [], count: 0 });
      }

      const employees = await storage.getEmployeesByCompanyId(companyId);
      const today = new Date();
      const sixtyDaysFromNow = new Date(today);
      sixtyDaysFromNow.setDate(sixtyDaysFromNow.getDate() + 60);

      const expiringCerts: Array<{
        employeeId: string;
        employeeName: string;
        certType: string;
        daysUntilExpiry: number;
      }> = [];

      for (const emp of employees) {
        // Check IRATA expiry
        if (emp.irataExpiryDate) {
          const expiryDate = new Date(emp.irataExpiryDate);
          if (expiryDate >= today && expiryDate <= sixtyDaysFromNow) {
            const daysUntil = Math.ceil((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
            expiringCerts.push({
              employeeId: emp.id,
              employeeName: emp.name || emp.email,
              certType: `IRATA Level ${emp.irataLevel || '?'}`,
              daysUntilExpiry: daysUntil,
            });
          }
        }
        // Check SPRAT expiry
        if (emp.spratExpiryDate) {
          const expiryDate = new Date(emp.spratExpiryDate);
          if (expiryDate >= today && expiryDate <= sixtyDaysFromNow) {
            const daysUntil = Math.ceil((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
            expiringCerts.push({
              employeeId: emp.id,
              employeeName: emp.name || emp.email,
              certType: `SPRAT Level ${emp.spratLevel || '?'}`,
              daysUntilExpiry: daysUntil,
            });
          }
        }
      }

      expiringCerts.sort((a, b) => a.daysUntilExpiry - b.daysUntilExpiry);

      res.json({ certs: expiringCerts, count: expiringCerts.length });
    } catch (error: any) {
      console.error('[Dashboard] Get expiring certs error:', error);
      res.status(500).json({ message: error.message || "Failed to get expiring certs" });
    }
  });

  // Get new feedback (for "New Feedback" card)
  // Permission: viewFeedback
  app.get("/api/new-feedback", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Permission check: viewFeedback
      const hasPermission = user.role === 'company' || user.permissions?.includes('view_feedback');
      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = user.role === "company" ? user.id : user.companyId;
      if (!companyId) {
        return res.json({ unreadCount: 0, recentItems: [] });
      }

      // Get feature requests (as feedback items)
      const requests = await db.select()
        .from(featureRequests)
        .where(eq(featureRequests.companyId, companyId))
        .orderBy(desc(featureRequests.createdAt))
        .limit(10);

      const unreadItems = requests.filter(r => r.status === 'pending' || r.status === 'open');

      res.json({
        unreadCount: unreadItems.length,
        recentItems: unreadItems.slice(0, 5).map(r => ({
          id: r.id,
          subject: r.title,
          type: r.type || 'Feedback',
        })),
      });
    } catch (error: any) {
      console.error('[Dashboard] Get new feedback error:', error);
      res.status(500).json({ message: error.message || "Failed to get feedback" });
    }
  });

  // =====================================================================
  // END DASHBOARD CARD DATA ENDPOINTS
  // =====================================================================
  
  // Get current user
  app.get("/api/user", requireAuth, async (req: Request, res: Response) => {
    try {
      // Handle SuperUser session
      if (req.session.userId === 'superuser') {
        return res.json({
          user: {
            id: 'superuser',
            name: 'Super User',
            fullName: 'Super User',
            email: 'superuser@system',
            role: 'superuser',
            companyName: 'System Admin',
          }
        });
      }
      
      // Handle Staff account session
      if (req.session.role === 'staff') {
        const staffAccount = await storage.getStaffAccountById(req.session.userId!);
        if (!staffAccount || !staffAccount.isActive) {
          return res.status(401).json({ message: "Staff account not found or disabled" });
        }
        
        return res.json({
          user: {
            id: staffAccount.id,
            name: `${staffAccount.firstName} ${staffAccount.lastName}`,
            fullName: `${staffAccount.firstName} ${staffAccount.lastName}`,
            email: staffAccount.email,
            role: 'staff',
            permissions: staffAccount.permissions,
          }
        });
      }
      
      let user = await storage.getUserById(req.session.userId!);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Auto-renew subscription if renewal date has passed (company users only)
      // ONLY renew if license is still verified
      if (user.role === 'company' && user.subscriptionRenewalDate && user.licenseVerified === true) {
        try {
          const today = new Date();
          today.setHours(0, 0, 0, 0); // Reset to start of day for accurate comparison
          const renewalDate = new Date(user.subscriptionRenewalDate);
          renewalDate.setHours(0, 0, 0, 0);
          
          // If renewal date has passed, extend by 30 days (only if license is verified)
          if (renewalDate <= today) {
            const newRenewalDate = new Date(renewalDate);
            newRenewalDate.setDate(newRenewalDate.getDate() + 30);
            const subscriptionRenewalDate = newRenewalDate.toISOString().split('T')[0];
            
            await storage.updateUser(user.id, { subscriptionRenewalDate });
            console.log(`[/api/user] Subscription auto-renewed for ${user.email}. New renewal date: ${subscriptionRenewalDate}`);
            
            // Refetch user to get the updated renewal date
            user = await storage.getUserById(user.id) || user;
          }
        } catch (error) {
          console.error('[/api/user] Failed to auto-renew subscription:', error);
          // Continue without renewal - user can still access the system
        }
      } else if (user.role === 'company' && user.subscriptionRenewalDate && user.licenseVerified !== true) {
        // License is not verified - do not auto-renew
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const renewalDate = new Date(user.subscriptionRenewalDate);
        renewalDate.setHours(0, 0, 0, 0);
        
        if (renewalDate <= today) {
          console.warn(`[/api/user] Subscription expired for ${user.email} - license not verified, skipping auto-renewal`);
        }
      }
      
      // Auto-generate codes if company doesn't have them
      if (user.role === 'company') {
        const updates: any = {};
        
        // Generate resident code if missing
        if (!user.residentCode) {
          try {
            console.log('[/api/user] Company missing resident code, generating...');
            const residentCode = await generateResidentCode();
            updates.residentCode = residentCode;
            console.log(`[/api/user] Resident code generated: ${residentCode}`);
          } catch (error) {
            console.error('[/api/user] Failed to generate resident code:', error);
          }
        }
        
        // Generate property manager code if missing
        if (!user.propertyManagerCode) {
          try {
            console.log('[/api/user] Company missing property manager code, generating...');
            const propertyManagerCode = await generatePropertyManagerCode();
            updates.propertyManagerCode = propertyManagerCode;
            console.log(`[/api/user] Property manager code generated: ${propertyManagerCode}`);
          } catch (error) {
            console.error('[/api/user] Failed to generate property manager code:', error);
          }
        }
        
        // Update user if any codes were generated
        if (Object.keys(updates).length > 0) {
          await storage.updateUser(user.id, updates);
          // Refetch user to get the updated codes
          user = await storage.getUserById(user.id) || user;
        }
      }
      
      // Auto-generate PM code if property manager doesn't have one
      if (user.role === 'property_manager' && !user.pmCode) {
        try {
          console.log('[/api/user] Property manager missing PM code, generating...');
          const pmCode = await generatePmCode();
          await storage.updateUser(user.id, { pmCode });
          user = await storage.getUserById(user.id) || user;
          console.log(`[/api/user] PM code generated: ${pmCode}`);
        } catch (error) {
          console.error('[/api/user] Failed to generate PM code:', error);
        }
      }
      
      // Check if user has been terminated - destroy session if so
      // Exception: Self-resigned technicians can still log in to accept new invitations
      if (user.terminatedDate && user.terminationReason !== "Self-resigned") {
        req.session.destroy(() => {});
        return res.status(403).json({ message: "Your employment has been terminated. Please contact your administrator for more information." });
      }
      
      // For employees: include parent company's license verification status, resident code, AND company name
      let companyLicenseVerified: boolean | undefined = undefined;
      let companyResidentCode: string | undefined = undefined;
      let employerCompanyName: string | undefined = undefined;
      if (user.role !== 'company' && user.role !== 'resident' && user.companyId) {
        try {
          const parentCompany = await storage.getUserById(user.companyId);
          if (parentCompany) {
            companyLicenseVerified = parentCompany.licenseVerified;
            companyResidentCode = parentCompany.residentCode || undefined;
            employerCompanyName = parentCompany.companyName || parentCompany.name || undefined;
          } else {
            console.warn(`[/api/user] Parent company not found for employee ${user.id}, companyId: ${user.companyId}`);
          }
        } catch (parentError) {
          console.error(`[/api/user] Error fetching parent company for employee ${user.id}:`, parentError);
          // Continue without parent company verification status
        }
      }
      
      // Strip sensitive fields (passwordHash)
      // Include licenseKey for company users so they can view it in their subscription page
      const { passwordHash, ...userWithoutPassword } = user;
      
      // For technicians: compute PLUS status based on database OR referral count
      let hasPlusAccess = user.hasPlusAccess || false;
      let referralCount = 0;
      if (user.role === 'rope_access_tech') {
        try {
          referralCount = await storage.getReferralCount(user.id);
          // PLUS access is granted if: manually granted by SuperUser OR has at least 1 referral
          hasPlusAccess = user.hasPlusAccess || referralCount >= 1;
        } catch (err) {
          console.error('[/api/user] Failed to get referral count:', err);
        }
      }
      
      // Disable caching to ensure fresh data
      res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
      
      // Compute fullName for frontend display
      // For property_manager: use firstName + lastName
      // For other roles: use name field or companyName
      let fullName: string | undefined;
      if (user.role === 'property_manager' && user.firstName && user.lastName) {
        fullName = `${user.firstName} ${user.lastName}`;
      } else if (user.name) {
        fullName = user.name;
      } else if (user.companyName) {
        fullName = user.companyName;
      }
      
      res.json({ 
        user: {
          ...userWithoutPassword,
          ...(fullName && { fullName }),
          ...(companyLicenseVerified !== undefined && { companyLicenseVerified }),
          ...(companyResidentCode && { residentCode: companyResidentCode }),
          ...(employerCompanyName && { companyName: employerCompanyName }),
          ...(user.role === 'rope_access_tech' && { hasPlusAccess, referralCount })
        }
      });
    } catch (error) {
      console.error("Get user error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Technician: Update own profile
  app.patch("/api/technician/profile", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Allow technicians and employees to update their own profile
      const allowedRoles = ['rope_access_tech', 'operations_manager', 'office_admin', 'safety_officer', 'ground_crew'];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ message: "Only technicians can update their profile via this endpoint" });
      }

      const {
        name,
        email,
        employeePhoneNumber,
        smsNotificationsEnabled,
        employeeStreetAddress,
        employeeCity,
        employeeProvinceState,
        employeeCountry,
        employeePostalCode,
        emergencyContactName,
        emergencyContactPhone,
        emergencyContactRelationship,
        socialInsuranceNumber,
        bankTransitNumber,
        bankInstitutionNumber,
        bankAccountNumber,
        driversLicenseNumber,
        driversLicenseIssuedDate,
        driversLicenseExpiry,
        birthday,
        specialMedicalConditions,
        irataBaselineHours,
        irataHoursAtLastUpgrade,
        irataLastUpgradeDate,
        irataExpirationDate,
        spratBaselineHours,
        spratHoursAtLastUpgrade,
        spratLastUpgradeDate,
        spratExpirationDate,
        ropeAccessSpecialties,
      } = req.body;

      // Validate required fields
      if (!name || !email || !employeePhoneNumber) {
        return res.status(400).json({ message: "Name, email, and phone are required" });
      }

      if (!emergencyContactName || !emergencyContactPhone) {
        return res.status(400).json({ message: "Emergency contact is required" });
      }

      // Check if email is being changed to one that already exists
      if (email !== user.email) {
        const existingUser = await storage.getUserByEmail(email);
        if (existingUser && existingUser.id !== userId) {
          return res.status(400).json({ message: "Email is already in use by another account" });
        }
      }

      // Build update object - storage.updateUser handles encryption automatically
      // via encryptSensitiveFields for SIN, bank info, and medical conditions
      const updateData: any = {
        name,
        email,
        employeePhoneNumber,
        smsNotificationsEnabled,
        emergencyContactName,
        emergencyContactPhone,
      };

      // Add optional address fields only if provided
      if (smsNotificationsEnabled !== undefined) updateData.smsNotificationsEnabled = smsNotificationsEnabled ?? false;
      if (employeeStreetAddress !== undefined) updateData.employeeStreetAddress = employeeStreetAddress || null;
      if (employeeCity !== undefined) updateData.employeeCity = employeeCity || null;
      if (employeeProvinceState !== undefined) updateData.employeeProvinceState = employeeProvinceState || null;
      if (employeeCountry !== undefined) updateData.employeeCountry = employeeCountry || null;
      if (employeePostalCode !== undefined) updateData.employeePostalCode = employeePostalCode || null;
      if (emergencyContactRelationship !== undefined) updateData.emergencyContactRelationship = emergencyContactRelationship || null;
      if (birthday !== undefined) updateData.birthday = birthday || null;
      if (driversLicenseIssuedDate !== undefined) updateData.driversLicenseIssuedDate = driversLicenseIssuedDate || null;
      if (driversLicenseExpiry !== undefined) updateData.driversLicenseExpiry = driversLicenseExpiry || null;
      if (irataBaselineHours !== undefined) updateData.irataBaselineHours = irataBaselineHours || "0";
      if (irataHoursAtLastUpgrade !== undefined) updateData.irataHoursAtLastUpgrade = irataHoursAtLastUpgrade || null;
      if (irataLastUpgradeDate !== undefined) updateData.irataLastUpgradeDate = irataLastUpgradeDate || null;
      if (irataExpirationDate !== undefined) updateData.irataExpirationDate = irataExpirationDate || null;
      if (spratBaselineHours !== undefined) updateData.spratBaselineHours = spratBaselineHours || "0";
      if (spratHoursAtLastUpgrade !== undefined) updateData.spratHoursAtLastUpgrade = spratHoursAtLastUpgrade || null;
      if (spratLastUpgradeDate !== undefined) updateData.spratLastUpgradeDate = spratLastUpgradeDate || null;
      if (spratExpirationDate !== undefined) updateData.spratExpirationDate = spratExpirationDate || null;
      if (ropeAccessSpecialties !== undefined) updateData.ropeAccessSpecialties = Array.isArray(ropeAccessSpecialties) ? ropeAccessSpecialties : [];

      // Sensitive fields - these are encrypted by storage.updateUser via encryptSensitiveFields
      if (socialInsuranceNumber !== undefined) updateData.socialInsuranceNumber = socialInsuranceNumber || null;
      if (bankTransitNumber !== undefined) updateData.bankTransitNumber = bankTransitNumber || null;
      if (bankInstitutionNumber !== undefined) updateData.bankInstitutionNumber = bankInstitutionNumber || null;
      if (bankAccountNumber !== undefined) updateData.bankAccountNumber = bankAccountNumber || null;
      if (driversLicenseNumber !== undefined) updateData.driversLicenseNumber = driversLicenseNumber || null;
      if (specialMedicalConditions !== undefined) updateData.specialMedicalConditions = specialMedicalConditions || null;

      // Update the user profile - storage.updateUser applies encryption to sensitive fields
      const updatedUser = await storage.updateUser(userId, updateData);

      console.log(`[Technician-Profile] Profile updated for user ${userId}`);

      // Strip/mask sensitive fields before returning to minimize transport exposure
      const { 
        passwordHash, 
        socialInsuranceNumber: sinValue,
        bankTransitNumber: transitValue,
        bankInstitutionNumber: instValue,
        bankAccountNumber: acctValue,
        driversLicenseNumber: dlValue,
        specialMedicalConditions: medValue,
        ...safeUser 
      } = updatedUser;

      // Mask sensitive values - show only last 4 chars if they exist
      const maskValue = (val: string | null) => {
        if (!val) return null;
        if (val.length <= 4) return '****';
        return '*'.repeat(val.length - 4) + val.slice(-4);
      };

      const maskedUser = {
        ...safeUser,
        socialInsuranceNumber: maskValue(sinValue),
        bankTransitNumber: maskValue(transitValue),
        bankInstitutionNumber: maskValue(instValue),
        bankAccountNumber: maskValue(acctValue),
        driversLicenseNumber: maskValue(dlValue),
        specialMedicalConditions: medValue ? '[Recorded]' : null,
      };

      res.json({ user: maskedUser });
    } catch (error: any) {
      console.error("[Technician-Profile] Error updating profile:", error);
      res.status(500).json({ message: error.message || "Failed to update profile" });
    }
  });

  // Technician: Update certification expiration date only
  // This is a simpler endpoint that only updates expiration dates without requiring full profile data
  app.patch("/api/technician/expiration-date", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only technicians and employees can update their own expiration dates
      const allowedRoles = ['rope_access_tech', 'operations_manager', 'office_admin', 'safety_officer', 'ground_crew'];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ message: "Only technicians can update expiration dates via this endpoint" });
      }

      const { type, date } = req.body;

      if (!type || !['irata', 'sprat'].includes(type)) {
        return res.status(400).json({ message: "Invalid type. Must be 'irata' or 'sprat'" });
      }

      if (!date) {
        return res.status(400).json({ message: "Date is required" });
      }

      // Validate date format (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(date)) {
        return res.status(400).json({ message: "Invalid date format. Use YYYY-MM-DD" });
      }

      const updateData: any = {};
      if (type === 'irata') {
        updateData.irataExpirationDate = date;
      } else {
        updateData.spratExpirationDate = date;
      }

      await storage.updateUser(userId, updateData);

      console.log(`[Technician-Expiration] ${type.toUpperCase()} expiration date updated to ${date} for user ${userId}`);

      res.json({ success: true, message: `${type.toUpperCase()} expiration date updated` });
    } catch (error: any) {
      console.error("[Technician-Expiration] Error updating expiration date:", error);
      res.status(500).json({ message: error.message || "Failed to update expiration date" });
    }
  });

  // Technician: Update experience start date only
  // This is a simpler endpoint that only updates the rope access start date
  app.patch("/api/technician/experience-date", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only technicians and employees can update their own experience date
      const allowedRoles = ['rope_access_tech', 'operations_manager', 'office_admin', 'safety_officer', 'ground_crew'];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ message: "Only technicians can update experience date via this endpoint" });
      }

      const { date } = req.body;

      if (!date) {
        return res.status(400).json({ message: "Date is required" });
      }

      // Validate date format (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(date)) {
        return res.status(400).json({ message: "Invalid date format. Use YYYY-MM-DD" });
      }

      await storage.updateUser(userId, { ropeAccessStartDate: date });

      console.log(`[Technician-Experience] Experience start date updated to ${date} for user ${userId}`);

      res.json({ success: true, message: "Experience start date updated" });
    } catch (error: any) {
      console.error("[Technician-Experience] Error updating experience date:", error);
      res.status(500).json({ message: error.message || "Failed to update experience date" });
    }
  });

  // Technician: Leave company (self-unlink)
  // This sets a terminated date so the technician appears in the employer's terminated section
  // for historical HR/payroll records, while allowing the technician to be invited by other companies
  app.post("/api/technician/leave-company", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Technicians and ground crew can use this endpoint
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians and ground crew can leave a company" });
      }

      // Must be linked to a company to leave
      if (!user.companyId) {
        return res.status(400).json({ message: "You are not currently linked to any company" });
      }

      const companyId = user.companyId;
      const company = await storage.getUserById(companyId);
      const companyName = company?.companyName || company?.name || 'Unknown Company';

      // Set terminated date and reason, but KEEP companyId for historical records
      // This puts them in the "terminated employees" section for the employer
      await storage.updateUser(userId, {
        terminatedDate: new Date().toISOString().split('T')[0],
        terminationReason: "Self-resigned",
        terminationNotes: `Technician voluntarily left the company on ${new Date().toLocaleDateString()}`
      });

      console.log(`[Team] Technician ${user.name} (${userId}) self-resigned from company ${companyId}`);

      res.json({ 
        message: "Successfully left the company",
        companyName
      });
    } catch (error: any) {
      console.error("[Technician] Error leaving company:", error);
      res.status(500).json({ message: error.message || "Failed to leave company" });
    }
  });

  // Generate referral code for users who don't have one
  // This allows company owners and other users to get a referral code
  app.post("/api/user/generate-referral-code", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // If user already has a referral code, return it
      if (user.referralCode) {
        return res.json({ 
          referralCode: user.referralCode,
          message: "Referral code already exists"
        });
      }

      // Generate a new referral code
      const newReferralCode = await generateReferralCode();
      
      // Update the user with the new referral code
      await storage.updateUser(userId, { referralCode: newReferralCode });

      console.log(`[Referral] Generated referral code ${newReferralCode} for user ${userId} (${user.role})`);

      res.json({ 
        referralCode: newReferralCode,
        message: "Referral code generated successfully"
      });
    } catch (error: any) {
      console.error("[Referral] Error generating referral code:", error);
      res.status(500).json({ message: error.message || "Failed to generate referral code" });
    }
  });

  // Redeem a referral code after registration
  // Allows technicians who missed entering a code during signup to help their referrer earn PLUS
  app.post("/api/user/redeem-referral-code", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only technicians can redeem referral codes
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can redeem referral codes" });
      }

      // Check if user has already used a referral code
      if (user.referredByUserId || user.referredByCode) {
        return res.status(400).json({ message: "You have already redeemed a referral code" });
      }

      const { referralCode } = req.body;
      if (!referralCode || !referralCode.trim()) {
        return res.status(400).json({ message: "Referral code is required" });
      }

      const normalizedCode = referralCode.trim().toUpperCase();

      // Validate the referral code exists and belongs to a technician
      const referrer = await storage.getUserByReferralCode(normalizedCode);
      if (!referrer) {
        return res.status(400).json({ message: "Invalid referral code. Please check and try again." });
      }

      // Verify the referrer is an active technician
      if (referrer.role !== 'rope_access_tech') {
        return res.status(400).json({ message: "Invalid referral code. Please check and try again." });
      }

      // Can't use your own referral code
      if (referrer.id === userId) {
        return res.status(400).json({ message: "You cannot use your own referral code" });
      }

      // Update the user with the referral information
      await storage.updateUser(userId, {
        referredByUserId: referrer.id,
        referredByCode: normalizedCode,
      });

      console.log(`[Referral] User ${userId} redeemed referral code ${normalizedCode} from ${referrer.id}`);

      res.json({ 
        success: true,
        message: `Referral code redeemed successfully! ${referrer.name || 'The referrer'} will now have PLUS access.`,
        referrerName: referrer.name
      });
    } catch (error: any) {
      console.error("[Referral] Error redeeming referral code:", error);
      res.status(500).json({ message: error.message || "Failed to redeem referral code" });
    }
  });

  // Multer config for technician document uploads (images or PDFs)
  const technicianDocumentUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max per file
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
        cb(null, true);
      } else {
        cb(new Error('Only image or PDF files are allowed'));
      }
    }
  });

  // Technician: Upload documents (void cheque, driver's license, first aid, certification card)
  app.post("/api/technician/upload-document", requireAuth, technicianDocumentUpload.single('file'), async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can upload documents through this endpoint" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { documentType } = req.body;
      if (!documentType) {
        return res.status(400).json({ message: "Document type is required" });
      }

      const validTypes = ['voidCheque', 'driversLicense', 'driversAbstract', 'firstAidCertificate', 'certificationCard', 'irataCertificationCard', 'spratCertificationCard', 'resume'];
      if (!validTypes.includes(documentType)) {
        return res.status(400).json({ message: `Invalid document type. Must be one of: ${validTypes.join(', ')}` });
      }

      // Upload file to object storage
      const objectStorageService = new ObjectStorageService();
      const timestamp = Date.now();
      const extension = req.file.mimetype === 'application/pdf' ? 'pdf' : req.file.mimetype.split('/')[1];
      const filename = `technician-${userId}-${documentType}-${timestamp}.${extension}`;
      
      const url = await objectStorageService.uploadPublicFile(filename, req.file.buffer, req.file.mimetype);
      
      console.log(`[Technician] Uploaded ${documentType} for user ${userId}:`, url);

      // Update the user's document arrays based on document type
      let updateData: any = {};
      
      if (documentType === 'voidCheque') {
        const existingDocs = user.bankDocuments || [];
        updateData.bankDocuments = [...existingDocs, url];
      } else if (documentType === 'driversLicense' || documentType === 'driversAbstract') {
        const existingDocs = user.driversLicenseDocuments || [];
        updateData.driversLicenseDocuments = [...existingDocs, url];
      } else if (documentType === 'firstAidCertificate') {
        const existingDocs = user.firstAidDocuments || [];
        updateData.firstAidDocuments = [...existingDocs, url];
      } else if (documentType === 'certificationCard' || documentType === 'irataCertificationCard') {
        const existingDocs = user.irataDocuments || [];
        updateData.irataDocuments = [...existingDocs, url];
      } else if (documentType === 'spratCertificationCard') {
        const existingDocs = user.spratDocuments || [];
        updateData.spratDocuments = [...existingDocs, url];
      } else if (documentType === 'resume') {
        const existingDocs = user.resumeDocuments || [];
        updateData.resumeDocuments = [...existingDocs, url];
      }

      await storage.updateUser(userId, updateData);

      res.json({ 
        message: "Document uploaded successfully",
        url,
        documentType
      });
    } catch (error: any) {
      console.error("[Technician] Error uploading document:", error);
      res.status(500).json({ message: error.message || "Failed to upload document" });
    }
  });

  // Technician: Delete uploaded document
  app.delete("/api/technician/document", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can delete documents through this endpoint" });
      }

      const { documentType, documentUrl } = req.body;
      if (!documentType || !documentUrl) {
        return res.status(400).json({ message: "Document type and URL are required" });
      }

      const validTypes = ['bankDocuments', 'driversLicenseDocuments', 'firstAidDocuments', 'irataDocuments', 'spratDocuments', 'resumeDocuments'];
      if (!validTypes.includes(documentType)) {
        return res.status(400).json({ message: `Invalid document type. Must be one of: ${validTypes.join(', ')}` });
      }

      // Get the current document array and remove the URL
      let updateData: any = {};
      let currentDocs: string[] = [];
      
      if (documentType === 'bankDocuments') {
        currentDocs = user.bankDocuments || [];
      } else if (documentType === 'driversLicenseDocuments') {
        currentDocs = user.driversLicenseDocuments || [];
      } else if (documentType === 'firstAidDocuments') {
        currentDocs = user.firstAidDocuments || [];
      } else if (documentType === 'irataDocuments') {
        currentDocs = user.irataDocuments || [];
      } else if (documentType === 'spratDocuments') {
        currentDocs = user.spratDocuments || [];
      } else if (documentType === 'resumeDocuments') {
        currentDocs = user.resumeDocuments || [];
      }

      // Check if the document exists
      if (!currentDocs.includes(documentUrl)) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Remove the document URL from the array
      const updatedDocs = currentDocs.filter(url => url !== documentUrl);
      updateData[documentType] = updatedDocs;

      await storage.updateUser(userId, updateData);

      console.log(`[Technician] Deleted ${documentType} document for user ${userId}`);

      res.json({ 
        message: "Document deleted successfully",
        documentType
      });
    } catch (error: any) {
      console.error("[Technician] Error deleting document:", error);
      res.status(500).json({ message: error.message || "Failed to delete document" });
    }
  });

  // Ground Crew: Upload documents (void cheque, driver's license, first aid)
  app.post("/api/ground-crew/upload-document", requireAuth, technicianDocumentUpload.single('file'), async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'ground_crew' && user.role !== 'ground_crew_supervisor') {
        return res.status(403).json({ message: "Only ground crew members can upload documents through this endpoint" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { documentType } = req.body;
      if (!documentType) {
        return res.status(400).json({ message: "Document type is required" });
      }

      const validTypes = ['voidCheque', 'driversLicense', 'firstAidCertificate'];
      if (!validTypes.includes(documentType)) {
        return res.status(400).json({ message: `Invalid document type. Must be one of: ${validTypes.join(', ')}` });
      }

      // Upload file to object storage
      const objectStorageService = new ObjectStorageService();
      const timestamp = Date.now();
      const extension = req.file.mimetype === 'application/pdf' ? 'pdf' : req.file.mimetype.split('/')[1];
      const filename = `ground-crew-${userId}-${documentType}-${timestamp}.${extension}`;
      
      const url = await objectStorageService.uploadPublicFile(filename, req.file.buffer, req.file.mimetype);
      
      console.log(`[GroundCrew] Uploaded ${documentType} for user ${userId}:`, url);

      // Update the user's document arrays based on document type
      let updateData: any = {};
      
      if (documentType === 'voidCheque') {
        const existingDocs = user.bankDocuments || [];
        updateData.bankDocuments = [...existingDocs, url];
      } else if (documentType === 'driversLicense') {
        const existingDocs = user.driversLicenseDocuments || [];
        updateData.driversLicenseDocuments = [...existingDocs, url];
      } else if (documentType === 'firstAidCertificate') {
        const existingDocs = user.firstAidDocuments || [];
        updateData.firstAidDocuments = [...existingDocs, url];
      }

      await storage.updateUser(userId, updateData);

      res.json({ 
        message: "Document uploaded successfully",
        url,
        documentType
      });
    } catch (error: any) {
      console.error("[GroundCrew] Error uploading document:", error);
      res.status(500).json({ message: error.message || "Failed to upload document" });
    }
  });

  // Ground Crew: Delete uploaded document
  app.delete("/api/ground-crew/document", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'ground_crew' && user.role !== 'ground_crew_supervisor') {
        return res.status(403).json({ message: "Only ground crew members can delete documents through this endpoint" });
      }

      const { documentType, documentUrl } = req.body;
      if (!documentType || !documentUrl) {
        return res.status(400).json({ message: "Document type and URL are required" });
      }

      const validTypes = ['bankDocuments', 'driversLicenseDocuments', 'firstAidDocuments'];
      if (!validTypes.includes(documentType)) {
        return res.status(400).json({ message: `Invalid document type. Must be one of: ${validTypes.join(', ')}` });
      }

      // Get the current document array and remove the URL
      let currentDocs: string[] = [];
      
      if (documentType === 'bankDocuments') {
        currentDocs = user.bankDocuments || [];
      } else if (documentType === 'driversLicenseDocuments') {
        currentDocs = user.driversLicenseDocuments || [];
      } else if (documentType === 'firstAidDocuments') {
        currentDocs = user.firstAidDocuments || [];
      }

      // Check if the document exists
      if (!currentDocs.includes(documentUrl)) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Remove the document URL from the array
      const updatedDocs = currentDocs.filter(url => url !== documentUrl);
      const updateData: any = {};
      updateData[documentType] = updatedDocs;

      await storage.updateUser(userId, updateData);

      console.log(`[GroundCrew] Deleted ${documentType} document for user ${userId}`);

      res.json({ 
        message: "Document deleted successfully",
        documentType
      });
    } catch (error: any) {
      console.error("[GroundCrew] Error deleting document:", error);
      res.status(500).json({ message: error.message || "Failed to delete document" });
    }
  });

  // ==================== USER CERTIFICATIONS API ====================
  
  // Get all certifications for the current user
  app.get("/api/user/certifications", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can access certifications" });
      }

      const certifications = await db.select().from(userCertifications).where(eq(userCertifications.userId, userId)).orderBy(desc(userCertifications.createdAt));
      
      res.json({ certifications });
    } catch (error: any) {
      console.error("[UserCertifications] Error fetching certifications:", error);
      res.status(500).json({ message: error.message || "Failed to fetch certifications" });
    }
  });

  // Upload a new certification document
  app.post("/api/user/certifications", requireAuth, technicianDocumentUpload.single('file'), async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can upload certifications" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { description, expiryDate } = req.body;

      // Upload file to object storage
      const objectStorageService = new ObjectStorageService();
      const timestamp = Date.now();
      const extension = req.file.mimetype === 'application/pdf' ? 'pdf' : req.file.mimetype.split('/')[1];
      const filename = `certification-${userId}-${timestamp}.${extension}`;
      
      const url = await objectStorageService.uploadPublicFile(filename, req.file.buffer, req.file.mimetype);
      
      console.log(`[UserCertifications] Uploaded certification for user ${userId}:`, url);

      // Insert into database
      const [certification] = await db.insert(userCertifications).values({
        userId,
        fileName: req.file.originalname,
        fileUrl: url,
        description: description || null,
        expiryDate: expiryDate || null,
      }).returning();

      res.json({ 
        message: "Certification uploaded successfully",
        certification
      });
    } catch (error: any) {
      console.error("[UserCertifications] Error uploading certification:", error);
      res.status(500).json({ message: error.message || "Failed to upload certification" });
    }
  });

  // Update a certification
  app.patch("/api/user/certifications/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { id } = req.params;
      const { description, expiryDate } = req.body;
      
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can update certifications" });
      }

      // Verify ownership
      const [existing] = await db.select().from(userCertifications).where(and(eq(userCertifications.id, id), eq(userCertifications.userId, userId)));
      
      if (!existing) {
        return res.status(404).json({ message: "Certification not found" });
      }

      const [updated] = await db.update(userCertifications)
        .set({
          description: description !== undefined ? description : existing.description,
          expiryDate: expiryDate !== undefined ? expiryDate : existing.expiryDate,
          updatedAt: new Date(),
        })
        .where(eq(userCertifications.id, id))
        .returning();

      res.json({ 
        message: "Certification updated successfully",
        certification: updated
      });
    } catch (error: any) {
      console.error("[UserCertifications] Error updating certification:", error);
      res.status(500).json({ message: error.message || "Failed to update certification" });
    }
  });

  // Delete a certification
  app.delete("/api/user/certifications/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const { id } = req.params;
      
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can delete certifications" });
      }

      // Verify ownership
      const [existing] = await db.select().from(userCertifications).where(and(eq(userCertifications.id, id), eq(userCertifications.userId, userId)));
      
      if (!existing) {
        return res.status(404).json({ message: "Certification not found" });
      }

      await db.delete(userCertifications).where(eq(userCertifications.id, id));

      console.log(`[UserCertifications] Deleted certification ${id} for user ${userId}`);

      res.json({ message: "Certification deleted successfully" });
    } catch (error: any) {
      console.error("[UserCertifications] Error deleting certification:", error);
      res.status(500).json({ message: error.message || "Failed to delete certification" });
    }
  });


  // Property Manager: Get all company links
  app.get("/api/property-manager/company-links", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const links = await storage.getPropertyManagerCompanyLinks(req.session.userId!);
      
      // Fetch company details for each link
      const linksWithCompanyDetails = await Promise.all(
        links.map(async (link) => {
          const company = await storage.getUserById(link.companyId);
          return {
            ...link,
            companyName: company?.companyName || 'Unknown Company',
          };
        })
      );
      
      res.json({ links: linksWithCompanyDetails });
    } catch (error) {
      console.error("Get property manager company links error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Add new company link
  app.post("/api/property-manager/company-links", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { companyCode } = req.body;
      
      if (!companyCode || typeof companyCode !== 'string' || companyCode.length !== 10) {
        return res.status(400).json({ message: "Invalid company code format. Must be 10 characters." });
      }
      
      // Validate property manager code exists
      const company = await storage.getUserByPropertyManagerCode(companyCode);
      if (!company || company.role !== 'company') {
        return res.status(400).json({ message: "Invalid property manager code. Please check with the rope access company." });
      }
      
      // Check if link already exists
      const existingLinks = await storage.getPropertyManagerCompanyLinks(req.session.userId!);
      if (existingLinks.some(link => link.companyCode === companyCode)) {
        return res.status(400).json({ message: "You are already linked to this company." });
      }
      
      // Create the link
      const link = await storage.addPropertyManagerCompanyLink({
        propertyManagerId: req.session.userId!,
        companyCode,
        companyId: company.id,
      });
      
      res.json({ 
        link: {
          ...link,
          companyName: company.companyName,
        }
      });
    } catch (error) {
      console.error("Add property manager company link error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Remove company link
  app.delete("/api/property-manager/company-links/:id", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      await storage.removePropertyManagerCompanyLink(id, req.session.userId!);
      
      res.json({ message: "Company link removed successfully" });
    } catch (error) {
      console.error("Remove property manager company link error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get vendor summaries (My Vendors interface)
  app.get("/api/property-managers/me/vendors", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const vendorSummaries = await storage.getPropertyManagerVendorSummaries(req.session.userId!);
      console.log(`[PM Vendors] Fetched ${vendorSummaries.length} vendors for property manager ${req.session.userId}`);
      
      // Fetch CSR data for each vendor in parallel
      const vendorsWithCSR = await Promise.all(
        vendorSummaries.map(async (vendor) => {
          try {
            const csrData = await calculateCompanyCSR(vendor.id, storage, true);
            console.log(`[PM Vendors] CSR for vendor ${vendor.companyName}: ${csrData.csrRating}% (${csrData.csrLabel})`);
            return {
              ...vendor,
              csrRating: csrData.csrRating,
              csrLabel: csrData.csrLabel,
              csrColor: csrData.csrColor,
            };
          } catch (error) {
            console.error(`[PM Vendors] Failed to calculate CSR for vendor ${vendor.id}:`, error);
            return {
              ...vendor,
              csrRating: null,
              csrLabel: null,
              csrColor: null,
            };
          }
        })
      );
      
      console.log(`[PM Vendors] Returning vendors with CSR:`, vendorsWithCSR.map(v => ({ name: v.companyName, csrRating: v.csrRating })));
      res.json({ vendors: vendorsWithCSR });
    } catch (error) {
      console.error("Get property manager vendor summaries error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get buildings for map view
  app.get("/api/property-managers/me/buildings-map", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const buildings = await storage.getPropertyManagerBuildingsForMap(req.session.userId!);
      res.json({ buildings });
    } catch (error) {
      console.error("Get property manager buildings for map error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Add new vendor using company code
  app.post("/api/property-managers/vendors", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { companyCode } = req.body;
      
      if (!companyCode || typeof companyCode !== 'string' || companyCode.length !== 10) {
        return res.status(400).json({ message: "Invalid company code format. Must be 10 characters." });
      }
      
      const link = await storage.addPropertyManagerVendor(req.session.userId!, companyCode);
      
      const vendorSummaries = await storage.getPropertyManagerVendorSummaries(req.session.userId!);
      const addedVendor = vendorSummaries.find(v => v.id === link.companyId);
      
      res.json({ 
        link,
        vendor: addedVendor,
        message: "Vendor added successfully"
      });
    } catch (error: any) {
      console.error("Add property manager vendor error:", error);
      if (error.message?.includes('Invalid company code')) {
        return res.status(400).json({ message: error.message });
      }
      if (error.message?.includes('already linked')) {
        return res.status(400).json({ message: "You are already linked to this company." });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Update strata number for a vendor link
  app.patch("/api/property-managers/vendors/:linkId", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const { strataNumber } = req.body;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Validate strata number (required, 1-100 chars)
      if (!strataNumber || typeof strataNumber !== 'string' || strataNumber.trim() === '') {
        return res.status(400).json({ message: "Strata number is required and cannot be empty." });
      }
      
      if (strataNumber.length > 100) {
        return res.status(400).json({ message: "Strata number cannot exceed 100 characters." });
      }
      
      // Normalize strata number before saving (uppercase, no whitespace)
      const normalizeStrata = (strata: string): string => {
        return strata.toUpperCase().replace(/\s+/g, '');
      };
      
      const normalizedStrata = normalizeStrata(strataNumber);
      const updatedLink = await storage.updatePropertyManagerStrataNumber(linkId, normalizedStrata);
      
      res.json({ 
        link: updatedLink,
        message: "Strata number updated successfully"
      });
    } catch (error: any) {
      console.error("Update strata number error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Remove a vendor link
  app.delete("/api/property-managers/vendors/:linkId", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Remove the link
      await storage.removePropertyManagerCompanyLink(linkId, propertyManagerId);
      
      res.json({ 
        message: "Vendor removed successfully"
      });
    } catch (error: any) {
      console.error("Remove vendor link error:", error);
      res.status(500).json({ message: "Failed to remove vendor. Please try again." });
    }
  });

  // Property Manager: Get projects filtered by company and strata number
  app.get("/api/property-managers/vendors/:linkId/projects", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Require strata number to be set before fetching projects
      if (!ownedLink.strataNumber) {
        return res.status(400).json({ message: "Strata number required. Please set your strata/building number first." });
      }
      
      // Get filtered projects using companyId and normalized strata number
      const projects = await storage.getPropertyManagerFilteredProjects(
        ownedLink.companyId, 
        ownedLink.strataNumber
      );
      
      res.json({ projects });
    } catch (error: any) {
      console.error("Get filtered projects error:", error);
      if (error.message?.includes('not found')) {
        return res.status(404).json({ message: "Vendor link not found" });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get project details with complaints and documents
  app.get("/api/property-managers/vendors/:linkId/projects/:projectId", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId, projectId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Get project details - PM can view any project from connected vendor
      const details = await storage.getPropertyManagerProjectDetails(
        projectId, 
        ownedLink.companyId
      );
      
      res.json(details);
    } catch (error: any) {
      console.error("Get project details error:", error);
      if (error.message?.includes('not found') || error.message?.includes('access denied')) {
        return res.status(404).json({ message: error.message });
      }
      if (error.message?.includes('Strata number required')) {
        return res.status(400).json({ message: error.message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Update account settings
  app.patch("/api/property-managers/me/account", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      
      // Validate request body using Zod schema
      const validationResult = updatePropertyManagerAccountSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ 
          message: "Validation failed", 
          errors: validationResult.error.errors 
        });
      }
      
      const { name, email, propertyManagerPhoneNumber, propertyManagerSmsOptIn, propertyManagementCompany, currentPassword, newPassword } = validationResult.data;
      
      // Get current property manager data
      const currentUser = await storage.getUserById(propertyManagerId);
      if (!currentUser) {
        return res.status(404).json({ message: "Property manager not found" });
      }
      
      // Handle password change if requested
      if (newPassword) {
        // Verify current password
        const isPasswordValid = await bcrypt.compare(currentPassword!, currentUser.passwordHash);
        if (!isPasswordValid) {
          return res.status(401).json({ message: "Current password is incorrect" });
        }
        
        // Hash and update new password
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        await storage.updateUserPassword(propertyManagerId, hashedPassword);
      }
      
      // Update email if changed
      if (email && email !== currentUser.email) {
        // Check if email is already in use by another user
        const existingUser = await storage.getUserByEmail(email);
        if (existingUser && existingUser.id !== propertyManagerId) {
          return res.status(400).json({ message: "Email address is already in use" });
        }
        
        await storage.updateUserEmail(propertyManagerId, email);
      }
      
      // Update name if changed
      if (name && name !== currentUser.name) {
        await storage.updateUserName(propertyManagerId, name);
      }
      
      // Update phone number if provided (can be empty to clear it)
      if (propertyManagerPhoneNumber !== undefined) {
        await db.update(users)
          .set({ propertyManagerPhoneNumber: propertyManagerPhoneNumber || null })
          .where(eq(users.id, propertyManagerId));
      }
      
      // Update property management company if provided
      if (propertyManagementCompany !== undefined) {
        await db.update(users)
          .set({ propertyManagementCompany: propertyManagementCompany || null })
          .where(eq(users.id, propertyManagerId));
      }
      
      // Update SMS opt-in if provided
      if (propertyManagerSmsOptIn !== undefined) {
        await db.update(users)
          .set({ propertyManagerSmsOptIn })
          .where(eq(users.id, propertyManagerId));
      }
      
      // Sync property manager profile changes to linked client records
      // This ensures companies see up-to-date PM information
      try {
        const pmLinks = await db.select()
          .from(propertyManagerCompanyLinks)
          .where(eq(propertyManagerCompanyLinks.propertyManagerId, propertyManagerId));
        
        if (pmLinks.length > 0) {
          // Get updated PM data
          const updatedPM = await storage.getUserById(propertyManagerId);
          if (updatedPM) {
            // Parse name into firstName and lastName
            const nameParts = (updatedPM.name || '').trim().split(' ');
            const firstName = nameParts[0] || '';
            const lastName = nameParts.slice(1).join(' ') || '';
            
            // Update client records in each linked company
            // Match by strata number (building) since email may be empty
            for (const link of pmLinks) {
              if (!link.companyId) continue;
              
              // Find clients in this company that have this strata number in their lmsNumbers
              // or match by email if available
              const strataNumber = link.strataNumber;
              
              // Get all clients in this company
              const companyClients = await db.select()
                .from(clients)
                .where(eq(clients.companyId, link.companyId));
              
              // Find clients that match by email OR by strata number in lmsNumbers
              for (const client of companyClients) {
                const matchesByEmail = client.email && client.email.toLowerCase() === updatedPM.email?.toLowerCase();
                const lmsNumbers = client.lmsNumbers as Array<{ number: string }> | null;
                const matchesByStrata = strataNumber && lmsNumbers?.some(
                  (lms) => lms.number?.toUpperCase() === strataNumber.toUpperCase()
                );
                
                if (matchesByEmail || matchesByStrata) {
                  // Build update object with only non-empty values
                  const updateData: Record<string, any> = { updatedAt: new Date() };
                  if (firstName) updateData.firstName = firstName;
                  if (lastName) updateData.lastName = lastName;
                  if (updatedPM.propertyManagementCompany) updateData.company = updatedPM.propertyManagementCompany;
                  if (updatedPM.propertyManagerPhoneNumber) updateData.phoneNumber = updatedPM.propertyManagerPhoneNumber;
                  // Also sync email to ensure future syncs work by email
                  if (updatedPM.email && !client.email) updateData.email = updatedPM.email;
                  
                  await db.update(clients)
                    .set(updateData)
                    .where(eq(clients.id, client.id));
                  
                  console.log(`[PM Sync] Updated client ${client.id} (${client.firstName} ${client.lastName}) with PM data`);
                }
              }
            }
            console.log(`[PM Sync] Completed sync for PM ${updatedPM.email} across ${pmLinks.length} linked companies`);
          }
        }
      } catch (syncError) {
        // Non-blocking - log but don't fail the request
        console.error("[PM Sync] Error syncing PM profile to client records:", syncError);
      }
      
      res.json({ message: "Account settings updated successfully" });
    } catch (error) {
      console.error("Update property manager account error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get all quotes sent to them
  app.get("/api/property-managers/me/quotes", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      
      // Get all quotes where this property manager is the recipient
      const allQuotes = await db.select()
        .from(quotes)
        .where(eq(quotes.recipientPropertyManagerId, propertyManagerId))
        .orderBy(sql`${quotes.createdAt} DESC`);
      
      // Enrich quotes with company names and services
      const enrichedQuotes = await Promise.all(allQuotes.map(async (quote) => {
        const company = await storage.getUserById(quote.companyId);
        const services = await db.select().from(quoteServices).where(eq(quoteServices.quoteId, quote.id));
        const grandTotal = services.reduce((sum, s) => sum + Number(s.totalCost || 0), 0);
        
        return {
          id: quote.id,
          quoteNumber: quote.quoteNumber,
          buildingName: quote.buildingName,
          strataPlanNumber: quote.strataPlanNumber,
          buildingAddress: quote.buildingAddress,
          status: quote.status,
          pipelineStage: quote.pipelineStage,
          createdAt: quote.createdAt,
          companyName: company?.companyName || "Rope Access Company",
          grandTotal,
          serviceCount: services.length
        };
      }));
      
      res.json({ quotes: enrichedQuotes });
    } catch (error) {
      console.error("Get property manager quotes error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get a specific quote by ID (if they are the recipient)
  app.get("/api/property-managers/quotes/:quoteId", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      
      // Get the quote with services
      const quote = await storage.getQuoteById(quoteId);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      // Verify this property manager is the recipient of the quote
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Track first view: update viewedAt, collaborationStatus, and pipelineStage
      if (!quote.viewedAt) {
        await storage.updateQuote(quoteId, {
          viewedAt: new Date(),
          collaborationStatus: 'viewed',
          pipelineStage: 'review',
          stageUpdatedAt: new Date()
        } as any);
        
        console.log(`[Quote] Property manager ${propertyManagerId} viewed quote ${quote.quoteNumber} - moved to 'In Review'`);
        
        // Log the view event in quote history
        await db.insert(quoteHistory).values({
          quoteId: quote.id,
          companyId: quote.companyId,
          eventType: 'viewed',
          actorUserId: propertyManagerId,
          actorName: 'Property Manager',
          notes: `Quote first viewed by property manager`,
        });
      }
      
      // Get the company info for display
      const company = await storage.getUserById(quote.companyId);
      const companyName = company?.companyName || "Rope Access Company";
      
      // Calculate grand total
      const grandTotal = quote.services.reduce((sum, s) => sum + Number(s.totalCost || 0), 0);
      
      res.json({
        quote: {
          id: quote.id,
          quoteNumber: quote.quoteNumber,
          buildingName: quote.buildingName,
          strataPlanNumber: quote.strataPlanNumber,
          buildingAddress: quote.buildingAddress,
          floorCount: quote.floorCount,
          status: quote.status,
          pipelineStage: quote.pipelineStage,
          collaborationStatus: quote.collaborationStatus,
          createdAt: quote.createdAt,
          companyName,
          services: quote.services.map(s => ({
            id: s.id,
            serviceType: s.serviceType,
            description: s.description,
            totalCost: s.totalCost
          })),
          grandTotal
        }
      });
    } catch (error) {
      console.error("Get property manager quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get quote messages (collaboration thread)
  app.get("/api/property-managers/quotes/:quoteId/messages", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      
      // Verify this property manager has access to this quote
      const quote = await storage.getQuoteById(quoteId);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Get all messages for this quote
      const messages = await storage.getQuoteMessages(quoteId);
      
      // Mark messages from company as read
      await storage.markQuoteMessagesAsRead(quoteId, 'property_manager');
      
      res.json({ messages });
    } catch (error) {
      console.error("Get quote messages error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Send a message on a quote
  app.post("/api/property-managers/quotes/:quoteId/messages", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      const { content } = req.body;
      
      if (!content || typeof content !== 'string' || content.trim().length === 0) {
        return res.status(400).json({ message: "Message content is required" });
      }
      
      // Verify this property manager has access to this quote
      const quote = await storage.getQuoteById(quoteId);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Get property manager info
      const propertyManager = await storage.getUserById(propertyManagerId);
      const senderName = propertyManager?.name || "Property Manager";
      
      // Create the message
      const message = await storage.createQuoteMessage({
        quoteId,
        senderUserId: propertyManagerId,
        senderType: 'property_manager',
        senderName,
        messageType: 'message',
        content: content.trim(),
      });
      
      // Update quote collaboration status if not already in negotiation
      if (quote.collaborationStatus === 'sent' || quote.collaborationStatus === 'viewed') {
        await storage.updateQuoteCollaborationStatus(quoteId, 'negotiation');
      }
      
      res.json({ message, success: true });
    } catch (error) {
      console.error("Send quote message error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Accept a quote
  app.post("/api/property-managers/quotes/:quoteId/accept", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      
      // Verify this property manager has access to this quote
      const quote = await storage.getQuoteById(quoteId);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Check quote is in a valid state for acceptance
      if (quote.collaborationStatus === 'accepted') {
        return res.status(400).json({ message: "Quote has already been accepted" });
      }
      if (quote.collaborationStatus === 'declined') {
        return res.status(400).json({ message: "Quote has been declined and cannot be accepted" });
      }
      
      // Get property manager info
      const propertyManager = await storage.getUserById(propertyManagerId);
      const senderName = propertyManager?.name || "Property Manager";
      
      // Create accept message
      await storage.createQuoteMessage({
        quoteId,
        senderUserId: propertyManagerId,
        senderType: 'property_manager',
        senderName,
        messageType: 'accept',
        content: 'Quote accepted',
      });
      
      // Update quote collaboration status
      await storage.updateQuoteCollaborationStatus(quoteId, 'accepted');
      
      // Update status and pipeline stage to approved/closed
      await db.update(quotes)
        .set({ status: 'closed', pipelineStage: 'approved', stageUpdatedAt: new Date() })
        .where(eq(quotes.id, quoteId));
      
      // Notify company via WebSocket
      wsHub.notifyQuoteAccepted(quote.companyId, {
        id: quote.id,
        quoteNumber: quote.quoteNumber,
        buildingName: quote.buildingName,
        strataPlanNumber: quote.strataPlanNumber,
        propertyManagerName: senderName,
      });
      
      res.json({ success: true, message: "Quote accepted successfully" });
    } catch (error) {
      console.error("Accept quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Decline a quote
  app.post("/api/property-managers/quotes/:quoteId/decline", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      const { reason } = req.body;
      
      // Verify this property manager has access to this quote
      const quote = await storage.getQuoteById(quoteId);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Check quote is in a valid state
      if (quote.collaborationStatus === 'declined') {
        return res.status(400).json({ message: "Quote has already been declined" });
      }
      if (quote.collaborationStatus === 'accepted') {
        return res.status(400).json({ message: "Quote has been accepted and cannot be declined" });
      }
      
      // Get property manager info
      const propertyManager = await storage.getUserById(propertyManagerId);
      const senderName = propertyManager?.name || "Property Manager";
      
      // Create decline message
      await storage.createQuoteMessage({
        quoteId,
        senderUserId: propertyManagerId,
        senderType: 'property_manager',
        senderName,
        messageType: 'decline',
        content: reason || 'Quote declined',
      });
      
      // Update quote collaboration status
      await storage.updateQuoteCollaborationStatus(quoteId, 'declined');
      
      // Update status and pipeline stage to lost/closed
      await db.update(quotes)
        .set({ status: 'closed', pipelineStage: 'lost', stageUpdatedAt: new Date() })
        .where(eq(quotes.id, quoteId));
      
      // Notify company via WebSocket
      wsHub.notifyQuoteDeclined(quote.companyId, {
        id: quote.id,
        quoteNumber: quote.quoteNumber,
        buildingName: quote.buildingName,
        strataPlanNumber: quote.strataPlanNumber,
        propertyManagerName: senderName,
        reason: reason || null,
      });
      
      res.json({ success: true, message: "Quote declined" });
    } catch (error) {
      console.error("Decline quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Submit a counter-offer
  app.post("/api/property-managers/quotes/:quoteId/counter-offer", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const propertyManagerId = req.session.userId!;
      const { quoteId } = req.params;
      const { counterOfferAmount, notes } = req.body;
      
      if (!counterOfferAmount || isNaN(Number(counterOfferAmount))) {
        return res.status(400).json({ message: "Valid counter-offer amount is required" });
      }
      
      // Verify this property manager has access to this quote
      const quote = await storage.getQuoteById(quoteId);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      if (quote.recipientPropertyManagerId !== propertyManagerId) {
        return res.status(403).json({ message: "You do not have access to this quote" });
      }
      
      // Check quote is in a valid state
      if (quote.collaborationStatus === 'accepted' || quote.collaborationStatus === 'declined') {
        return res.status(400).json({ message: "Cannot submit counter-offer on a closed quote" });
      }
      
      // Get property manager info
      const propertyManager = await storage.getUserById(propertyManagerId);
      const senderName = propertyManager?.name || "Property Manager";
      
      // Create counter-offer message
      const message = await storage.createQuoteMessage({
        quoteId,
        senderUserId: propertyManagerId,
        senderType: 'property_manager',
        senderName,
        messageType: 'counter_offer',
        content: notes || `Counter-offer submitted: $${Number(counterOfferAmount).toLocaleString()}`,
        counterOfferAmount: String(counterOfferAmount),
        counterOfferNotes: notes,
      });
      
      // Update quote collaboration status to negotiation
      await storage.updateQuoteCollaborationStatus(quoteId, 'negotiation');
      
      // Update quote pipeline stage to negotiation so it appears in the pipeline
      await storage.updateQuote(quoteId, { pipelineStage: 'negotiation' } as any);
      
      // Send real-time WebSocket notification to company
      wsHub.notifyQuoteCounterOffer(quote.companyId, {
        id: quote.id,
        quoteNumber: quote.quoteNumber,
        buildingName: quote.buildingName,
        strataPlanNumber: quote.strataPlanNumber,
        propertyManagerName: senderName,
        counterOfferAmount: String(counterOfferAmount),
      });
      
      console.log(`[Counter-Offer] PM ${senderName} submitted counter-offer of $${counterOfferAmount} for quote ${quote.quoteNumber}`);
      
      res.json({ message, success: true });
    } catch (error) {
      console.error("Counter-offer error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // SuperUser: Get all companies
  app.get("/api/superuser/companies", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only allow superuser to access this endpoint
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      // Fetch all users with company role
      const companies = await storage.getAllCompanies();
      console.log(`[SuperUser] Found ${companies.length} companies`);
      
      // For each company, get the most recent activity from any user (owner + employees)
      const companiesWithActivity = await Promise.all(companies.map(async (company) => {
        try {
          const { passwordHash, ...companyData } = company;
          
          // Query for the most recent activity across company owner and all employees
          const activityResult = await db.select({
            lastActivity: sql<Date>`MAX(last_activity_at)`
          })
          .from(users)
          .where(
            sql`${users.id} = ${company.id} OR ${users.companyId} = ${company.id}`
          );
          
          const lastCompanyActivity = activityResult[0]?.lastActivity || company.lastActivityAt;
          
          return {
            ...companyData,
            lastCompanyActivity,
          };
        } catch (err) {
          console.error(`[SuperUser] Error processing company ${company.id}:`, err);
          const { passwordHash, ...companyData } = company;
          return {
            ...companyData,
            lastCompanyActivity: company.lastActivityAt,
          };
        }
      }));

      res.json({ companies: companiesWithActivity });
    } catch (error) {
      console.error("[SuperUser] Get all companies error:", error);
      res.status(500).json({ message: "Internal server error", error: String(error) });
    }
  });

  // SuperUser: Get single company by ID
  app.get("/api/superuser/companies/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only allow superuser to access this endpoint
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const company = await storage.getUserById(req.params.id);
      
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Return company without sensitive password hash
      const { passwordHash,  ...companyData } = company;
      res.json({ company: companyData });
    } catch (error) {
      console.error("Get company error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get company analytics for SuperUser
  app.get("/api/superuser/companies/:id/analytics", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const companyId = req.params.id;
      const company = await storage.getUserById(companyId);
      
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Fetch all data for analytics
      const [projects, employees, clients, quotes, workSessions, harnessInspections, toolboxMeetings] = await Promise.all([
        storage.getProjectsByCompany(companyId),
        storage.getAllEmployees(companyId),
        storage.getClientsByCompany(companyId),
        storage.getQuotesByCompany(companyId),
        storage.getWorkSessionsByCompany(companyId),
        storage.getHarnessInspectionsByCompany(companyId),
        storage.getToolboxMeetingsByCompany(companyId),
      ]);

      // Calculate project stats
      const activeProjects = projects.filter(p => p.status === 'active').length;
      const completedProjects = projects.filter(p => p.status === 'completed').length;
      const pendingProjects = projects.filter(p => p.status === 'pending').length;

      // Calculate employee stats
      const activeEmployees = employees.filter(e => !e.terminatedDate).length;
      const terminatedEmployees = employees.filter(e => e.terminatedDate).length;

      // Calculate quote stats
      const totalQuoteValue = quotes.reduce((sum, q) => sum + parseFloat(q.totalAmount || '0'), 0);
      const acceptedQuotes = quotes.filter(q => q.status === 'accepted');
      const acceptedQuoteValue = acceptedQuotes.reduce((sum, q) => sum + parseFloat(q.totalAmount || '0'), 0);
      const pendingQuotes = quotes.filter(q => q.status === 'pending' || q.status === 'sent');

      // Calculate work session stats
      const completedSessions = workSessions.filter(s => s.status === 'completed');
      const totalBillableHours = completedSessions.reduce((sum, s) => {
        if (s.totalHours && s.sessionType === 'billable') {
          return sum + parseFloat(s.totalHours);
        }
        return sum;
      }, 0);
      const totalNonBillableHours = completedSessions.reduce((sum, s) => {
        if (s.totalHours && s.sessionType !== 'billable') {
          return sum + parseFloat(s.totalHours);
        }
        return sum;
      }, 0);

      // Calculate safety stats
      const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const recentInspections = harnessInspections.filter(h => new Date(h.inspectionDate) >= last30Days).length;
      const recentMeetings = toolboxMeetings.filter(m => new Date(m.meetingDate) >= last30Days).length;

      res.json({
        analytics: {
          projects: {
            total: projects.length,
            active: activeProjects,
            completed: completedProjects,
            pending: pendingProjects,
          },
          employees: {
            total: employees.length,
            active: activeEmployees,
            terminated: terminatedEmployees,
          },
          clients: {
            total: clients.length,
          },
          quotes: {
            total: quotes.length,
            totalValue: totalQuoteValue,
            accepted: acceptedQuotes.length,
            acceptedValue: acceptedQuoteValue,
            pending: pendingQuotes.length,
          },
          workSessions: {
            total: workSessions.length,
            completed: completedSessions.length,
            billableHours: totalBillableHours,
            nonBillableHours: totalNonBillableHours,
          },
          safety: {
            harnessInspections: harnessInspections.length,
            toolboxMeetings: toolboxMeetings.length,
            recentInspections,
            recentMeetings,
          },
        },
      });
    } catch (error) {
      console.error("Get company analytics error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get employee data for a specific company (SuperUser only)
  app.get("/api/superuser/companies/:id/employees", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only allow superuser to access this endpoint
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const companyId = req.params.id;
      const company = await storage.getUserById(companyId);
      
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Get all employees for this company (including terminated)
      const employees = await storage.getAllEmployees(companyId);
      
      // Calculate seat usage using new subscription system
      const limitsCheck = await checkSubscriptionLimits(companyId);
      const activeEmployeeCount = employees.filter(emp => !emp.terminatedDate).length;
      const tier = company.subscriptionTier || 'none';
      const paidSeats = company.additionalSeatsCount || 0;
      const giftedSeats = company.giftedSeatsCount || 0;
      const totalAdditionalSeats = paidSeats + giftedSeats;
      // baseSeatLimit is always 2 (the free included seats), not derived from seatLimit
      const baseSeatLimit = 2;
      const seatLimit = limitsCheck.limits.maxSeats;
      
      res.json({ 
        seatInfo: {
          tier,
          seatLimit,
          baseSeatLimit,
          paidSeats,
          giftedSeats,
          additionalSeats: totalAdditionalSeats,
          seatsUsed: activeEmployeeCount,
          seatsAvailable: seatLimit === -1 ? -1 : Math.max(0, seatLimit - activeEmployeeCount),
          atSeatLimit: seatLimit === 0 || (seatLimit > 0 && activeEmployeeCount >= seatLimit)
        }
      });
    } catch (error) {
      console.error("Get company employees error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // SuperUser: Gift a free company account
  app.post("/api/superuser/gift-company", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only allow superuser to access this endpoint
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { companyName, email, password, tier, licenseKey } = req.body;

      console.log('[Gift-Company] Creating gifted account:', { companyName, email, tier, licenseKey });

      // Validation
      if (!companyName || !email || !password || !tier || !licenseKey) {
        return res.status(400).json({ message: "Missing required fields: companyName, email, password, tier, licenseKey" });
      }

      // Validate tier
      const validTiers = ['basic', 'starter', 'premium', 'enterprise', 'onropepro'];
      if (!validTiers.includes(tier)) {
        return res.status(400).json({ message: "Invalid tier. Must be one of: basic, starter, premium, enterprise, onropepro" });
      }

      // Validate license key format (GIFT-XXXXX-XXXXX-XXXXX-[1-4])
      const expectedTierSuffix = tier === 'basic' ? '1' : tier === 'starter' ? '2' : tier === 'premium' ? '3' : tier === 'enterprise' ? '4' : 'P';
      const licenseKeyPattern = new RegExp(`^GIFT-[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}-${expectedTierSuffix}$`);
      if (!licenseKeyPattern.test(licenseKey)) {
        return res.status(400).json({ message: "Invalid license key format or tier mismatch" });
      }

      // Get tier configuration
      const tierConfig = TIER_CONFIG[tier as TierName];

      // Use the provided license key from frontend
      const giftLicenseKey = licenseKey;
      const timestamp = Date.now();

      // Hash password before transaction
      const passwordHash = await bcrypt.hash(password, 10);

      // Use transaction for atomic user and license creation
      const result = await db.transaction(async (tx) => {
        // Check if user already exists (within transaction)
        const existingUserByEmail = await tx.query.users.findFirst({
          where: eq(users.email, email),
        });

        if (existingUserByEmail) {
          throw new Error("Email already registered");
        }

        const existingUserByCompanyName = await tx.query.users.findFirst({
          where: eq(users.companyName, companyName),
        });

        if (existingUserByCompanyName) {
          throw new Error("Company name already taken");
        }

        // Create user with subscription data (active status since it's a gift)
        const [user] = await tx.insert(users).values({
          companyName,
          email,
          passwordHash,
          role: 'company',
          stripeCustomerId: `gift_${timestamp}`, // Placeholder for gift accounts
          stripeSubscriptionId: `gift_sub_${timestamp}`, // Placeholder for gift accounts
          subscriptionTier: tier,
          subscriptionStatus: 'active', // Gift accounts are immediately active
          licenseKey: giftLicenseKey,
        }).returning();

        if (!user) {
          throw new Error("Failed to create user");
        }

        console.log('[Gift-Company] User created:', user.id);

        // Store gift license key in database (within same transaction)
        await tx.insert(licenseKeys).values({
          licenseKey: giftLicenseKey,
          stripeSessionId: `gift_session_${timestamp}`, // Placeholder for gift
          stripeCustomerId: `gift_${timestamp}`,
          stripeSubscriptionId: `gift_sub_${timestamp}`,
          tier,
          currency: 'usd',
          used: true,
          usedByUserId: user.id,
          usedAt: new Date(),
        });

        console.log('[Gift-Company] Gift license key created:', giftLicenseKey);

        return user;
      });

      // Create default payroll config (outside transaction - not critical)
      try {
        await storage.createPayPeriodConfig({
          companyId: result.id,
          periodType: 'semi-monthly',
          firstPayDay: 1,
          secondPayDay: 15,
        });
        await storage.generatePayPeriods(result.id, 6);
        console.log('[Gift-Company] Payroll config created');
      } catch (error) {
        console.error('[Gift-Company] Payroll setup error:', error);
        // Don't fail if payroll setup fails - account is already created
      }

      console.log('[Gift-Company] Gifted account created successfully:', email);

      // Return user without password
      const { passwordHash: _, ...userWithoutPassword } = result;
      res.json({ 
        success: true, 
        message: `Company "${companyName}" created with ${tierConfig.name} tier access`,
        user: userWithoutPassword,
        licenseKey: giftLicenseKey,
        tier: tierConfig.name,
        maxProjects: tierConfig.maxProjects,
        maxSeats: tierConfig.maxSeats,
      });
    } catch (error: any) {
      console.error('[Gift-Company] Error:', error);
      const message = error.message || "Failed to create gifted company account";
      res.status(400).json({ message });
    }
  });

  // ==================== STAFF ACCOUNTS (Internal Platform Management) ====================
  
  // Helper to check if user is superuser or has specific staff permission
  const requireSuperuserOrStaffPermission = (permission: string) => {
    return async (req: Request, res: Response, next: Function) => {
      if (req.session.userId === 'superuser') {
        return next();
      }
      
      if (req.session.role === 'staff') {
        const permissions = req.session.staffPermissions || [];
        if (permissions.includes(permission)) {
          return next();
        }
      }
      
      return res.status(403).json({ message: "Access denied. Insufficient permissions." });
    };
  };

  // Inline helper to check superuser or staff permission (returns true if authorized)
  // Get all staff accounts (superuser or staff with manage_staff_accounts permission)
  app.get("/api/staff-accounts", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only superuser or staff with manage_staff_accounts permission
      if (!isSuperuserOrHasPermission(req, 'manage_staff_accounts')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('manage_staff_accounts')) {
          return res.status(403).json({ message: "Access denied. Insufficient permissions." });
        }
      }
      
      const accounts = await storage.getAllStaffAccounts();
      
      // Remove password hashes from response
      const safeAccounts = accounts.map(({ passwordHash, ...rest }) => rest);
      
      res.json({ staffAccounts: safeAccounts });
    } catch (error: any) {
      console.error('[Staff-Accounts] Get all error:', error);
      res.status(500).json({ message: error.message || "Failed to get staff accounts" });
    }
  });
  
  // Get single staff account
  app.get("/api/staff-accounts/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'manage_staff_accounts')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('manage_staff_accounts')) {
          return res.status(403).json({ message: "Access denied. Insufficient permissions." });
        }
      }
      
      const account = await storage.getStaffAccountById(req.params.id);
      if (!account) {
        return res.status(404).json({ message: "Staff account not found" });
      }
      
      const { passwordHash, ...safeAccount } = account;
      res.json({ staffAccount: safeAccount });
    } catch (error: any) {
      console.error('[Staff-Accounts] Get by ID error:', error);
      res.status(500).json({ message: error.message || "Failed to get staff account" });
    }
  });
  
  // Create staff account
  app.post("/api/staff-accounts", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'manage_staff_accounts')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('manage_staff_accounts')) {
          return res.status(403).json({ message: "Access denied. Insufficient permissions." });
        }
      }
      
      const { firstName, lastName, email, password, permissions, isActive } = req.body;
      
      if (!firstName || !lastName || !email || !password) {
        return res.status(400).json({ message: "Missing required fields: firstName, lastName, email, password" });
      }
      
      // Check if email already exists
      const existing = await storage.getStaffAccountByEmail(email);
      if (existing) {
        return res.status(400).json({ message: "A staff account with this email already exists" });
      }
      
      // Validate permissions
      const validPermissions = [
        'view_dashboard', 'view_companies', 'view_technicians', 'view_buildings',
        'view_job_board', 'view_tasks', 'view_feature_requests', 'view_future_ideas',
        'view_metrics', 'view_goals', 'view_changelog', 'view_founder_resources',
        'manage_staff_accounts'
      ];
      
      const requestedPermissions = permissions || [];
      const invalidPermissions = requestedPermissions.filter((p: string) => !validPermissions.includes(p));
      if (invalidPermissions.length > 0) {
        return res.status(400).json({ message: `Invalid permissions: ${invalidPermissions.join(', ')}` });
      }
      
      const account = await storage.createStaffAccount({
        firstName,
        lastName,
        email,
        passwordHash: password, // Will be hashed in storage
        permissions: requestedPermissions,
        isActive: isActive !== false,
        createdBy: req.session.userId === 'superuser' ? 'superuser' : req.session.userId,
      });
      
      console.log(`[Staff-Accounts] Created account for ${email} by ${req.session.userId}`);
      
      const { passwordHash, ...safeAccount } = account;
      res.json({ success: true, message: "Staff account created", staffAccount: safeAccount });
    } catch (error: any) {
      console.error('[Staff-Accounts] Create error:', error);
      res.status(500).json({ message: error.message || "Failed to create staff account" });
    }
  });
  
  // Update staff account
  app.patch("/api/staff-accounts/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'manage_staff_accounts')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('manage_staff_accounts')) {
          return res.status(403).json({ message: "Access denied. Insufficient permissions." });
        }
      }
      
      const { firstName, lastName, email, password, permissions, isActive } = req.body;
      const updates: any = {};
      
      if (firstName !== undefined) updates.firstName = firstName;
      if (lastName !== undefined) updates.lastName = lastName;
      if (email !== undefined) updates.email = email;
      if (password !== undefined) updates.passwordHash = password; // Will be hashed in storage
      if (permissions !== undefined) updates.permissions = permissions;
      if (isActive !== undefined) updates.isActive = isActive;
      
      if (Object.keys(updates).length === 0) {
        return res.status(400).json({ message: "No updates provided" });
      }
      
      const account = await storage.updateStaffAccount(req.params.id, updates);
      if (!account) {
        return res.status(404).json({ message: "Staff account not found" });
      }
      
      console.log(`[Staff-Accounts] Updated account ${req.params.id} by ${req.session.userId}`);
      
      const { passwordHash, ...safeAccount } = account;
      res.json({ success: true, message: "Staff account updated", staffAccount: safeAccount });
    } catch (error: any) {
      console.error('[Staff-Accounts] Update error:', error);
      res.status(500).json({ message: error.message || "Failed to update staff account" });
    }
  });
  
  // Delete staff account
  app.delete("/api/staff-accounts/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'manage_staff_accounts')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('manage_staff_accounts')) {
          return res.status(403).json({ message: "Access denied. Insufficient permissions." });
        }
      }
      
      // Prevent deleting yourself
      if (req.session.role === 'staff' && req.session.userId === req.params.id) {
        return res.status(400).json({ message: "You cannot delete your own account" });
      }
      
      const deleted = await storage.deleteStaffAccount(req.params.id);
      if (!deleted) {
        return res.status(404).json({ message: "Staff account not found" });
      }
      
      console.log(`[Staff-Accounts] Deleted account ${req.params.id} by ${req.session.userId}`);
      
      res.json({ success: true, message: "Staff account deleted" });
    } catch (error: any) {
      console.error('[Staff-Accounts] Delete error:', error);
      res.status(500).json({ message: error.message || "Failed to delete staff account" });
    }
  });

  // ============================================
  // FOUNDER RESOURCES API
  // ============================================

  // Get all founder resources
  app.get("/api/founder-resources", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only superuser or staff with view_founder_resources permission
      if (!isSuperuserOrHasPermission(req, 'view_founder_resources')) {
        if (req.session.role !== 'staff' || !req.session.staffPermissions?.includes('view_founder_resources')) {
          return res.status(403).json({ message: "Access denied" });
        }
      }

      const resources = await db.select().from(founderResources).orderBy(founderResources.sortOrder);
      res.json({ resources });
    } catch (error: any) {
      console.error("Get founder resources error:", error);
      res.status(500).json({ message: error.message || "Failed to fetch founder resources" });
    }
  });

  // Add a founder resource
  app.post("/api/founder-resources", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only superuser can add resources
      if (!isSuperuserOrHasPermission(req, 'view_founder_resources')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { name, url, description, icon, category } = req.body;

      if (!name || !url) {
        return res.status(400).json({ message: "Name and URL are required" });
      }

      // Get max sort order to add at the end
      const maxOrder = await db.select({ max: sql<number>`COALESCE(MAX(sort_order), 0)` }).from(founderResources);
      const newOrder = (maxOrder[0]?.max || 0) + 1;

      const [resource] = await db.insert(founderResources).values({
        name,
        url,
        description: description || null,
        icon: icon || 'Link',
        category: category || 'tools',
        sortOrder: newOrder,
        createdBy: 'superuser',
      }).returning();

      res.status(201).json({ resource });
    } catch (error: any) {
      console.error("Create founder resource error:", error);
      res.status(500).json({ message: error.message || "Failed to create founder resource" });
    }
  });

  // Delete a founder resource
  app.delete("/api/founder-resources/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only superuser can delete resources
      if (!isSuperuserOrHasPermission(req, 'view_founder_resources')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });

  // Database Cost Tracking Endpoints
  // Get all database costs with period summaries
  app.get("/api/superuser/database-costs", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const costs = await db.select().from(databaseCosts).orderBy(desc(databaseCosts.date));
      
      // Calculate period summaries
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfWeek = new Date(now);
      startOfWeek.setDate(now.getDate() - now.getDay());
      startOfWeek.setHours(0, 0, 0, 0);
      const startOfDay = new Date(now);
      startOfDay.setHours(0, 0, 0, 0);
      
      let allTime = 0, thisYear = 0, thisMonth = 0, thisWeek = 0, today = 0;
      
      costs.forEach(cost => {
        const costDate = new Date(cost.date);
        allTime += cost.amount;
        if (costDate >= startOfYear) thisYear += cost.amount;
        if (costDate >= startOfMonth) thisMonth += cost.amount;
        if (costDate >= startOfWeek) thisWeek += cost.amount;
        if (costDate >= startOfDay) today += cost.amount;
      });
      
      res.json({
        costs,
        summary: {
          allTime: Math.round(allTime * 100) / 100,
          thisYear: Math.round(thisYear * 100) / 100,
          thisMonth: Math.round(thisMonth * 100) / 100,
          thisWeek: Math.round(thisWeek * 100) / 100,
          today: Math.round(today * 100) / 100,
        }
      });
    } catch (error) {
      console.error("Get database costs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Add a database cost entry
  app.post("/api/superuser/database-costs", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const parsed = insertDatabaseCostSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid data", errors: parsed.error.errors });
      }

      const [newCost] = await db.insert(databaseCosts).values({
        ...parsed.data,
        createdBy: 'superuser',
      }).returning();

      res.status(201).json({ cost: newCost });
    } catch (error) {
      console.error("Add database cost error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete a database cost entry
  app.delete("/api/superuser/database-costs/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const costId = req.params.id;
      await db.delete(databaseCosts).where(eq(databaseCosts.id, costId));
      res.json({ success: true });
    } catch (error) {
      console.error("Delete database cost error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

      }

      const resourceId = req.params.id;
      await db.delete(founderResources).where(eq(founderResources.id, resourceId));
      res.json({ success: true });
    } catch (error: any) {
      console.error("Delete founder resource error:", error);
      res.status(500).json({ message: error.message || "Failed to delete founder resource" });
    }
  });


  // SuperUser: Gift add-ons to an existing company
  app.post("/api/superuser/companies/:id/gift-addons", requireAuth, async (req: Request, res: Response) => {
    try {
      // Only allow superuser to access this endpoint
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const companyId = req.params.id;
      const { extraSeats, whiteLabel } = req.body;

      console.log('[Gift-Addons] Gifting add-ons to company:', { companyId, extraSeats, whiteLabel });

      // Validate inputs - ensure non-negative integers
      const parsedSeats = parseInt(extraSeats) || 0;
            const parsedWhiteLabel = whiteLabel === true;

      if (parsedSeats < 0) {
        return res.status(400).json({ message: "Add-on counts cannot be negative" });
      }

      if (parsedSeats === 0 && !parsedWhiteLabel) {
        return res.status(400).json({ message: "Please select at least one add-on to gift" });
      }

      // Fetch the company
      const company = await storage.getUserById(companyId);
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Build update object with validated values
      const updates: any = {};
      
      if (parsedSeats > 0) {
        // Gifted seats are stored separately and are free forever
        updates.giftedSeatsCount = (company.giftedSeatsCount || 0) + parsedSeats;
      }
      
if (parsedWhiteLabel && !company.whitelabelBrandingActive) {
        updates.whitelabelBrandingActive = true;
      }

      // Check if there's anything to update
      if (Object.keys(updates).length === 0) {
        return res.status(400).json({ message: "No new add-ons to gift (white label may already be active)" });
      }

      // Update the company in database
      await db.update(users)
        .set(updates)
        .where(eq(users.id, companyId));

      // Fetch updated company to confirm changes
      const updatedCompany = await storage.getUserById(companyId);

      console.log('[Gift-Addons] Add-ons gifted successfully:', updates);

      // Build descriptive message
      const giftedItems: string[] = [];
      if (parsedSeats > 0) giftedItems.push(`${parsedSeats} seat${parsedSeats > 1 ? 's' : ''}`);
      
      if (parsedWhiteLabel && !company.whitelabelBrandingActive) giftedItems.push('white-label branding');

      res.json({
        success: true,
        message: `Successfully gifted ${giftedItems.join(', ')} to ${company.companyName}`,
        company: {
          id: updatedCompany?.id,
          companyName: updatedCompany?.companyName,
          additionalSeatsCount: updatedCompany?.additionalSeatsCount,
          giftedSeatsCount: updatedCompany?.giftedSeatsCount,
                    whitelabelBrandingActive: updatedCompany?.whitelabelBrandingActive,
        },
        gifted: {
          seats: parsedSeats,
                    whiteLabel: parsedWhiteLabel && !company.whitelabelBrandingActive,
        },
      });
    } catch (error: any) {
      console.error('[Gift-Addons] Error:', error);
      res.status(500).json({ message: error.message || "Failed to gift add-ons" });
    }
  });

  /**
   * SuperUser: Remove legacy $19 seat items from a company's Stripe subscription
   * POST /api/superuser/companies/:id/remove-legacy-seats
   */
  app.post("/api/superuser/companies/:id/remove-legacy-seats", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;
      const company = await storage.getUserById(id);

      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      if (!company.stripeSubscriptionId) {
        return res.status(400).json({ message: "Company has no Stripe subscription" });
      }

      // Legacy seat price IDs
      const legacySeatPriceIds = [
        'price_1SWDH4BzDsOltscrMxt5u3ij',  // Old USD seat price ($19/month)
        'price_1SZG7KBzDsOltscrAcGW9Vuw',  // Old CAD seat price ($19/month)
      ];

      // Current seat price IDs
      const addonConfig = ADDON_CONFIG.extra_seats;
      const currentSeatPriceIds = [addonConfig.priceIdUSD, addonConfig.priceIdCAD];

      console.log(`[SuperUser] Removing legacy seats for company ${company.companyName} (${id})`);

      // Get current subscription
      const subscription = await stripe.subscriptions.retrieve(company.stripeSubscriptionId);

      // Find legacy seat items
      const legacyItems = subscription.items.data.filter(item => 
        legacySeatPriceIds.includes(item.price.id)
      );

      if (legacyItems.length === 0) {
        return res.status(400).json({ message: "No legacy seats found on this subscription" });
      }

      // Count legacy seats being removed
      let legacySeatsRemoved = 0;
      for (const item of legacyItems) {
        legacySeatsRemoved += item.quantity || 0;
        console.log(`[SuperUser] Removing legacy seat item: ${item.id}, price: ${item.price.id}, quantity: ${item.quantity}`);
        await stripe.subscriptionItems.del(item.id, {
          proration_behavior: 'create_prorations',  // Give credit for unused time
        });
      }

      // Re-fetch subscription to get accurate count of remaining seats
      const verifySubscription = await stripe.subscriptions.retrieve(company.stripeSubscriptionId);
      let remainingSeats = 0;
      for (const item of verifySubscription.items.data) {
        if (currentSeatPriceIds.includes(item.price.id)) {
          remainingSeats += item.quantity || 0;
        }
      }

      // Update database to match Stripe
      await storage.updateUser(company.id, {
        additionalSeatsCount: remainingSeats,
      });

      console.log(`[SuperUser] Legacy seats removed. Removed: ${legacySeatsRemoved}, Remaining: ${remainingSeats}`);
      res.json({
        success: true,
        message: `Removed ${legacySeatsRemoved} legacy seat(s) from ${company.companyName}`,
        legacySeatsRemoved,
        remainingSeats,
        companyId: company.id,
        companyName: company.companyName,
      });
    } catch (error: any) {
      console.error('[SuperUser] Remove legacy seats error:', error);
      res.status(500).json({ message: error.message || "Failed to remove legacy seats" });
    }
  });

  // ==================== SuperUser Platform Metrics Endpoints ====================

  // SuperUser: Get MRR metrics summary
  app.get("/api/superuser/metrics/mrr", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const mrrMetrics = await storage.calculateLiveMrrMetrics();
      
      // Calculate ARR
      const arr = mrrMetrics.totalMrr * 12;
      
      res.json({
        mrr: mrrMetrics.totalMrr,
        arr,
        byTier: mrrMetrics.byTier,
        byAddon: mrrMetrics.byAddon,
        customerCounts: mrrMetrics.customerCounts,
      });
    } catch (error) {
      console.error('[SuperUser] Get MRR metrics error:', error);
      res.status(500).json({ message: "Failed to fetch MRR metrics" });
    }
  });

  // SuperUser: Get customer summary metrics
  app.get("/api/superuser/metrics/customers", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const customerMetrics = await storage.getCustomerSummaryMetrics();
      res.json(customerMetrics);
    } catch (error) {
      console.error('[SuperUser] Get customer metrics error:', error);
      res.status(500).json({ message: "Failed to fetch customer metrics" });
    }
  });

  // SuperUser: Get product usage metrics
  app.get("/api/superuser/metrics/usage", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const usageMetrics = await storage.getProductUsageMetrics();
      res.json(usageMetrics);
    } catch (error) {
      console.error('[SuperUser] Get usage metrics error:', error);
      res.status(500).json({ message: "Failed to fetch usage metrics" });
    }
  });

  // SuperUser: Get subscription breakdown by company
  app.get("/api/superuser/metrics/subscriptions", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const subscriptionBreakdown = await storage.getSubscriptionBreakdown();
      res.json({ subscriptions: subscriptionBreakdown });
    } catch (error) {
      console.error('[SuperUser] Get subscription breakdown error:', error);
      res.status(500).json({ message: "Failed to fetch subscription breakdown" });
    }
  });

  // SuperUser: Get combined dashboard metrics summary
  app.get("/api/superuser/metrics/summary", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_metrics')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      // Fetch all metrics in parallel
      const [mrrMetrics, customerMetrics, usageMetrics, allBuildings] = await Promise.all([
        storage.calculateLiveMrrMetrics(),
        storage.getCustomerSummaryMetrics(),
        storage.getProductUsageMetrics(),
        storage.getAllBuildings(),
      ]);

      res.json({
        mrr: mrrMetrics.totalMrr,
        arr: mrrMetrics.totalMrr * 12,
        byTier: mrrMetrics.byTier,
        byAddon: mrrMetrics.byAddon,
        customerCounts: mrrMetrics.customerCounts,
        customers: customerMetrics,
        usage: {
          ...usageMetrics,
          totalBuildings: allBuildings.length,
        },
      });
    } catch (error) {
      console.error('[SuperUser] Get metrics summary error:', error);
      res.status(500).json({ message: "Failed to fetch metrics summary" });
    }
  });

  // SuperUser: Get all feature requests with messages
  app.get("/api/superuser/feature-requests", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_feature_requests')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const requestsWithMessages = await storage.getFeatureRequestsWithMessages();
      
      // Enrich with company information
      const enrichedRequests = await Promise.all(
        requestsWithMessages.map(async (request) => {
          const company = await storage.getUserById(request.companyId);
          return {
            ...request,
            companyName: company?.companyName || 'Unknown Company',
            userName: company?.name || company?.email || 'Unknown',
          };
        })
      );

      // Sort by creation date (newest first) and then by priority
      enrichedRequests.sort((a, b) => {
        // Priority order: urgent, high, normal, low
        const priorityOrder: Record<string, number> = { urgent: 0, high: 1, normal: 2, low: 3 };
        const priorityDiff = (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);
        if (priorityDiff !== 0) return priorityDiff;
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      });

      res.json({ requests: enrichedRequests });
    } catch (error) {
      console.error('[SuperUser] Get feature requests error:', error);
      res.status(500).json({ message: "Failed to fetch feature requests" });
    }
  });

  // SuperUser: Update feature request status
  app.patch("/api/superuser/feature-requests/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_feature_requests')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const requestId = req.params.id;
      const { status } = req.body;

      const validStatuses = ['pending', 'reviewing', 'in_progress', 'completed', 'declined'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const updates: any = { status };
      if (status === 'completed' || status === 'declined') {
        updates.resolvedAt = new Date();
      }

      const updated = await storage.updateFeatureRequest(requestId, updates);
      res.json({ request: updated });
    } catch (error) {
      console.error('[SuperUser] Update feature request error:', error);
      res.status(500).json({ message: "Failed to update feature request" });
    }
  });

  // SuperUser: Send message on feature request
  app.post("/api/superuser/feature-requests/:id/messages", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_feature_requests')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const requestId = req.params.id;
      const { message } = req.body;

      if (!message?.trim()) {
        return res.status(400).json({ message: "Message is required" });
      }

      // Verify the request exists
      const request = await storage.getFeatureRequestById(requestId);
      if (!request) {
        return res.status(404).json({ message: "Feature request not found" });
      }

      const newMessage = await storage.createFeatureRequestMessage({
        requestId,
        senderId: 'superuser',
        senderRole: 'superuser',
        senderName: 'OnRopePro Team',
        message: message.trim(),
      });

      res.json({ message: newMessage });
    } catch (error) {
      console.error('[SuperUser] Send message error:', error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });

  // ==================== FUTURE IDEAS (SUPERUSER) ====================

  // SuperUser: Get all future ideas
  app.get("/api/superuser/future-ideas", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_future_ideas')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const ideas = await db.select().from(futureIdeas).orderBy(desc(futureIdeas.createdAt));
      res.json(ideas);
    } catch (error) {
      console.error('[SuperUser] Get future ideas error:', error);
      res.status(500).json({ message: "Failed to fetch future ideas" });
    }
  });

  // SuperUser: Create a future idea
  app.post("/api/superuser/future-ideas", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_future_ideas')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const parsed = insertFutureIdeaSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid data", errors: parsed.error.errors });
      }

      const [newIdea] = await db.insert(futureIdeas).values(parsed.data).returning();
      res.json(newIdea);
    } catch (error) {
      console.error('[SuperUser] Create future idea error:', error);
      res.status(500).json({ message: "Failed to create idea" });
    }
  });

  // SuperUser: Update a future idea
  app.patch("/api/superuser/future-ideas/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_future_ideas')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const ideaId = req.params.id;
      const { title, description, category, priority, status } = req.body;

      const [updated] = await db.update(futureIdeas)
        .set({
          ...(title !== undefined && { title }),
          ...(description !== undefined && { description }),
          ...(category !== undefined && { category }),
          ...(priority !== undefined && { priority }),
          ...(status !== undefined && { status }),
          updatedAt: new Date(),
        })
        .where(eq(futureIdeas.id, ideaId))
        .returning();

      if (!updated) {
        return res.status(404).json({ message: "Idea not found" });
      }

      res.json(updated);
    } catch (error) {
      console.error('[SuperUser] Update future idea error:', error);
      res.status(500).json({ message: "Failed to update idea" });
    }
  });

  // SuperUser: Delete a future idea
  app.delete("/api/superuser/future-ideas/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_future_ideas')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const ideaId = req.params.id;
      await db.delete(futureIdeas).where(eq(futureIdeas.id, ideaId));
      res.json({ message: "Idea deleted" });
    } catch (error) {
      console.error('[SuperUser] Delete future idea error:', error);
      res.status(500).json({ message: "Failed to delete idea" });
    }
  });

  // SuperUser: View company dashboard data (impersonation mode - read-only)
  app.get("/api/superuser/impersonate/:companyId/dashboard", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const companyId = req.params.companyId;
      
      // Get the company user
      const company = await storage.getUserById(companyId);
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Fetch all dashboard-related data for this company
      const [projects, employees, clients, workSessions, quotes] = await Promise.all([
        storage.getProjectsByCompany(companyId),
        storage.getAllEmployees(companyId),
        storage.getClientsByCompany(companyId),
        storage.getWorkSessionsByCompany(companyId),
        storage.getQuotesByCompany(companyId),
      ]);

      // Get active work sessions
      const activeWorkSessions = workSessions.filter(session => session.status === 'active');

      // Calculate stats
      const stats = {
        totalProjects: projects.length,
        activeProjects: projects.filter(p => p.status === 'active').length,
        completedProjects: projects.filter(p => p.status === 'completed').length,
        totalEmployees: employees.length,
        activeWorkers: activeWorkSessions.length,
        totalClients: clients.length,
        totalQuotes: quotes.length,
        pendingQuotes: quotes.filter(q => q.status === 'pending' || q.status === 'submitted').length,
      };

      // Build company info (without password)
      const { passwordHash, ...companyInfo } = company;

      res.json({
        company: companyInfo,
        projects,
        employees: employees.map(emp => {
          const { passwordHash: _, ...empWithoutPassword } = emp;
          return empWithoutPassword;
        }),
        clients,
        stats,
        activeWorkSessions: activeWorkSessions.map(session => ({
          ...session,
          employeeName: employees.find(e => e.id === session.userId)?.name || 'Unknown',
        })),
        quotes: quotes.slice(0, 20), // Limit to recent 20 quotes
      });
    } catch (error) {
      console.error('[SuperUser] Impersonate dashboard error:', error);
      res.status(500).json({ message: "Failed to fetch company dashboard data" });
    }
  });

  // SuperUser: Get company safety data (impersonation mode - read-only)
  app.get("/api/superuser/impersonate/:companyId/safety", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const companyId = req.params.companyId;
      
      // Verify company exists
      const company = await storage.getUserById(companyId);
      if (!company || company.role !== 'company') {
        return res.status(404).json({ message: "Company not found" });
      }

      // Fetch safety-related data
      const [harnessInspections, toolboxMeetings, flhaForms, incidentReports] = await Promise.all([
        storage.getHarnessInspectionsByCompany(companyId),
        storage.getToolboxMeetingsByCompany(companyId),
        storage.getFlhaFormsByCompany(companyId),
        storage.getIncidentReportsByCompany(companyId),
      ]);

      res.json({
        harnessInspections: harnessInspections.slice(0, 50),
        toolboxMeetings: toolboxMeetings.slice(0, 50),
        flhaForms: flhaForms.slice(0, 50),
        incidentReports: incidentReports.slice(0, 50),
        counts: {
          harnessInspections: harnessInspections.length,
          toolboxMeetings: toolboxMeetings.length,
          flhaForms: flhaForms.length,
          incidentReports: incidentReports.length,
        }
      });
    } catch (error) {
      console.error('[SuperUser] Impersonate safety error:', error);
      res.status(500).json({ message: "Failed to fetch company safety data" });
    }
  });

  // ==================== GLOBAL BUILDINGS DATABASE (SuperUser) ====================

  // SuperUser: Get all buildings
  app.get("/api/superuser/buildings", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const allBuildings = await storage.getAllBuildings();
      
      // Return buildings without password hash
      const buildings = allBuildings.map(({ passwordHash, ...building }) => building);
      
      res.json({ buildings });
    } catch (error) {
      console.error('[SuperUser] Get all buildings error:', error);
      res.status(500).json({ message: "Failed to fetch buildings" });
    }
  });

  // SuperUser: Get single building with project history
  app.get("/api/superuser/buildings/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const building = await storage.getBuildingById(req.params.id);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      // Get all projects for this building
      const buildingProjects = await storage.getProjectsForBuilding(building.strataPlanNumber);
      
      // Get unique companies that have worked on this building
      const companyIds = Array.from(new Set(buildingProjects.map(p => p.companyId)));
      const companies = await Promise.all(
        companyIds.map(async (id) => {
          const company = await storage.getUserById(id);
          return company ? { id: company.id, name: company.companyName } : null;
        })
      );

      // Get building instructions
      const instructions = await storage.getBuildingInstructions(building.id);

      const { passwordHash, ...buildingData } = building;
      
      res.json({ 
        building: buildingData,
        projects: buildingProjects,
        companies: companies.filter(Boolean),
        instructions: instructions || null,
      });
    } catch (error) {
      console.error('[SuperUser] Get building error:', error);
      res.status(500).json({ message: "Failed to fetch building" });
    }
  });

  // SuperUser: Update building details
  app.patch("/api/superuser/buildings/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const building = await storage.getBuildingById(req.params.id);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      // Don't allow changing strata plan number (it's the unique identifier)
      const { strataPlanNumber, passwordHash, ...allowedUpdates } = req.body;
      
      const updated = await storage.updateBuilding(req.params.id, allowedUpdates);
      
      if (updated) {
        const { passwordHash: _, ...buildingData } = updated;
        res.json({ building: buildingData });
      } else {
        res.status(500).json({ message: "Failed to update building" });
      }
    } catch (error) {
      console.error('[SuperUser] Update building error:', error);
      res.status(500).json({ message: "Failed to update building" });
    }
  });

  // SuperUser: Reset building password
  app.post("/api/superuser/buildings/:id/reset-password", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const building = await storage.getBuildingById(req.params.id);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      const newPassword = req.body.password || building.strataPlanNumber;
      await storage.updateBuildingPassword(req.params.id, newPassword);
      
      res.json({ message: "Password reset successfully" });
    } catch (error) {
      console.error('[SuperUser] Reset building password error:', error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  // SuperUser: Geocode a building's address to get lat/lng
  app.post("/api/superuser/buildings/:id/geocode", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const building = await storage.getBuildingById(req.params.id);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      // Build address string for geocoding
      const addressParts = [
        building.buildingAddress,
        building.city,
        building.province,
        building.postalCode,
      ].filter(Boolean);

      if (addressParts.length === 0) {
        return res.status(400).json({ message: "Building has no address to geocode" });
      }

      const addressString = addressParts.join(", ");
      
      const apiKey = process.env.GEOAPIFY_API_KEY;
      if (!apiKey) {
        return res.status(500).json({ message: "Geocoding service not configured" });
      }

      const response = await fetch(
        `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(addressString)}&apiKey=${apiKey}`
      );

      if (!response.ok) {
        return res.status(500).json({ message: "Geocoding service error" });
      }

      const data = await response.json();
      
      if (!data.features || data.features.length === 0) {
        return res.status(404).json({ message: "Could not find coordinates for this address" });
      }

      const [longitude, latitude] = data.features[0].geometry.coordinates;
      
      // Update building with new coordinates
      const updated = await storage.updateBuilding(req.params.id, {
        latitude: latitude.toString(),
        longitude: longitude.toString(),
      });

      if (updated) {
        const { passwordHash, ...buildingData } = updated;
        res.json({ building: buildingData, geocoded: true });
      } else {
        res.status(500).json({ message: "Failed to update building coordinates" });
      }
    } catch (error) {
      console.error('[SuperUser] Geocode building error:', error);
      res.status(500).json({ message: "Failed to geocode building" });
    }
  });

  // SuperUser: Batch geocode all buildings without coordinates
  app.post("/api/superuser/buildings/geocode-all", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_buildings')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const allBuildings = await storage.getAllBuildings();
      const buildingsToGeocode = allBuildings.filter(b => !b.latitude || !b.longitude);
      
      const apiKey = process.env.GEOAPIFY_API_KEY;
      if (!apiKey) {
        return res.status(500).json({ message: "Geocoding service not configured" });
      }

      let successCount = 0;
      let failCount = 0;

      for (const building of buildingsToGeocode) {
        const addressParts = [
          building.buildingAddress,
          building.city,
          building.province,
          building.postalCode,
        ].filter(Boolean);

        if (addressParts.length === 0) {
          failCount++;
          continue;
        }

        try {
          const addressString = addressParts.join(", ");
          const response = await fetch(
            `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(addressString)}&apiKey=${apiKey}`
          );

          if (response.ok) {
            const data = await response.json();
            if (data.features && data.features.length > 0) {
              const [longitude, latitude] = data.features[0].geometry.coordinates;
              await storage.updateBuilding(building.id, {
                latitude: latitude.toString(),
                longitude: longitude.toString(),
              });
              successCount++;
            } else {
              failCount++;
            }
          } else {
            failCount++;
          }
          
          // Rate limit: wait 200ms between requests
          await new Promise(resolve => setTimeout(resolve, 200));
        } catch (err) {
          failCount++;
        }
      }

      res.json({ 
        message: `Geocoded ${successCount} buildings, ${failCount} failed`,
        successCount,
        failCount,
        total: buildingsToGeocode.length
      });
    } catch (error) {
      console.error('[SuperUser] Batch geocode error:', error);
      res.status(500).json({ message: "Failed to batch geocode buildings" });
    }
  });

  // ==================== BUILDING INSTRUCTIONS ====================

  // Get building with instructions by strata plan number (for project detail page)
  app.get("/api/buildings/by-strata/:strataPlanNumber", requireAuth, async (req: Request, res: Response) => {
    try {
      const { strataPlanNumber } = req.params;
      const user = await storage.getUserById(req.session.userId!);
      
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const building = await storage.getBuildingByStrata(strataPlanNumber);
      if (!building) {
        return res.json({ building: null, instructions: null });
      }

      const instructions = await storage.getBuildingInstructions(building.id);
      
      // Remove sensitive data
      const { passwordHash, ...buildingData } = building;
      
      res.json({ building: buildingData, instructions: instructions || null });
    } catch (error) {
      console.error('[Buildings] Get by strata error:', error);
      res.status(500).json({ message: "Failed to get building data" });
    }
  });

  // Get building instructions by building ID (accessible to building managers, companies with projects, and superuser)
  app.get("/api/buildings/:buildingId/instructions", async (req: Request, res: Response) => {
    try {
      const { buildingId } = req.params;

      // SuperUser can access all
      if (req.session.userId === 'superuser') {
        const instructions = await storage.getBuildingInstructions(buildingId);
        return res.json(instructions || null);
      }

      // Building manager session (uses buildingId, not userId)
      if (req.session.role === 'building' && req.session.buildingId) {
        // Building managers can only access their own building's instructions
        if (req.session.buildingId === buildingId) {
          const instructions = await storage.getBuildingInstructions(buildingId);
          return res.json(instructions || null);
        }
        return res.status(403).json({ message: "Access denied" });
      }

      // Regular user session
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      // Company owners can access buildings they have projects for
      if (user.role === 'company') {
        const building = await storage.getBuildingById(buildingId);
        if (building) {
          const projects = await storage.getProjectsByCompany(user.id);
          const hasProjectForBuilding = projects.some(p => 
            p.strataPlanNumber && 
            p.strataPlanNumber.toUpperCase().replace(/\s/g, '') === 
            building.strataPlanNumber.toUpperCase().replace(/\s/g, '')
          );
          if (hasProjectForBuilding) {
            const instructions = await storage.getBuildingInstructions(buildingId);
            return res.json(instructions || null);
          }
        }
      }

      return res.status(403).json({ message: "Access denied" });
    } catch (error) {
      console.error('[BuildingInstructions] Get error:', error);
      res.status(500).json({ message: "Failed to get building instructions" });
    }
  });

  // Create or update building instructions
  app.post("/api/buildings/:buildingId/instructions", async (req: Request, res: Response) => {
    try {
      const { buildingId } = req.params;

      // SuperUser can update any building
      if (req.session.userId === 'superuser') {
        const instructions = await storage.upsertBuildingInstructions({
          buildingId,
          ...req.body,
          createdByUserId: 'superuser',
          createdByRole: 'superuser',
        });
        return res.json(instructions);
      }

      // Building manager session (uses buildingId, not userId)
      if (req.session.role === 'building' && req.session.buildingId) {
        // Building managers can only update their own building's instructions
        if (req.session.buildingId === buildingId) {
          const instructions = await storage.upsertBuildingInstructions({
            buildingId,
            ...req.body,
            createdByUserId: null, // Building managers don't have user IDs
            createdByRole: 'building_manager',
          });
          return res.json(instructions);
        }
        return res.status(403).json({ message: "Access denied" });
      }

      // Regular user session
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      // Company owners can update buildings they have projects for
      if (user.role === 'company') {
        const building = await storage.getBuildingById(buildingId);
        if (building) {
          const projects = await storage.getProjectsByCompany(user.id);
          const hasProjectForBuilding = projects.some(p => 
            p.strataPlanNumber && 
            p.strataPlanNumber.toUpperCase().replace(/\s/g, '') === 
            building.strataPlanNumber.toUpperCase().replace(/\s/g, '')
          );
          if (hasProjectForBuilding) {
            const instructions = await storage.upsertBuildingInstructions({
              buildingId,
              ...req.body,
              createdByUserId: user.id,
              createdByRole: 'company',
            });
            return res.json(instructions);
          }
        }
      }

      return res.status(403).json({ message: "Access denied" });
    } catch (error) {
      console.error('[BuildingInstructions] Upsert error:', error);
      res.status(500).json({ message: "Failed to save building instructions" });
    }
  });

  // Update building address with coordinates (Building managers, Property managers, SuperUser)
  app.patch("/api/buildings/:buildingId/address", async (req: Request, res: Response) => {
    try {
      const { buildingId } = req.params;
      const { address, latitude, longitude } = req.body;

      // SuperUser can update any building
      if (req.session.userId === 'superuser') {
        await storage.updateBuildingAddress(buildingId, address, latitude, longitude);
        return res.json({ success: true });
      }

      // Building manager session (uses buildingId, not userId)
      if (req.session.role === 'building' && req.session.buildingId) {
        if (req.session.buildingId === buildingId) {
          await storage.updateBuildingAddress(buildingId, address, latitude, longitude);
          return res.json({ success: true });
        }
        return res.status(403).json({ message: "Access denied" });
      }

      // Regular user session
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const user = await storage.getUserById(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      // Property managers can update buildings they are linked to via strata numbers
      if (user.role === 'property_manager') {
        const links = await storage.getPropertyManagerVendorLinks(user.id);
        const allStrataNums = links.flatMap(link => 
          (link.strataNumbers || []).map(s => s.toUpperCase().replace(/\s/g, ''))
        );
        const building = await storage.getBuildingById(buildingId);
        if (building && allStrataNums.includes(building.strataPlanNumber.toUpperCase().replace(/\s/g, ''))) {
          await storage.updateBuildingAddress(buildingId, address, latitude, longitude);
          return res.json({ success: true });
        }
      }

      // Company owners can update buildings they have projects for
      if (user.role === 'company') {
        const building = await storage.getBuildingById(buildingId);
        if (building) {
          const projects = await storage.getProjectsByCompany(user.id);
          const hasProjectForBuilding = projects.some(p => 
            p.strataPlanNumber && 
            p.strataPlanNumber.toUpperCase().replace(/\s/g, '') === 
            building.strataPlanNumber.toUpperCase().replace(/\s/g, '')
          );
          if (hasProjectForBuilding) {
            await storage.updateBuildingAddress(buildingId, address, latitude, longitude);
            return res.json({ success: true });
          }
        }
      }

      return res.status(403).json({ message: "Access denied" });
    } catch (error) {
      console.error('[BuildingAddress] Update error:', error);
      res.status(500).json({ message: "Failed to update building address" });
    }
  });

  // Delete building instructions (SuperUser and building managers only)
  app.delete("/api/buildings/:buildingId/instructions", async (req: Request, res: Response) => {
    try {
      const { buildingId } = req.params;

      // SuperUser can delete any
      if (req.session.userId === 'superuser') {
        await storage.deleteBuildingInstructions(buildingId);
        return res.json({ success: true });
      }

      // Building manager session (uses buildingId, not userId)
      if (req.session.role === 'building' && req.session.buildingId) {
        // Building managers can only delete their own building's instructions
        if (req.session.buildingId === buildingId) {
          await storage.deleteBuildingInstructions(buildingId);
          return res.json({ success: true });
        }
        return res.status(403).json({ message: "Access denied" });
      }

      return res.status(403).json({ message: "Access denied" });
    } catch (error) {
      console.error('[BuildingInstructions] Delete error:', error);
      res.status(500).json({ message: "Failed to delete building instructions" });
    }
  });

  // ==================== SUPERUSER TECHNICIAN DATABASE ====================

  // Get all technicians (SuperUser only)
  app.get("/api/superuser/technicians", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_technicians')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const page = parseInt(req.query.page as string) || 1;
      const pageSize = Math.min(parseInt(req.query.pageSize as string) || 50, 100);
      const search = (req.query.search as string) || undefined;
      const companyId = (req.query.companyId as string) || undefined;
      const linkedOnly = req.query.linkedOnly === 'true' ? true : 
                        req.query.linkedOnly === 'false' ? false : undefined;

      const result = await storage.getAllTechnicians({ 
        page, 
        pageSize, 
        search, 
        companyId, 
        linkedOnly 
      });

      // Convert Map to object for JSON serialization
      const companiesObject: Record<string, { name: string; id: string }> = {};
      result.companies.forEach((value, key) => {
        companiesObject[key] = value;
      });

      // Get referral counts for all technicians in this batch
      const referralCounts = new Map<string, number>();
      for (const tech of result.technicians) {
        const count = await storage.getReferralCount(tech.id);
        referralCounts.set(tech.id, count);
      }

      // Format technicians for response (exclude sensitive fields)
      const technicians = result.technicians.map(tech => ({
        id: tech.id,
        name: tech.name,
        email: tech.email,
        companyId: tech.companyId,
        companyName: tech.companyId ? companiesObject[tech.companyId]?.name : null,
        irataLevel: tech.irataLevel,
        irataLicenseNumber: tech.irataLicenseNumber,
        irataExpiry: tech.irataExpiry,
        irataVerified: tech.irataVerified,
        spratLevel: tech.spratLevel,
        spratLicenseNumber: tech.spratLicenseNumber,
        spratExpiry: tech.spratExpiry,
        spratVerified: tech.spratVerified,
        startDate: tech.startDate,
        terminatedDate: tech.terminatedDate,
        terminationReason: tech.terminationReason,
        createdAt: tech.createdAt,
        lastActivityAt: tech.lastActivityAt,
        employeeCity: tech.employeeCity,
        employeeProvinceState: tech.employeeProvinceState,
        employeeCountry: tech.employeeCountry,
        referralCode: tech.referralCode,
        referralCount: referralCounts.get(tech.id) || 0,
        hasPlusAccess: tech.hasPlusAccess || false,
        isDisabled: tech.isDisabled || false,
      }));

      res.json({ 
        technicians, 
        total: result.total,
        page,
        pageSize,
        totalPages: Math.ceil(result.total / pageSize)
      });
    } catch (error) {
      console.error('[SuperUser] Get technicians error:', error);
      res.status(500).json({ message: "Failed to fetch technicians" });
    }
  });

  // Get single technician details (SuperUser only)
  app.get("/api/superuser/technicians/:technicianId", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_technicians')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { technicianId } = req.params;
      const result = await storage.getTechnicianWithCompanyDetails(technicianId);

      if (!result) {
        return res.status(404).json({ message: "Technician not found" });
      }

      const { technician, company } = result;

      // Return full technician details (excluding password hash and raw sensitive data)
      const technicianDetails = {
        id: technician.id,
        name: technician.name,
        email: technician.email,
        role: technician.role,
        companyId: technician.companyId,
        
        // Certification Info
        irataLevel: technician.irataLevel,
        irataLicenseNumber: technician.irataLicenseNumber,
        irataExpiry: technician.irataExpiry,
        irataVerified: technician.irataVerified,
        irataVerifiedAt: technician.irataVerifiedAt,
        spratLevel: technician.spratLevel,
        spratLicenseNumber: technician.spratLicenseNumber,
        spratExpiry: technician.spratExpiry,
        spratVerified: technician.spratVerified,
        spratVerifiedAt: technician.spratVerifiedAt,
        
        // Employment Info
        startDate: technician.startDate,
        terminatedDate: technician.terminatedDate,
        terminationReason: technician.terminationReason,
        hourlyRate: technician.hourlyRate,
        isSalary: technician.isSalary,
        salary: technician.salary,
        permissions: technician.permissions,
        
        // Personal Info
        birthday: technician.birthday,
        employeePhoneNumber: technician.employeePhoneNumber,
        smsNotificationsEnabled: technician.smsNotificationsEnabled,
        employeeStreetAddress: technician.employeeStreetAddress,
        employeeCity: technician.employeeCity,
        employeeProvinceState: technician.employeeProvinceState,
        employeeCountry: technician.employeeCountry,
        employeePostalCode: technician.employeePostalCode,
        
        // Emergency Contact
        emergencyContactName: technician.emergencyContactName,
        emergencyContactPhone: technician.emergencyContactPhone,
        emergencyContactRelationship: technician.emergencyContactRelationship,
        
        // Driver's License
        driversLicenseNumber: technician.driversLicenseNumber ? '****' + technician.driversLicenseNumber.slice(-4) : null,
        driversLicenseExpiry: technician.driversLicenseExpiry,
        driversLicenseProvince: technician.driversLicenseProvince,
        
        // Documents
        bankDocuments: technician.bankDocuments,
        driversLicenseDocuments: technician.driversLicenseDocuments,
        firstAidDocuments: technician.firstAidDocuments,
        irataDocuments: technician.irataDocuments,
        spratDocuments: technician.spratDocuments,
        
        // Medical
        specialMedicalConditions: technician.specialMedicalConditions,
        
        // Metadata
        createdAt: technician.createdAt,
        lastActivityAt: technician.lastActivityAt,
        irataBaselineHours: technician.irataBaselineHours,
        
        // PLUS Access
        hasPlusAccess: technician.hasPlusAccess || false,
        referralCount: await storage.getReferralCount(technicianId),
        
        // Account Status
        isDisabled: technician.isDisabled || false,
        disabledAt: technician.disabledAt,
        disabledReason: technician.disabledReason,
      };

      // Company info (if linked)
      const companyInfo = company ? {
        id: company.id,
        name: company.companyName,
        email: company.email,
        subscriptionTier: company.subscriptionTier,
        licenseVerified: company.licenseVerified,
      } : null;

      res.json({ 
        technician: technicianDetails, 
        company: companyInfo 
      });
    } catch (error) {
      console.error('[SuperUser] Get technician details error:', error);
      res.status(500).json({ message: "Failed to fetch technician details" });
    }
  });

  // Toggle PLUS access for a technician (SuperUser only)
  app.put("/api/superuser/technicians/:technicianId/plus-access", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_technicians')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { technicianId } = req.params;
      const { hasPlusAccess } = req.body;

      if (typeof hasPlusAccess !== 'boolean') {
        return res.status(400).json({ message: "hasPlusAccess must be a boolean" });
      }

      // Find the user
      const user = await storage.getUserById(technicianId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Update the hasPlusAccess field
      await db.update(users).set({
        hasPlusAccess: hasPlusAccess,
      }).where(eq(users.id, technicianId));

      console.log(`[SuperUser] ${hasPlusAccess ? 'Granted' : 'Revoked'} PLUS access for technician ${technicianId}`);

      res.json({ 
        success: true, 
        message: `PLUS access ${hasPlusAccess ? 'granted' : 'revoked'} successfully` 
      });
    } catch (error) {
      console.error('[SuperUser] Toggle PLUS access error:', error);
      res.status(500).json({ message: "Failed to update PLUS access" });
    }
  });

  // Disable/Enable account (SuperUser only) - for fraud or misuse
  app.put("/api/superuser/accounts/:userId/status", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { userId } = req.params;
      const { isDisabled, reason, confirmationCode } = req.body;

      // Validate confirmation code for double confirmation
      if (confirmationCode !== 'CONFIRM-DISABLE' && confirmationCode !== 'CONFIRM-ENABLE') {
        return res.status(400).json({ message: "Invalid confirmation code. Use 'CONFIRM-DISABLE' or 'CONFIRM-ENABLE'" });
      }

      // Validate the action matches the confirmation code
      if (isDisabled && confirmationCode !== 'CONFIRM-DISABLE') {
        return res.status(400).json({ message: "Confirmation code must be 'CONFIRM-DISABLE' to disable an account" });
      }
      if (!isDisabled && confirmationCode !== 'CONFIRM-ENABLE') {
        return res.status(400).json({ message: "Confirmation code must be 'CONFIRM-ENABLE' to re-enable an account" });
      }

      if (typeof isDisabled !== 'boolean') {
        return res.status(400).json({ message: "isDisabled must be a boolean" });
      }

      // Find the user
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Cannot disable superuser
      if (user.role === 'superuser') {
        return res.status(400).json({ message: "Cannot disable superuser account" });
      }

      // Only allow disabling company or rope_access_tech accounts
      if (user.role !== 'company' && user.role !== 'rope_access_tech') {
        return res.status(400).json({ message: "Can only disable company or technician accounts" });
      }

      // Require reason for disabling
      if (isDisabled && (!reason || reason.trim().length < 10)) {
        return res.status(400).json({ message: "A reason of at least 10 characters is required to disable an account" });
      }

      // Update the account status
      await db.update(users).set({
        isDisabled: isDisabled,
        disabledAt: isDisabled ? new Date() : null,
        disabledReason: isDisabled ? reason : null,
        disabledBy: isDisabled ? 'superuser' : null,
      }).where(eq(users.id, userId));

      console.log(`[SuperUser] ${isDisabled ? 'Disabled' : 'Re-enabled'} account for user ${userId} (${user.email || user.companyName}). Reason: ${reason || 'N/A'}`);

      res.json({ 
        success: true, 
        message: `Account ${isDisabled ? 'disabled' : 're-enabled'} successfully`,
        user: {
          id: user.id,
          name: user.name || user.companyName,
          email: user.email,
          role: user.role,
          isDisabled: isDisabled,
        }
      });
    } catch (error) {
      console.error('[SuperUser] Toggle account status error:', error);
      res.status(500).json({ message: "Failed to update account status" });
    }
  });

  // Get account suspension status (SuperUser only)
  app.get("/api/superuser/accounts/:userId/status", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_companies')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { userId } = req.params;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({
        id: user.id,
        name: user.name || user.companyName,
        email: user.email,
        role: user.role,
        isDisabled: user.isDisabled || false,
        disabledAt: user.disabledAt,
        disabledReason: user.disabledReason,
        disabledBy: user.disabledBy,
      });
    } catch (error) {
      console.error('[SuperUser] Get account status error:', error);
      res.status(500).json({ message: "Failed to get account status" });
    }
  });

  // ==================== SUPERUSER TASK MANAGEMENT ====================

  // Get all SuperUser tasks with comments
  app.get("/api/superuser/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const tasks = await db.query.superuserTasks.findMany({
        orderBy: (tasks, { asc, desc }) => [asc(tasks.section), desc(tasks.createdAt)],
      });

      // Get comments for all tasks
      const comments = await db.query.superuserTaskComments.findMany({
        orderBy: (comments, { asc }) => [asc(comments.createdAt)],
      });

      // Group comments by taskId
      const commentsByTask: Record<string, typeof comments> = {};
      for (const comment of comments) {
        if (!commentsByTask[comment.taskId]) {
          commentsByTask[comment.taskId] = [];
        }
        commentsByTask[comment.taskId].push(comment);
      }

      // Attach comments to tasks
      const tasksWithComments = tasks.map(task => ({
        ...task,
        comments: commentsByTask[task.id] || [],
      }));

      res.json({ tasks: tasksWithComments });
    } catch (error) {
      console.error('[SuperUser] Get tasks error:', error);
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });

  // Create a new SuperUser task
  app.post("/api/superuser/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { title, description, section, assignee, dueDate, priority, createdBy } = req.body;

      if (!title || !section || !assignee || !createdBy) {
        return res.status(400).json({ message: "Title, section, assignee, and createdBy are required" });
      }

      const [task] = await db.insert(superuserTasks).values({
        title,
        description: description || null,
        section,
        assignee,
        dueDate: dueDate || null, // Convert empty string to null for date field
        priority: priority || 'medium',
        createdBy,
      }).returning();

      res.json({ task: { ...task, comments: [] } });
    } catch (error) {
      console.error('[SuperUser] Create task error:', error);
      res.status(500).json({ message: "Failed to create task" });
    }
  });

  // Update a SuperUser task (status, details)
  app.patch("/api/superuser/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;
      const { status, title, description, section, assignee, dueDate, priority, completedBy, currentUser } = req.body;

      // SECURITY: Only the assignee can complete or uncomplete a task
      if (status !== undefined) {
        const existingTask = await db.query.superuserTasks.findFirst({
          where: eq(superuserTasks.id, id),
        });
        
        if (!existingTask) {
          return res.status(404).json({ message: "Task not found" });
        }
        
        // If changing status to/from completed, verify the current user is the assignee
        if (status === 'completed' || existingTask.status === 'completed') {
          if (currentUser !== existingTask.assignee) {
            return res.status(403).json({ message: "Only the assignee can complete or uncomplete this task" });
          }
        }
      }

      const updates: any = { updatedAt: new Date() };
      
      if (status !== undefined) {
        updates.status = status;
        // If completing the task, record completion details
        if (status === 'completed') {
          updates.completedAt = new Date();
          updates.completedBy = completedBy || 'Unknown';
        } else {
          // If uncompleting, clear completion details
          updates.completedAt = null;
          updates.completedBy = null;
        }
      }
      if (title !== undefined) updates.title = title;
      if (description !== undefined) updates.description = description || null;
      if (section !== undefined) updates.section = section;
      if (assignee !== undefined) updates.assignee = assignee;
      if (dueDate !== undefined) updates.dueDate = dueDate || null; // Convert empty string to null
      if (priority !== undefined) updates.priority = priority;

      const [updated] = await db.update(superuserTasks)
        .set(updates)
        .where(eq(superuserTasks.id, id))
        .returning();

      if (!updated) {
        return res.status(404).json({ message: "Task not found" });
      }

      // Get comments for this task
      const comments = await db.query.superuserTaskComments.findMany({
        where: eq(superuserTaskComments.taskId, id),
        orderBy: (comments, { asc }) => [asc(comments.createdAt)],
      });

      res.json({ task: { ...updated, comments } });
    } catch (error) {
      console.error('[SuperUser] Update task error:', error);
      res.status(500).json({ message: "Failed to update task" });
    }
  });

  // Delete a SuperUser task
  app.delete("/api/superuser/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;

      await db.delete(superuserTasks).where(eq(superuserTasks.id, id));

      res.json({ message: "Task deleted" });
    } catch (error) {
      console.error('[SuperUser] Delete task error:', error);
      res.status(500).json({ message: "Failed to delete task" });
    }
  });

  // Add a comment to a SuperUser task
  app.post("/api/superuser/tasks/:id/comments", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;
      const { authorName, content } = req.body;

      if (!authorName || !content) {
        return res.status(400).json({ message: "Author name and content are required" });
      }

      const [comment] = await db.insert(superuserTaskComments).values({
        taskId: id,
        authorName,
        content,
      }).returning();

      res.json({ comment });
    } catch (error) {
      console.error('[SuperUser] Add comment error:', error);
      res.status(500).json({ message: "Failed to add comment" });
    }
  });

  // Delete a comment
  app.delete("/api/superuser/tasks/:taskId/comments/:commentId", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { commentId } = req.params;

      await db.delete(superuserTaskComments).where(eq(superuserTaskComments.id, commentId));

      res.json({ message: "Comment deleted" });
    } catch (error) {
      console.error('[SuperUser] Delete comment error:', error);
      res.status(500).json({ message: "Failed to delete comment" });
    }
  });

  // ==================== TASK ATTACHMENTS ====================
  
  // Multer config for task attachments (supports various file types)
  const taskAttachmentUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 25 * 1024 * 1024 }, // 25MB max
    fileFilter: (req, file, cb) => {
      // Allow common document and file types
      const allowedTypes = [
        'text/markdown',
        'text/plain',
        'text/csv',
        'application/pdf',
        'application/json',
        'application/xml',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'image/png',
        'image/jpeg',
        'image/gif',
        'image/webp',
      ];
      // Also allow .md files which may come as application/octet-stream
      if (allowedTypes.includes(file.mimetype) || 
          file.originalname.endsWith('.md') ||
          file.originalname.endsWith('.txt')) {
        cb(null, true);
      } else {
        cb(new Error('File type not allowed. Supported: .md, .txt, .pdf, .doc, .docx, .xls, .xlsx, .json, .csv, images'));
      }
    }
  });

  // Get attachments for a task
  app.get("/api/superuser/tasks/:id/attachments", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;
      const attachments = await db.query.superuserTaskAttachments.findMany({
        where: eq(superuserTaskAttachments.taskId, id),
        orderBy: (attachments, { desc }) => [desc(attachments.createdAt)],
      });

      res.json({ attachments });
    } catch (error) {
      console.error('[SuperUser] Get attachments error:', error);
      res.status(500).json({ message: "Failed to get attachments" });
    }
  });

  // Upload attachment to a task
  app.post("/api/superuser/tasks/:id/attachments", requireAuth, taskAttachmentUpload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { id } = req.params;
      const { uploaderName } = req.body;

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      if (!uploaderName) {
        return res.status(400).json({ message: "Uploader name is required" });
      }

      // Verify task exists
      const task = await db.query.superuserTasks.findFirst({
        where: eq(superuserTasks.id, id),
      });

      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }

      // Generate unique filename
      const timestamp = Date.now();
      const safeOriginalName = req.file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
      const fileName = `task-${id}-${timestamp}-${safeOriginalName}`;

      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const storagePath = await objectStorageService.uploadPrivateFile(
        fileName,
        req.file.buffer,
        req.file.mimetype
      );

      // Save attachment record to database
      const [attachment] = await db.insert(superuserTaskAttachments).values({
        taskId: id,
        fileName,
        originalName: req.file.originalname,
        fileSize: req.file.size,
        contentType: req.file.mimetype,
        storagePath,
        uploadedBy: uploaderName,
      }).returning();

      res.json({ attachment });
    } catch (error) {
      console.error('[SuperUser] Upload attachment error:', error);
      res.status(500).json({ message: "Failed to upload attachment" });
    }
  });

  // Download attachment
  app.get("/api/superuser/tasks/:taskId/attachments/:attachmentId/download", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { attachmentId } = req.params;

      // Get attachment record
      const attachment = await db.query.superuserTaskAttachments.findFirst({
        where: eq(superuserTaskAttachments.id, attachmentId),
      });

      if (!attachment) {
        return res.status(404).json({ message: "Attachment not found" });
      }

      // Get file from object storage
      const objectStorageService = new ObjectStorageService();
      const file = await objectStorageService.getPrivateFile(attachment.fileName);

      if (!file) {
        return res.status(404).json({ message: "File not found in storage" });
      }

      // Set headers for download
      res.set({
        'Content-Disposition': `attachment; filename="${attachment.originalName}"`,
        'Content-Type': attachment.contentType,
      });

      await objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error('[SuperUser] Download attachment error:', error);
      res.status(500).json({ message: "Failed to download attachment" });
    }
  });

  // Delete attachment
  app.delete("/api/superuser/tasks/:taskId/attachments/:attachmentId", requireAuth, async (req: Request, res: Response) => {
    try {
      if (!isSuperuserOrHasPermission(req, 'view_tasks')) {
        return res.status(403).json({ message: "Access denied. Insufficient permissions." });
      }

      const { attachmentId } = req.params;

      // Get attachment to find file name
      const attachment = await db.query.superuserTaskAttachments.findFirst({
        where: eq(superuserTaskAttachments.id, attachmentId),
      });

      if (!attachment) {
        return res.status(404).json({ message: "Attachment not found" });
      }

      // Delete from database (file can stay in storage - orphaned files can be cleaned up later)
      await db.delete(superuserTaskAttachments).where(eq(superuserTaskAttachments.id, attachmentId));

      res.json({ message: "Attachment deleted" });
    } catch (error) {
      console.error('[SuperUser] Delete attachment error:', error);
      res.status(500).json({ message: "Failed to delete attachment" });
    }
  });

  // ==================== BUILDING PORTAL LOGIN ====================

  // Building login endpoint
  app.post("/api/building/login", loginRateLimiter, async (req: Request, res: Response) => {
    try {
      const { strataPlanNumber, password } = req.body;

      if (!strataPlanNumber || !password) {
        return res.status(400).json({ message: "Strata plan number and password are required" });
      }

      const building = await storage.verifyBuildingPassword(strataPlanNumber, password);
      
      if (!building) {
        return res.status(401).json({ message: "Invalid strata number or password" });
      }

      // Create building session
      req.session.userId = building.id;
      req.session.role = 'building';
      req.session.buildingId = building.id;
      req.session.strataPlanNumber = building.strataPlanNumber;

      // Save session before responding (critical for production)
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      const { passwordHash, ...buildingData } = building;
      
      res.json({ 
        message: "Login successful",
        building: buildingData,
      });
    } catch (error) {
      console.error('[Building] Login error:', error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Building portal: Get building data and project history
  app.get("/api/building/portal", requireAuth, async (req: Request, res: Response) => {
    try {
      // Check if this is a building session
      if (req.session.role !== 'building' || !req.session.buildingId) {
        return res.status(403).json({ message: "Access denied. Building login required." });
      }

      const building = await storage.getBuildingById(req.session.buildingId);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      // Get all projects for this building across all companies
      const allProjects = await storage.getProjectsForBuilding(building.strataPlanNumber);
      
      // Get work sessions for these projects with additional details for active projects
      const projectHistory = await Promise.all(
        allProjects.map(async (project) => {
          const company = await storage.getUserById(project.companyId);
          
          // Base project info
          const projectInfo: any = {
            id: project.id,
            jobType: project.jobType,
            customJobType: project.customJobType,
            status: project.status,
            startDate: project.startDate,
            endDate: project.endDate,
            companyName: company?.companyName || 'Unknown Company',
            createdAt: project.createdAt,
          };
          
          // For active projects, include more details and resident code
          if (project.status === 'active') {
            projectInfo.residentCode = company?.residentCode || null;
            projectInfo.companyPhone = company?.phone || null;
            projectInfo.companyEmail = company?.email || null;
            projectInfo.notes = project.notes || null;
            projectInfo.scheduledDates = project.scheduledDates || [];
            
            // Get progress info based on job type
            if (project.progressType === 'drops') {
              projectInfo.progressType = 'drops';
              projectInfo.totalDropsNorth = project.totalDropsNorth;
              projectInfo.totalDropsEast = project.totalDropsEast;
              projectInfo.totalDropsSouth = project.totalDropsSouth;
              projectInfo.totalDropsWest = project.totalDropsWest;
              projectInfo.completedDropsNorth = project.completedDropsNorth;
              projectInfo.completedDropsEast = project.completedDropsEast;
              projectInfo.completedDropsSouth = project.completedDropsSouth;
              projectInfo.completedDropsWest = project.completedDropsWest;
            } else if (project.progressType === 'suites') {
              projectInfo.progressType = 'suites';
              projectInfo.totalSuites = project.totalSuites;
              projectInfo.completedSuites = project.completedSuites;
            } else if (project.progressType === 'stalls') {
              projectInfo.progressType = 'stalls';
              projectInfo.totalStalls = project.totalStalls;
              projectInfo.completedStalls = project.completedStalls;
            } else if (project.progressType === 'hours') {
              projectInfo.progressType = 'hours';
              projectInfo.estimatedHours = project.estimatedHours;
              projectInfo.loggedHours = project.loggedHours;
            }
          }
          
          return projectInfo;
        })
      );

      const { passwordHash, ...buildingData } = building;
      
      // Get work notices for active projects
      const activeProjects = allProjects.filter(p => p.status === 'active');
      const workNoticesResult: any[] = [];
      
      for (const project of activeProjects) {
        const notices = await db.select().from(workNotices)
          .where(and(
            eq(workNotices.projectId, project.id),
            eq(workNotices.isPublished, true)
          ))
          .orderBy(desc(workNotices.createdAt));
        const company = await storage.getUserById(project.companyId);
        
        for (const notice of notices) {
          workNoticesResult.push({
            id: notice.id,
            title: notice.noticeTitle,
            content: notice.noticeDetails,
            additionalInstructions: notice.additionalInstructions,
            workStartDate: notice.startDate,
            workEndDate: notice.endDate,
            projectId: project.id,
            buildingName: project.buildingName,
            jobType: project.customJobType || project.jobType,
            companyName: company?.companyName || 'Unknown Company',
            companyPhone: company?.phone || null,
            logoUrl: company?.whitelabelBrandingActive ? company?.brandingLogoUrl : null,
            propertyManagerName: notice.propertyManagerName,
            createdAt: notice.createdAt,
            unitSchedule: notice.unitSchedule,
          });
        }
      }
      
      res.json({ 
        building: buildingData,
        projectHistory,
        workNotices: workNoticesResult,
        stats: {
          totalProjects: allProjects.length,
          completedProjects: allProjects.filter(p => p.status === 'completed').length,
          activeProjects: allProjects.filter(p => p.status === 'active').length,
        },
      });
    } catch (error) {
      console.error('[Building] Portal error:', error);
      res.status(500).json({ message: "Failed to fetch building data" });
    }
  });

  // Building portal: Change password
  app.post("/api/building/change-password", requireAuth, async (req: Request, res: Response) => {
    try {
      // Check if this is a building session
      if (req.session.role !== 'building' || !req.session.buildingId) {
        return res.status(403).json({ message: "Access denied. Building login required." });
      }

      const { currentPassword, newPassword, confirmPassword } = req.body;

      if (!currentPassword || !newPassword || !confirmPassword) {
        return res.status(400).json({ message: "All password fields are required" });
      }

      if (newPassword !== confirmPassword) {
        return res.status(400).json({ message: "New passwords do not match" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters long" });
      }

      const building = await storage.getBuildingById(req.session.buildingId);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found" });
      }

      // Verify current password
      const bcrypt = await import('bcrypt');
      const isCurrentPasswordValid = await bcrypt.compare(currentPassword, building.passwordHash);
      
      if (!isCurrentPasswordValid) {
        return res.status(401).json({ message: "Current password is incorrect" });
      }

      // Don't allow new password to be the same as strata number
      if (newPassword === building.strataPlanNumber) {
        return res.status(400).json({ message: "New password cannot be the same as your strata number" });
      }

      // Hash and save new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);
      await storage.updateBuildingPassword(building.id, newPasswordHash);

      res.json({ 
        success: true, 
        message: "Password changed successfully",
        passwordChangedAt: new Date().toISOString()
      });
    } catch (error) {
      console.error('[Building] Change password error:', error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  // Update user profile
  app.patch("/api/user/profile", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const updates: any = {};
      
      // Allow updating name for all users
      if (req.body.name !== undefined) {
        updates.name = req.body.name;
      }
      
      // Allow updating email for non-company users
      if (req.body.email !== undefined && user.role !== "company") {
        // Check if email is already in use by another user
        const existingUser = await storage.getUserByEmail(req.body.email);
        if (existingUser && existingUser.id !== user.id) {
          return res.status(400).json({ message: "Email address is already in use" });
        }
        updates.email = req.body.email;
      }
      
      // Role-specific updates
      if (user.role === "resident") {
        if (req.body.unitNumber !== undefined) {
          updates.unitNumber = req.body.unitNumber;
        }
      }
      
      if (user.role === "company") {
        if (req.body.companyName !== undefined) {
          updates.companyName = req.body.companyName;
        }
        if (req.body.residentCode !== undefined) {
          // Validate resident code format (10 characters, alphanumeric)
          const code = req.body.residentCode.trim().toUpperCase();
          if (code.length === 0) {
            // Allow clearing the code
            updates.residentCode = null;
          } else if (code.length !== 10) {
            return res.status(400).json({ message: "Resident code must be exactly 10 characters" });
          } else if (!/^[A-Z0-9]+$/.test(code)) {
            return res.status(400).json({ message: "Resident code can only contain letters and numbers" });
          } else {
            // Check if code is already in use by another company
            const existingCompany = await storage.getUserByResidentCode(code);
            if (existingCompany && existingCompany.id !== user.id) {
              return res.status(400).json({ message: "This resident code is already in use by another company" });
            }
            updates.residentCode = code;
          }
        }
        // Company profile fields
        if (req.body.streetAddress !== undefined) {
          updates.streetAddress = req.body.streetAddress || null;
        }
        if (req.body.province !== undefined) {
          updates.province = req.body.province || null;
        }
        if (req.body.country !== undefined) {
          updates.country = req.body.country || null;
        }
        if (req.body.zipCode !== undefined) {
          updates.zipCode = req.body.zipCode || null;
        }
        if (req.body.employeePhoneNumber !== undefined) {
          updates.employeePhoneNumber = req.body.employeePhoneNumber || null;
        }
        if (req.body.hourlyRate !== undefined) {
          // Convert empty string to null, otherwise parse as number
          updates.hourlyRate = req.body.hourlyRate === '' ? null : req.body.hourlyRate;
        }
        if (req.body.timezone !== undefined) {
          updates.timezone = req.body.timezone || "America/Vancouver";
        }
      }
      
      // Ground crew and rope access tech profile fields
      if (user.role === "ground_crew" || user.role === "ground_crew_supervisor" || user.role === "rope_access_tech") {
        // Map form fields to database columns
        // Handle both field name variations from different frontend forms
        if (req.body.employeePhoneNumber !== undefined) {
          updates.employeePhoneNumber = req.body.employeePhoneNumber || null;
        }
        if (req.body.smsNotificationsEnabled !== undefined) {
          updates.smsNotificationsEnabled = req.body.smsNotificationsEnabled ?? false;
        }
        if (req.body.phone !== undefined) {
          updates.employeePhoneNumber = req.body.phone || null;
        }
        if (req.body.birthday !== undefined) {
          updates.birthday = req.body.birthday || null;
        }
        if (req.body.address !== undefined) {
          updates.employeeStreetAddress = req.body.address || null;
        }
        if (req.body.city !== undefined) {
          updates.employeeCity = req.body.city || null;
        }
        if (req.body.provinceState !== undefined) {
          updates.employeeProvinceState = req.body.provinceState || null;
        }
        if (req.body.country !== undefined) {
          updates.employeeCountry = req.body.country || null;
        }
        if (req.body.postalCode !== undefined) {
          updates.employeePostalCode = req.body.postalCode || null;
        }
        // Emergency contact fields
        if (req.body.emergencyContactName !== undefined) {
          updates.emergencyContactName = req.body.emergencyContactName || null;
        }
        if (req.body.emergencyContactPhone !== undefined) {
          updates.emergencyContactPhone = req.body.emergencyContactPhone || null;
        }
        if (req.body.emergencyContactRelationship !== undefined) {
          updates.emergencyContactRelationship = req.body.emergencyContactRelationship || null;
        }
        // Payroll and license fields
        if (req.body.sin !== undefined) {
          updates.sin = req.body.sin || null;
        }
        if (req.body.bankTransit !== undefined) {
          updates.bankTransit = req.body.bankTransit || null;
        }
        if (req.body.bankInstitution !== undefined) {
          updates.bankInstitution = req.body.bankInstitution || null;
        }
        if (req.body.bankAccount !== undefined) {
          updates.bankAccount = req.body.bankAccount || null;
        }
        if (req.body.driversLicenseNumber !== undefined) {
          updates.driversLicenseNumber = req.body.driversLicenseNumber || null;
        }
        if (req.body.driversLicenseIssuedDate !== undefined) {
          updates.driversLicenseIssuedDate = req.body.driversLicenseIssuedDate || null;
        }
        if (req.body.driversLicenseExpiry !== undefined) {
          updates.driversLicenseExpiry = req.body.driversLicenseExpiry || null;
        }
        // Medical and first aid fields
        if (req.body.specialMedicalConditions !== undefined) {
          updates.specialMedicalConditions = req.body.specialMedicalConditions || null;
        }
        if (req.body.firstAidType !== undefined) {
          updates.firstAidType = req.body.firstAidType || null;
        }
        if (req.body.firstAidExpiry !== undefined) {
          updates.firstAidExpiry = req.body.firstAidExpiry || null;
        }
      }
      
      await storage.updateUser(user.id, updates);
      const updatedUser = await storage.getUserById(user.id);
      
      const { passwordHash, ...userWithoutPassword } = updatedUser!;
      res.json({ user: userWithoutPassword, message: "Profile updated successfully" });
    } catch (error) {
      console.error("Update profile error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Change password - SECURITY: Rate limited to prevent brute force attacks
  app.patch("/api/user/password", requireAuth, passwordChangeRateLimiter, async (req: Request, res: Response) => {
    try {
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current and new passwords are required" });
      }
      
      // SECURITY: Validate password strength
      const passwordValidation = validatePasswordStrength(newPassword);
      if (!passwordValidation.valid) {
        return res.status(400).json({ message: passwordValidation.message });
      }
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify current password
      const isValid = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!isValid) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }
      
      // Hash and update new password
      const passwordHash = await bcrypt.hash(newPassword, 10);
      await storage.updateUser(user.id, { passwordHash, isTempPassword: false });
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update language preference
  app.patch("/api/user/language", requireAuth, async (req: Request, res: Response) => {
    try {
      const { language } = req.body;
      
      if (!language || !['en', 'fr'].includes(language)) {
        return res.status(400).json({ message: "Invalid language. Must be 'en' or 'fr'" });
      }
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      await storage.updateUser(user.id, { preferredLanguage: language });
      
      res.json({ message: "Language preference updated successfully", language });
    } catch (error) {
      console.error("Update language error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete company account (company role only)
  app.delete("/api/user/account", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const { password } = req.body;
      
      if (!password) {
        return res.status(400).json({ message: "Password is required to delete account" });
      }
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify password
      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(400).json({ message: "Incorrect password" });
      }
      
      // Delete user (cascades to all employees, projects, work sessions, drop logs, complaints)
      await storage.deleteUser(user.id);
      
      // Destroy session
      req.session.destroy((err) => {
        if (err) {
          console.error("Session destroy error:", err);
        }
      });
      
      res.json({ message: "Account deleted successfully" });
    } catch (error) {
      console.error("Delete account error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get company information by ID
  app.get("/api/companies/:companyId", requireAuth, async (req: Request, res: Response) => {
    try {
      const company = await storage.getUserById(req.params.companyId);
      
      if (!company || company.role !== "company") {
        return res.status(404).json({ message: "Company not found" });
      }

      // Return only public company information
      res.json({ 
        company: {
          id: company.id,
          companyName: company.companyName,
          residentCode: company.residentCode,
        }
      });
    } catch (error) {
      console.error("Get company error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== EMPLOYEE ROUTES ====================
  
  // Create employee (Company/Operations Manager only)
  app.post("/api/employees", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get company ID (company themselves or the employee's company)
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { 
        name, email, password, role, techLevel, hourlyRate, isSalary, salary, permissions,
        startDate, birthday, driversLicenseNumber, driversLicenseProvince, driversLicenseDocuments,
        homeAddress, employeePhoneNumber, emergencyContactName, emergencyContactPhone,
        specialMedicalConditions, irataLevel, irataLicenseNumber, irataIssuedDate, irataExpirationDate
      } = req.body;
      
      // SECURITY: Validate password strength
      const passwordValidation = validatePasswordStrength(password);
      if (!passwordValidation.valid) {
        return res.status(400).json({ message: passwordValidation.message });
      }
      
      // Create employee account linked to company
      // Storage will hash the password
      const employee = await storage.createUser({
        name,
        email,
        role,
        techLevel: role === "rope_access_tech" ? techLevel : null,
        hourlyRate: hourlyRate ? hourlyRate : null,
        isSalary: isSalary ?? false,
        salary: salary ? salary : null,
        permissions: permissions || [],
        companyId, // Link employee to this company
        passwordHash: password, // Storage will hash this
        startDate: startDate || null,
        birthday: birthday || null,
        driversLicenseNumber: driversLicenseNumber || null,
        driversLicenseProvince: driversLicenseProvince || null,
        driversLicenseDocuments: driversLicenseDocuments || [],
        homeAddress: homeAddress || null,
        employeePhoneNumber: employeePhoneNumber || null,
        emergencyContactName: emergencyContactName || null,
        emergencyContactPhone: emergencyContactPhone || null,
        specialMedicalConditions: specialMedicalConditions || null,
        irataLevel: irataLevel || null,
        irataLicenseNumber: irataLicenseNumber || null,
        irataIssuedDate: irataIssuedDate || null,
        irataExpirationDate: irataExpirationDate || null,
      });
      
      const { passwordHash: _, ...employeeWithoutPassword } = employee;
      res.json({ employee: employeeWithoutPassword });
    } catch (error: any) {
      console.error("Create employee error:", error);
      
      // Check for duplicate email (Postgres unique constraint violation)
      if (error && typeof error === 'object' && error.code === '23505' && error.constraint?.includes('email')) {
        return res.status(409).json({ message: "Email address is already in use" });
      }
      
      res.status(500).json({ message: "Failed to create employee" });
    }
  });
  
  // Update employee
  app.patch("/api/employees/:id", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the employee to verify they belong to this company
      const employee = await storage.getUserById(req.params.id);
      
      // Allow if: employee belongs to company (primary or secondary) OR user is editing themselves
      const isOwnProfile = req.params.id === currentUser.id;
      const membership = employee ? await storage.checkEmployeeBelongsToCompany(employee.id, companyId) : { belongs: false };
      
      if (!employee || (!membership.belongs && !isOwnProfile)) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const { 
        name, email, role, techLevel, hourlyRate, isSalary, salary, permissions,
        startDate, birthday, driversLicenseNumber, driversLicenseProvince, driversLicenseDocuments,
        homeAddress, employeePhoneNumber, emergencyContactName, emergencyContactPhone,
        specialMedicalConditions, irataLevel, irataLicenseNumber, irataIssuedDate, 
        irataExpirationDate, terminatedDate, terminationReason, terminationNotes
      } = req.body;
      
      // Check if permissions or role changed, or if employee is being terminated
      const permissionsChanged = JSON.stringify(permissions || []) !== JSON.stringify(employee.permissions || []);
      const roleChanged = role !== undefined && role !== employee.role;
      const isBeingTerminated = terminatedDate !== undefined && terminatedDate !== null && !employee.terminatedDate;
      
      // For secondary connections (PLUS technicians), handle termination separately
      if (isBeingTerminated && membership.connectionType === 'secondary') {
        // Use the termination helper which handles secondary connections
        await storage.terminateEmployeeConnection(req.params.id, companyId, terminationReason, terminationNotes);
        
        // Notify the technician
        await wsHub.terminateUser(req.params.id);
        
        // Return the employee data (they still exist, just disconnected from this company)
        const { passwordHash: _, ...employeeWithoutPassword } = employee;
        return res.json({ employee: { ...employeeWithoutPassword, connectionTerminated: true } });
      }
      
      // Update employee (for primary connections or non-termination updates)
      const updatedEmployee = await storage.updateUser(req.params.id, {
        name,
        email,
        role,
        techLevel: role === "rope_access_tech" ? techLevel : null,
        hourlyRate: hourlyRate ? hourlyRate : null,
        isSalary: isSalary !== undefined ? isSalary : undefined,
        salary: salary !== undefined ? (salary ? salary : null) : undefined,
        permissions: permissions || [],
        startDate: startDate !== undefined ? (startDate || null) : undefined,
        birthday: birthday !== undefined ? (birthday || null) : undefined,
        driversLicenseNumber: driversLicenseNumber !== undefined ? (driversLicenseNumber || null) : undefined,
        driversLicenseProvince: driversLicenseProvince !== undefined ? (driversLicenseProvince || null) : undefined,
        driversLicenseDocuments: driversLicenseDocuments !== undefined ? (driversLicenseDocuments || []) : undefined,
        homeAddress: homeAddress !== undefined ? (homeAddress || null) : undefined,
        employeePhoneNumber: employeePhoneNumber !== undefined ? (employeePhoneNumber || null) : undefined,
        emergencyContactName: emergencyContactName !== undefined ? (emergencyContactName || null) : undefined,
        emergencyContactPhone: emergencyContactPhone !== undefined ? (emergencyContactPhone || null) : undefined,
        specialMedicalConditions: specialMedicalConditions !== undefined ? (specialMedicalConditions || null) : undefined,
        irataLevel: irataLevel !== undefined ? (irataLevel || null) : undefined,
        irataLicenseNumber: irataLicenseNumber !== undefined ? (irataLicenseNumber || null) : undefined,
        irataIssuedDate: irataIssuedDate !== undefined ? (irataIssuedDate || null) : undefined,
        irataExpirationDate: irataExpirationDate !== undefined ? (irataExpirationDate || null) : undefined,
        terminatedDate: terminatedDate !== undefined ? (terminatedDate || null) : undefined,
        terminationReason: terminationReason !== undefined ? (terminationReason || null) : undefined,
        terminationNotes: terminationNotes !== undefined ? (terminationNotes || null) : undefined,
      });
      
      // Send real-time notifications for permission/role changes or termination
      if (isBeingTerminated) {
        // User is being terminated - invalidate their session and notify
        await wsHub.terminateUser(req.params.id);
      } else if (permissionsChanged || roleChanged) {
        // Permissions or role changed - notify user to refresh their session
        await wsHub.updateUserPermissions(req.params.id);
      }
      
      const { passwordHash: _, ...employeeWithoutPassword } = updatedEmployee;
      res.json({ employee: employeeWithoutPassword });
    } catch (error: any) {
      console.error("Update employee error:", error);
      
      // Check for duplicate email (Postgres unique constraint violation)
      if (error && typeof error === 'object' && error.code === '23505' && error.constraint?.includes('email')) {
        return res.status(409).json({ message: "Email address is already in use" });
      }
      
      res.status(500).json({ message: "Failed to update employee" });
    }
  });
  
  // Reactivate employee
  app.post("/api/employees/:id/reactivate", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the employee to verify they belong to this company (primary or secondary)
      const employee = await storage.getUserById(req.params.id);
      const membership = employee ? await storage.checkEmployeeBelongsToCompany(employee.id, companyId) : { belongs: false };
      
      if (!employee || !membership.belongs) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Reactivate employee - handle both primary and secondary connections
      let updatedEmployee = employee;
      if (membership.connectionType === 'secondary' && membership.connectionId) {
        // Reactivate secondary connection
        await db.update(technicianEmployerConnections)
          .set({ status: "active", terminatedAt: null })
          .where(eq(technicianEmployerConnections.id, membership.connectionId));
      } else {
        // Reactivate primary connection
        updatedEmployee = await storage.updateUser(req.params.id, {
          terminatedDate: null,
          terminationReason: null,
          terminationNotes: null,
        });
      }
      
      const { passwordHash: _, ...employeeWithoutPassword } = updatedEmployee;
      res.json({ employee: employeeWithoutPassword });
    } catch (error) {
      console.error("Reactivate employee error:", error);
      res.status(500).json({ message: "Failed to reactivate employee" });
    }
  });
  
  // Change employee password (company owner only) - SECURITY: Rate limited
  app.patch("/api/employees/:id/change-password", requireAuth, requireRole("company"), passwordChangeRateLimiter, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the employee to verify they belong to this company
      const employee = await storage.getUserById(req.params.id);
      
      if (!employee || employee.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Prevent changing other company owners' passwords
      if (employee.role === "company" && employee.id !== currentUser.id) {
        return res.status(403).json({ message: "Cannot change another company owner's password" });
      }
      
      // SECURITY: Prevent employers from changing rope access technician passwords
      // Technicians own their own accounts through the Technician Portal
      if (employee.role === "rope_access_tech") {
        return res.status(403).json({ message: "Cannot change password for rope access technicians. They manage their own accounts." });
      }
      
      const { newPassword } = req.body;
      
      // SECURITY: Validate password strength
      if (!newPassword || typeof newPassword !== "string") {
        return res.status(400).json({ message: "Password is required" });
      }
      const passwordValidation = validatePasswordStrength(newPassword);
      if (!passwordValidation.valid) {
        return res.status(400).json({ message: passwordValidation.message });
      }
      
      // Hash new password
      const passwordHash = await bcrypt.hash(newPassword, 10);
      
      // Update employee password
      await storage.updateUser(req.params.id, {
        passwordHash,
      });
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });
  
  // Remove employee from team (unlink, don't delete - technician accounts persist)
  app.delete("/api/employees/:id", requireAuth, requireRole("company", "admin", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the employee to verify they belong to this company
      const employee = await storage.getUserById(req.params.id);
      
      if (!employee) {
        return res.status(404).json({ message: "Employee not found" });
      }
      
      if (employee.companyId !== companyId) {
        return res.status(403).json({ message: "This employee does not belong to your company" });
      }
      
      // IMPORTANT: Don't delete the user - just unlink them from the company
      // Self-registered technicians keep their accounts and can be invited by other companies
      await storage.updateUser(req.params.id, { 
        companyId: null,
        terminatedDate: null,
        terminationReason: null,
        terminationNotes: null
      });
      
      console.log(`[Team] Employee ${employee.name} (${req.params.id}) unlinked from company ${companyId} - account preserved`);
      
      res.json({ message: "Employee removed from team" });
    } catch (error) {
      console.error("Remove employee error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all employees
  // Get all employees including terminated (company only)
  app.get("/api/employees/all", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get all employees for this company (including terminated)
      const employees = await storage.getAllEmployees(currentUser.id);
      
      // Get the company owner as well (currentUser is the company owner)
      const companyOwner = currentUser;
      
      // Combine company owner and employees
      const allUsers = [companyOwner, ...employees];
      
      // Remove passwords from response
      const employeesWithoutPasswords = allUsers.map(emp => {
        const { passwordHash, ...empWithoutPassword } = emp;
        return empWithoutPassword;
      });
      
      // Calculate seat usage using new subscription system
      const activeEmployeeCount = employees.filter(emp => !emp.terminatedDate).length;
      const limitsCheck = await checkSubscriptionLimits(currentUser.id);
      const tier = companyOwner.subscriptionTier || 'none';
      const paidSeats = companyOwner.additionalSeatsCount || 0;
      const giftedSeats = companyOwner.giftedSeatsCount || 0;
      const totalAdditionalSeats = paidSeats + giftedSeats;
      const seatLimit = limitsCheck.limits.maxSeats;
      // baseSeatLimit is always 2 (the free included seats), not derived from seatLimit
      const baseSeatLimit = 2;
      
      res.json({ 
        employees: employeesWithoutPasswords,
        seatInfo: {
          tier,
          seatLimit,
          baseSeatLimit,
          paidSeats,
          giftedSeats,
          additionalSeats: totalAdditionalSeats,
          seatsUsed: activeEmployeeCount,
          seatsAvailable: seatLimit === -1 ? -1 : Math.max(0, seatLimit - activeEmployeeCount),
          atSeatLimit: seatLimit === 0 || (seatLimit > 0 && activeEmployeeCount >= seatLimit)
        }
      });
    } catch (error) {
      console.error("Get all employees error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get active employees (excludes terminated) - for general use
  app.get("/api/employees", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get company ID (company themselves or the employee's company)
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get employees for this company only
      const employees = await storage.getAllEmployees(companyId);
      
      // Get the company owner as well
      const companyOwner = await storage.getUserById(companyId);
      
      // Combine employees and company owner
      const allUsers = companyOwner ? [companyOwner, ...employees] : employees;
      
      // Filter out terminated employees and remove passwords from response
      const activeEmployees = allUsers
        .filter(emp => !emp.terminatedDate)
        .map(emp => {
          const { passwordHash, ...empWithoutPassword } = emp;
          return empWithoutPassword;
        });
      
      // Calculate seat usage using new subscription system
      const employeeCount = employees.filter(emp => !emp.terminatedDate).length;
      const limitsCheck = await checkSubscriptionLimits(companyId);
      const tier = companyOwner?.subscriptionTier || 'none';
      const paidSeats = companyOwner?.additionalSeatsCount || 0;
      const giftedSeats = companyOwner?.giftedSeatsCount || 0;
      const totalAdditionalSeats = paidSeats + giftedSeats;
      const seatLimit = limitsCheck.limits.maxSeats;
      // baseSeatLimit is always 2 (the free included seats), not derived from seatLimit
      const baseSeatLimit = 2;
      
      res.json({ 
        employees: activeEmployees,
        seatInfo: {
          tier,
          seatLimit,
          baseSeatLimit,
          paidSeats,
          giftedSeats,
          additionalSeats: totalAdditionalSeats,
          seatsUsed: employeeCount,
          seatsAvailable: seatLimit === -1 ? -1 : Math.max(0, seatLimit - employeeCount),
          atSeatLimit: seatLimit === 0 || (seatLimit > 0 && employeeCount >= seatLimit)
        }
      });
    } catch (error) {
      console.error("Get employees error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== ONROPEPRO TECHNICIAN LINKING ====================
  
  // Search for technicians (including PLUS members who can link to multiple companies)
  app.get("/api/technicians/search", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const { searchType, searchValue } = req.query;
      
      if (!searchType || !searchValue) {
        return res.status(400).json({ message: "Search type and value are required" });
      }
      
      if (!['irata', 'sprat', 'email'].includes(searchType as string)) {
        return res.status(400).json({ message: "Invalid search type. Must be 'irata', 'sprat', or 'email'" });
      }
      
      const searchVal = (searchValue as string).trim();
      if (!searchVal) {
        return res.status(400).json({ message: "Search value cannot be empty" });
      }
      
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      // Search for ANY technician (including already linked ones for PLUS access)
      let technician = null;
      
      if (searchType === 'email') {
        technician = await storage.getTechnicianByEmail(searchVal);
      } else if (searchType === 'irata') {
        technician = await storage.getTechnicianByIrataLicense(searchVal);
      } else if (searchType === 'sprat') {
        technician = await storage.getTechnicianBySpratLicense(searchVal);
      }
      
      if (!technician) {
        return res.json({ found: false, message: "No technician found with that information" });
      }
      
      // Check if technician is already linked to THIS company
      if (technician.companyId === companyId) {
        return res.json({ found: false, message: "This technician is already linked to your company" });
      }
      
      // Check existing employer connections for THIS company
      const existingConnections = technician.employerConnections || [];
      const alreadyConnected = existingConnections.some((conn: any) => conn.companyId === companyId);
      if (alreadyConnected) {
        return res.json({ found: false, message: "This technician is already connected to your company" });
      }
      
      // Technicians are visible to employers if they have visibility toggle on
      // OR if they have PLUS access (which allows multi-employer connections)
      const isVisible = technician.isVisibleToEmployers || technician.hasPlusAccess;
      
      // If technician is linked to another company, doesn't have PLUS, AND hasn't enabled visibility
      if (technician.companyId && !technician.hasPlusAccess && !technician.isVisibleToEmployers) {
        return res.json({ 
          found: false, 
          message: "This technician is not currently visible to employers. They need to enable their visibility toggle or have Technician PLUS." 
        });
      }
      
      // Return limited info for privacy (don't expose sensitive fields)
      const { passwordHash, socialInsuranceNumber, bankTransitNumber, bankInstitutionNumber, 
              bankAccountNumber, driversLicenseNumber, specialMedicalConditions, ...safeInfo } = technician;
      
      // Check if technician is linked to another employer AND has visibility on
      // This means their current employer can see they're advertising to other companies
      const hasEmployerVisibilityWarning = !!technician.companyId && technician.isVisibleToEmployers;
      
      res.json({ 
        found: true, 
        technician: {
          id: safeInfo.id,
          name: safeInfo.name,
          email: safeInfo.email,
          irataLevel: safeInfo.irataLevel,
          irataLicenseNumber: safeInfo.irataLicenseNumber,
          spratLevel: safeInfo.spratLevel,
          spratLicenseNumber: safeInfo.spratLicenseNumber,
          employeeCity: safeInfo.employeeCity,
          employeeProvinceState: safeInfo.employeeProvinceState,
          hasFirstAid: safeInfo.hasFirstAid,
          firstAidType: safeInfo.firstAidType,
          hasPlusAccess: safeInfo.hasPlusAccess,
          isAlreadyLinked: !!technician.companyId,
          isVisibleToEmployers: technician.isVisibleToEmployers,
        },
        warning: hasEmployerVisibilityWarning 
          ? "This technician is currently employed and has their employer visibility turned on. Their current employer may be aware they are visible to other companies."
          : null
      });
    } catch (error) {
      console.error("Search technicians error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Link an existing OnRopePro technician to a company
  app.post("/api/technicians/:technicianId/link", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const { technicianId } = req.params;
      const { hourlyRate, isSalary, salary } = req.body;
      
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check seat limits before linking
      const limitsCheck = await checkSubscriptionLimits(companyId);
      const employees = await storage.getAllEmployees(companyId);
      const activeEmployeeCount = employees.filter(emp => !emp.terminatedDate).length;
      
      if (limitsCheck.limits.maxSeats > 0 && activeEmployeeCount >= limitsCheck.limits.maxSeats) {
        return res.status(400).json({ message: "Seat limit reached. Please upgrade your subscription or add more seats." });
      }
      
      // Find the technician or ground crew member
      const technician = await storage.getUserById(technicianId);
      if (!technician) {
        return res.status(404).json({ message: "Team member not found" });
      }
      
      const LINKABLE_ROLES = ['rope_access_tech', 'ground_crew'];
      if (!LINKABLE_ROLES.includes(technician.role)) {
        return res.status(400).json({ message: "This user cannot be linked to a company" });
      }
      
      // Check if already linked to THIS company
      if (technician.companyId === companyId) {
        return res.status(400).json({ message: "This team member is already linked to your company" });
      }
      
      // Check existing employer connections
      const existingConnections = (technician.employerConnections || []) as any[];
      const alreadyConnected = existingConnections.some((conn: any) => conn.companyId === companyId);
      if (alreadyConnected) {
        return res.status(400).json({ message: "This team member is already connected to your company" });
      }
      
      // Get company name for the connection
      const companyOwner = await storage.getUserById(companyId);
      const companyName = companyOwner?.companyName || 'Unknown Company';
      
      if (technician.companyId) {
        // Technician is already linked to another company
        if (!technician.hasPlusAccess) {
          return res.status(400).json({ 
            message: "This technician is already linked to another company. They need Technician PLUS to connect with multiple employers." 
          });
        }
        
        // PLUS technician - add via employer_connections
        const newConnection = {
          companyId,
          companyName,
          hourlyRate: hourlyRate || null,
          isSalary: isSalary || false,
          salary: salary || null,
          connectedAt: new Date().toISOString(),
        };
        
        const updatedConnections = [...existingConnections, newConnection];
        await storage.updateUser(technicianId, {
          employerConnections: updatedConnections,
        });
        
        console.log(`[Technician-Link] PLUS technician ${technicianId} (${technician.name}) connected to additional employer ${companyId} (${companyName})`);
        
        res.json({ 
          success: true, 
          message: `${technician.name} has been connected to your company as an additional employer!` 
        });
      } else {
        // Unlinked technician - set as primary company
        await storage.updateUser(technicianId, {
          companyId,
          hourlyRate: hourlyRate || null,
          isSalary: isSalary || false,
          salary: salary || null,
          startDate: getTodayString(),
        });
        
        console.log(`[Technician-Link] Linked technician ${technicianId} (${technician.name}) to company ${companyId}`);
        
        res.json({ 
          success: true, 
          message: `${technician.name} has been added to your team!` 
        });
      }
    } catch (error) {
      console.error("Link technician error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== TEAM INVITATIONS ====================
  
  // Send an invitation to a technician to join the company team
  app.post("/api/technicians/:technicianId/invite", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const { technicianId } = req.params;
      const { message } = req.body;
      
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check seat limits before inviting
      const limitsCheck = await checkSubscriptionLimits(companyId);
      const employees = await storage.getAllEmployees(companyId);
      const activeEmployeeCount = employees.filter(emp => !emp.terminatedDate).length;
      
      if (limitsCheck.limits.maxSeats > 0 && activeEmployeeCount >= limitsCheck.limits.maxSeats) {
        return res.status(400).json({ message: "Seat limit reached. Please upgrade your subscription or add more seats." });
      }
      
      // Find the technician or ground crew member
      const technician = await storage.getUserById(technicianId);
      if (!technician) {
        return res.status(404).json({ message: "Team member not found" });
      }
      
      const INVITABLE_ROLES = ['rope_access_tech', 'ground_crew'];
      if (!INVITABLE_ROLES.includes(technician.role)) {
        return res.status(400).json({ message: "This user cannot be invited to a company" });
      }
      
      // Check if already linked to THIS company
      if (technician.companyId === companyId) {
        return res.status(400).json({ message: "This team member is already linked to your company" });
      }
      
      // Check existing employer connections
      const existingConnections = (technician.employerConnections || []) as any[];
      const alreadyConnected = existingConnections.some((conn: any) => conn.companyId === companyId);
      if (alreadyConnected) {
        return res.status(400).json({ message: "This team member is already connected to your company" });
      }
      
      // If linked to another company, require PLUS access
      if (technician.companyId && !technician.hasPlusAccess) {
        return res.status(400).json({ 
          message: "This technician is already linked to another company. They need Technician PLUS to connect with multiple employers." 
        });
      }
      
      // Check if there's already a pending invitation
      const existingInvitation = await storage.getPendingInvitationForTechnicianAndCompany(technicianId, companyId);
      if (existingInvitation) {
        return res.status(400).json({ message: "An invitation has already been sent to this technician" });
      }
      
      // Create the invitation
      const invitation = await storage.createTeamInvitation({
        technicianId,
        companyId,
        invitedBy: currentUser.id,
        status: "pending",
        message: message || null,
      });
      
      
      console.log(`[Team-Invite] Company ${companyId} sent invitation ${invitation.id} to technician ${technicianId} (${technician.name})`);
      
      // Handle both camelCase and snake_case field names from Drizzle ORM
      const techAny = technician as any;
      const technicianPhone = techAny.employeePhoneNumber || techAny.employee_phone_number;
      const smsEnabled = techAny.smsNotificationsEnabled ?? techAny.sms_notifications_enabled;
      
      // Debug info for response
      const debugInfo = {
        technicianId,
        technicianName: technician.name,
        rawPhoneField: technicianPhone,
        rawSmsEnabled: smsEnabled,
        invitationId: invitation.id,
        timestamp: new Date().toISOString()
      };
      
      console.log(`[Team-Invite] DEBUG: raw fields - phone=${technicianPhone}, smsEnabled=${smsEnabled}`);
      
      let smsStatus = 'not_attempted';
      let smsError: string | null = null;
      
      if (smsEnabled && technicianPhone) {
        try {
          const company = await storage.getUserById(companyId);
          const companyName = company?.companyName || 'An employer';
          console.log(`[Team-Invite] Sending SMS to ${technicianPhone} from company ${companyName}`);
          const smsResult = await sendTeamInvitationSMS(
            technicianPhone,
            companyName
          );
          if (smsResult.success) {
            console.log(`[Team-Invite] SMS notification sent to ${technician.name}, SID: ${smsResult.messageId}`);
            smsStatus = 'sent';
            (debugInfo as any).twilioMessageSid = smsResult.messageId;
            (debugInfo as any).twilioFormattedTo = (smsResult as any).formattedTo;
            (debugInfo as any).twilioStatus = (smsResult as any).status;
          } else {
            console.log(`[Team-Invite] SMS notification failed for ${technician.name}: ${smsResult.error}`);
            smsStatus = 'failed';
            smsError = smsResult.error || null;
          }
        } catch (smsErr: any) {
          console.error(`[Team-Invite] SMS notification error for ${technician.name}:`, smsErr);
          smsStatus = 'error';
          smsError = smsErr.message;
        }
      } else if (!smsEnabled) {
        console.log(`[Team-Invite] SMS disabled for ${technician.name}, skipping SMS`);
        smsStatus = 'skipped_disabled';
      } else {
        console.log(`[Team-Invite] No phone number for ${technician.name}, skipping SMS`);
        smsStatus = 'skipped_no_phone';
      }
      
      res.json({
        success: true, 
        message: `Invitation sent to ${technician.name}!`,
        invitationId: invitation.id,
        debug: {
          ...debugInfo,
          smsStatus,
          smsError
        }
      });
    } catch (error) {
      console.error("Send team invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // Get the count of technicians referred by the logged-in user
  app.get("/api/my-referral-count", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can view referral count" });
      }
      
      const count = await storage.getReferralCount(user.id);
      return res.json({ count });
    } catch (error) {
      console.error('[Referral] Error getting referral count:', error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get list of users referred by the logged-in user
  app.get("/api/my-referrals", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Allow technicians and company owners to see their referrals
      if (user.role !== 'rope_access_tech' && user.role !== 'company') {
        return res.status(403).json({ message: "Only technicians and company owners can view referrals" });
      }
      
      const referrals = await storage.getReferredUsers(user.id);
      return res.json({ referrals });
    } catch (error) {
      console.error('[Referral] Error getting referrals:', error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== DOCUMENT REQUEST ROUTES ====================
  
  // Multer config for document request file uploads (any file type allowed)
  const documentRequestUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 25 * 1024 * 1024 }, // 25MB max per file
  });
  
  // Employer creates a document request for a technician
  app.post("/api/technicians/:techId/document-requests", requireAuth, async (req: Request, res: Response) => {
    try {
      const { techId } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only company role can create document requests
      if (currentUser.role !== 'company') {
        return res.status(403).json({ message: "Only employers can create document requests" });
      }
      
      const companyId = currentUser.id;
      
      // Check if there's an active connection between this company and technician
      const connections = await db.select().from(technicianEmployerConnections)
        .where(and(
          eq(technicianEmployerConnections.technicianId, techId),
          eq(technicianEmployerConnections.companyId, companyId),
          eq(technicianEmployerConnections.status, 'active')
        ));
      
      if (connections.length === 0) {
        return res.status(403).json({ message: "No active connection with this technician" });
      }
      
      const connection = connections[0];
      
      // Validate request body
      const { title, details } = req.body;
      if (!title || typeof title !== 'string' || title.trim().length === 0) {
        return res.status(400).json({ message: "Title is required" });
      }
      
      // Create the document request
      const request = await storage.createDocumentRequest({
        companyId,
        technicianId: techId,
        connectionId: connection.id,
        requestedById: currentUser.id,
        title: title.trim(),
        details: details?.trim() || null,
        status: 'pending',
      });
      
      // Create notification for the technician
      await db.insert(notifications).values({
        companyId: techId,
        actorId: currentUser.id,
        type: 'document_request',
        payload: { 
          requestId: request.id, 
          employerId: companyId, 
          employerName: currentUser.companyName || 'An employer',
          title: title.trim() 
        },
      });
      
      console.log(`[DocRequest] Company ${companyId} created request ${request.id} for technician ${techId}`);
      
      res.status(201).json(request);
    } catch (error) {
      console.error("Create document request error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Technician gets their document requests (with files)
  app.get("/api/technicians/me/document-requests", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can view their document requests" });
      }
      
      const requests = await storage.getDocumentRequestsByTechnician(user.id);
      
      // Fetch files and company info for each request
      const requestsWithDetails = await Promise.all(requests.map(async (request) => {
        const files = await storage.getDocumentRequestFiles(request.id);
        const company = await storage.getUserById(request.companyId);
        return {
          ...request,
          files,
          company: company ? {
            id: company.id,
            name: company.companyName || company.name,
          } : null,
        };
      }));
      
      res.json({ requests: requestsWithDetails });
    } catch (error) {
      console.error("Get technician document requests error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Employer gets document requests they've sent (by company)
  app.get("/api/companies/:companyId/document-requests", requireAuth, async (req: Request, res: Response) => {
    try {
      const { companyId } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only allow company to view their own requests
      if (currentUser.role !== 'company' || currentUser.id !== companyId) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      
      const requests = await storage.getDocumentRequestsByCompany(companyId);
      
      // Fetch files and technician info for each request
      const requestsWithDetails = await Promise.all(requests.map(async (request) => {
        const files = await storage.getDocumentRequestFiles(request.id);
        const technician = await storage.getUserById(request.technicianId);
        return {
          ...request,
          files,
          technician: technician ? {
            id: technician.id,
            name: technician.name,
            email: technician.email,
          } : null,
        };
      }));
      
      res.json({ requests: requestsWithDetails });
    } catch (error) {
      console.error("Get company document requests error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Technician uploads files to a document request
  app.post("/api/technicians/document-requests/:id/files", requireAuth, documentRequestUpload.array('files', 10), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can upload files to document requests" });
      }
      
      // Get the request and verify it belongs to this technician
      const request = await storage.getDocumentRequestById(id);
      if (!request) {
        return res.status(404).json({ message: "Document request not found" });
      }
      
      if (request.technicianId !== user.id) {
        return res.status(403).json({ message: "This request does not belong to you" });
      }
      
      if (request.status !== 'pending') {
        return res.status(400).json({ message: "This request has already been fulfilled or cancelled" });
      }
      
      const files = req.files as Express.Multer.File[];
      if (!files || files.length === 0) {
        return res.status(400).json({ message: "No files uploaded" });
      }
      
      const uploadedFiles = [];
      const objectStorageService = new ObjectStorageService();
      for (const file of files) {
        // Upload to object storage
        const storageKey = `document-requests/${id}/${Date.now()}-${file.originalname}`;
        await objectStorageService.uploadPublicFile(storageKey, file.buffer, file.mimetype);
        
        // Create file record
        const fileRecord = await storage.createDocumentRequestFile({
          requestId: id,
          storageKey,
          fileName: file.originalname,
          fileSize: file.size,
          fileType: file.mimetype,
          uploadedById: user.id,
        });
        
        uploadedFiles.push(fileRecord);
      }
      
      console.log(`[DocRequest] Technician ${user.id} uploaded ${files.length} files to request ${id}`);
      
      res.status(201).json({ files: uploadedFiles });
    } catch (error) {
      console.error("Upload document request files error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Technician marks a document request as fulfilled
  app.patch("/api/technicians/document-requests/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { status, responseNote } = req.body;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can update their document requests" });
      }
      
      // Get the request and verify ownership
      const request = await storage.getDocumentRequestById(id);
      if (!request) {
        return res.status(404).json({ message: "Document request not found" });
      }
      
      if (request.technicianId !== user.id) {
        return res.status(403).json({ message: "This request does not belong to you" });
      }
      
      if (request.status !== 'pending') {
        return res.status(400).json({ message: "This request has already been fulfilled or cancelled" });
      }
      
      // Validate status
      if (status !== 'fulfilled') {
        return res.status(400).json({ message: "Invalid status. Only 'fulfilled' is allowed." });
      }
      
      // Check if at least one file has been uploaded
      const files = await storage.getDocumentRequestFiles(id);
      if (files.length === 0) {
        return res.status(400).json({ message: "You must upload at least one file before marking as fulfilled" });
      }
      
      // Update the request
      const updated = await storage.updateDocumentRequest(id, {
        status: 'fulfilled',
        responseNote: responseNote?.trim() || null,
        respondedAt: new Date(),
      });
      
      // Create notification for the employer
      await db.insert(notifications).values({
        companyId: request.companyId,
        actorId: user.id,
        type: 'document_request_fulfilled',
        payload: { 
          requestId: id, 
          technicianId: user.id,
          technicianName: user.name || 'A technician',
          title: request.title 
        },
      });
      
      console.log(`[DocRequest] Technician ${user.id} fulfilled request ${id}`);
      
      res.json(updated);
    } catch (error) {
      console.error("Update document request error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Secure file download endpoint
  app.get("/api/document-request-files/:id/download", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the file record
      const fileRecord = await storage.getDocumentRequestFileById(id);
      if (!fileRecord) {
        return res.status(404).json({ message: "File not found" });
      }
      
      // Get the parent request to check authorization
      const request = await storage.getDocumentRequestById(fileRecord.requestId);
      if (!request) {
        return res.status(404).json({ message: "Document request not found" });
      }
      
      // Only allow the technician or users from the requesting company to download
      const isTechnician = user.id === request.technicianId;
      const isCompanyOwner = user.id === request.companyId;
      const isCompanyEmployee = user.companyId === request.companyId;
      
      if (!isTechnician && !isCompanyOwner && !isCompanyEmployee) {
        return res.status(403).json({ message: "Unauthorized to download this file" });
      }
      
      // Fetch the file from object storage
      const objectStorageService = new ObjectStorageService();
      const file = await objectStorageService.searchPublicObject(fileRecord.storageKey);
      if (!file) {
        return res.status(404).json({ message: "File not found in storage" });
      }
      
      // Set download disposition header
      res.setHeader('Content-Disposition', `attachment; filename="${fileRecord.fileName}"`);
      
      // Stream the file to the response
      await objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error("Download document request file error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get pending invitations for the logged-in technician
  app.get("/api/my-invitations", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can view invitations" });
      }
      
      const invitations = await storage.getPendingInvitationsForTechnician(user.id);
      
      // Return limited company info for privacy
      const safeInvitations = invitations.map(inv => ({
        id: inv.id,
        message: inv.message,
        createdAt: inv.createdAt,
        company: {
          id: inv.company.id,
          name: inv.company.companyName || inv.company.name,
          email: inv.company.email,
        }
      }));
      
      res.json({ invitations: safeInvitations });
    } catch (error) {
      console.error("Get my invitations error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Accept a team invitation
  app.post("/api/invitations/:invitationId/accept", requireAuth, async (req: Request, res: Response) => {
    try {
      const { invitationId } = req.params;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const invitation = await storage.getTeamInvitationById(invitationId);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      
      // Verify the invitation is for this technician
      if (invitation.technicianId !== user.id) {
        return res.status(403).json({ message: "This invitation is not for you" });
      }
      
      if (invitation.status !== "pending") {
        return res.status(400).json({ message: "This invitation has already been processed" });
      }
      
      // Check if technician is already linked to an ACTIVE company
      // Self-resigned technicians (with terminatedDate) can still accept new invitations
      const hasActiveEmployer = user.companyId && !user.terminatedDate;
      
      // PLUS members can link to multiple employers
      if (hasActiveEmployer && !user.hasPlusAccess) {
        return res.status(400).json({ message: "You are already linked to a company. Upgrade to PLUS to connect with multiple employers." });
      }
      
      // Check if already connected to this specific company
      if (hasActiveEmployer) {
        const existingConnection = await db.select().from(technicianEmployerConnections)
          .where(and(
            eq(technicianEmployerConnections.technicianId, user.id),
            eq(technicianEmployerConnections.companyId, invitation.companyId),
            eq(technicianEmployerConnections.status, "active")
          )).limit(1);
        
        if (existingConnection.length > 0 || user.companyId === invitation.companyId) {
          return res.status(400).json({ message: "You are already connected to this employer" });
        }
      }
      
      // Accept the invitation and link the technician
      await storage.acceptTeamInvitation(invitationId);
      
      const company = await storage.getUserById(invitation.companyId);
      const companyName = company?.companyName || company?.name || "the company";
      
      // For PLUS members with existing employer, create a connection record
      if (hasActiveEmployer && user.hasPlusAccess) {
        // Create a new employer connection
        await db.insert(technicianEmployerConnections).values({
          technicianId: user.id,
          companyId: invitation.companyId,
          isPrimary: false,
          status: "active",
          invitationId: invitationId,
        });
        
        console.log(`[Team-Invite] PLUS member ${user.id} (${user.name}) added secondary employer ${invitation.companyId} via invitation ${invitationId}`);
        
        // Send SMS to company owner about acceptance
        if (company) {
          const companyAny = company as any;
          const ownerPhone = companyAny.employeePhoneNumber || companyAny.employee_phone_number;
          const ownerSmsEnabled = companyAny.smsNotificationsEnabled ?? companyAny.sms_notifications_enabled;
          if (ownerSmsEnabled && ownerPhone) {
            try {
              const smsResult = await sendInvitationAcceptedSMS(ownerPhone, user.name || 'A technician', user.role || 'rope_access_tech');
              if (smsResult.success) {
                console.log(`[Team-Invite] SMS sent to company owner about ${user.name} acceptance`);
              }
            } catch (smsErr) {
              console.error('[Team-Invite] Failed to send acceptance SMS:', smsErr);
            }
          }
        }
      } else {
        // Link the technician to the company and clear any previous termination status
        await storage.updateUser(user.id, {
          companyId: invitation.companyId,
          startDate: getTodayString(),
          terminatedDate: null,
          terminationReason: null,
          terminationNotes: null,
        });
        
        console.log(`[Team-Invite] Technician ${user.id} (${user.name}) accepted invitation ${invitationId} from company ${invitation.companyId}`);
        
        // Send SMS to company owner about acceptance
        if (company) {
          const companyAny = company as any;
          const ownerPhone = companyAny.employeePhoneNumber || companyAny.employee_phone_number;
          const ownerSmsEnabled = companyAny.smsNotificationsEnabled ?? companyAny.sms_notifications_enabled;
          if (ownerSmsEnabled && ownerPhone) {
            try {
              const smsResult = await sendInvitationAcceptedSMS(ownerPhone, user.name || 'A technician', user.role || 'rope_access_tech');
              if (smsResult.success) {
                console.log(`[Team-Invite] SMS sent to company owner about ${user.name} acceptance`);
              }
            } catch (smsErr) {
              console.error('[Team-Invite] Failed to send acceptance SMS:', smsErr);
            }
          }
        }
      }
      
      res.json({ 
        success: true, 
        message: `Welcome to ${companyName}!`,
        companyId: invitation.companyId
      });
    } catch (error) {
      console.error("Accept invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Decline a team invitation
  app.post("/api/invitations/:invitationId/decline", requireAuth, async (req: Request, res: Response) => {
    try {
      const { invitationId } = req.params;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const invitation = await storage.getTeamInvitationById(invitationId);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      
      // Verify the invitation is for this technician
      if (invitation.technicianId !== user.id) {
        return res.status(403).json({ message: "This invitation is not for you" });
      }
      
      if (invitation.status !== "pending") {
        return res.status(400).json({ message: "This invitation has already been processed" });
      }
      
      // Decline the invitation
      await storage.declineTeamInvitation(invitationId);
      
      console.log(`[Team-Invite] Technician ${user.id} (${user.name}) declined invitation ${invitationId}`);
      
      res.json({ 
        success: true, 
        message: "Invitation declined"
      });
    } catch (error) {
      console.error("Decline invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get technician's employer connections (for PLUS members with multiple employers)
  app.get("/api/my-employer-connections", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can view employer connections" });
      }
      
      // Get all employer connections (including suspended, but not terminated)
      // This allows the UI to show suspended employers with appropriate status badges
      const connections = await db.select({
        id: technicianEmployerConnections.id,
        companyId: technicianEmployerConnections.companyId,
        isPrimary: technicianEmployerConnections.isPrimary,
        status: technicianEmployerConnections.status,
        connectedAt: technicianEmployerConnections.connectedAt,
      }).from(technicianEmployerConnections)
        .where(and(
          eq(technicianEmployerConnections.technicianId, user.id),
          or(
            eq(technicianEmployerConnections.status, "active"),
            eq(technicianEmployerConnections.status, "suspended")
          )
        ));
      
      // Get company details for each connection
      const connectionsWithCompanies = await Promise.all(connections.map(async (conn) => {
        const company = await storage.getUserById(conn.companyId);
        return {
          ...conn,
          company: company ? {
            id: company.id,
            name: company.name,
            companyName: company.companyName,
            photoUrl: company.photoUrl,
          } : null
        };
      }));
      
      // Also include the legacy companyId if not in connections table
      // Check suspendedAt to determine if primary employer connection is suspended
      let legacyEmployer = null;
      if (user.companyId && !user.terminatedDate) {
        const hasLegacyInConnections = connections.some(c => c.companyId === user.companyId);
        if (!hasLegacyInConnections) {
          const company = await storage.getUserById(user.companyId);
          if (company) {
            legacyEmployer = {
              id: 'legacy',
              companyId: user.companyId,
              isPrimary: true,
              status: user.suspendedAt ? 'suspended' : 'active',
              connectedAt: user.startDate || new Date(),
              suspendedAt: user.suspendedAt || null,
              company: {
                id: company.id,
                name: company.name,
                companyName: company.companyName,
                photoUrl: company.photoUrl,
              }
            };
          }
        }
      }
      
      const allConnections = legacyEmployer 
        ? [legacyEmployer, ...connectionsWithCompanies]
        : connectionsWithCompanies;
      
      res.json({ 
        connections: allConnections,
        hasPlusAccess: user.hasPlusAccess,
        canAddMore: user.hasPlusAccess === true
      });
    } catch (error) {
      console.error("Get employer connections error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Set primary employer connection
  app.patch("/api/my-employer-connections/:connectionId/set-primary", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (user.role !== 'rope_access_tech' && user.role !== 'ground_crew') {
        return res.status(403).json({ message: "Only technicians can manage employer connections" });
      }
      
      const { connectionId } = req.params;
      
      // Handle legacy connection
      if (connectionId === 'legacy') {
        // For legacy, just update the main companyId - it's already primary
        return res.json({ success: true, message: "Primary employer set" });
      }
      
      // Verify connection belongs to this user
      const connection = await db.select().from(technicianEmployerConnections)
        .where(and(
          eq(technicianEmployerConnections.id, connectionId),
          eq(technicianEmployerConnections.technicianId, user.id)
        )).limit(1);
      
      if (connection.length === 0) {
        return res.status(404).json({ message: "Connection not found" });
      }
      
      // Clear all primary flags for this user
      await db.update(technicianEmployerConnections)
        .set({ isPrimary: false })
        .where(eq(technicianEmployerConnections.technicianId, user.id));
      
      // Set this connection as primary
      await db.update(technicianEmployerConnections)
        .set({ isPrimary: true })
        .where(eq(technicianEmployerConnections.id, connectionId));
      
      // Also update the user's main companyId to this employer
      await storage.updateUser(user.id, {
        companyId: connection[0].companyId
      });
      
      res.json({ success: true, message: "Primary employer set" });
    } catch (error) {
      console.error("Set primary employer error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get accepted invitations that owner hasn't acknowledged yet
  app.get("/api/accepted-invitations", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and admins can view accepted invitations
      if (user.role !== 'owner' && user.role !== 'company' && user.role !== 'admin') {
        return res.status(403).json({ message: "Only owners and admins can view accepted invitations" });
      }
      
      const invitations = await storage.getUnacknowledgedAcceptedInvitationsForCompany(companyId);
      
      // Return full technician info for employee form pre-population
      // Note: Sensitive fields (SIN, bank info) are decrypted by storage layer
      const safeInvitations = invitations.map(inv => ({
        id: inv.id,
        respondedAt: inv.respondedAt,
        technician: {
          id: inv.technician.id,
          name: inv.technician.name,
          email: inv.technician.email,
          // Phone and address
          employeePhoneNumber: inv.technician.employeePhoneNumber,
          smsNotificationsEnabled: inv.technician.smsNotificationsEnabled,
          employeeStreetAddress: inv.technician.employeeStreetAddress,
          employeeCity: inv.technician.employeeCity,
          employeeProvinceState: inv.technician.employeeProvinceState,
          employeeCountry: inv.technician.employeeCountry,
          employeePostalCode: inv.technician.employeePostalCode,
          homeAddress: inv.technician.homeAddress,
          // Personal info
          birthday: inv.technician.birthday,
          // Emergency contact
          emergencyContactName: inv.technician.emergencyContactName,
          emergencyContactPhone: inv.technician.emergencyContactPhone,
          emergencyContactRelationship: inv.technician.emergencyContactRelationship,
          specialMedicalConditions: inv.technician.specialMedicalConditions,
          // IRATA certification
          irataLevel: inv.technician.irataLevel,
          irataLicenseNumber: inv.technician.irataLicenseNumber,
          irataIssuedDate: inv.technician.irataIssuedDate,
          irataExpirationDate: inv.technician.irataExpirationDate,
          irataDocuments: inv.technician.irataDocuments,
          irataVerifiedAt: inv.technician.irataVerifiedAt,
          irataVerificationStatus: inv.technician.irataVerificationStatus,
          // SPRAT certification
          spratLevel: inv.technician.spratLevel,
          spratLicenseNumber: inv.technician.spratLicenseNumber,
          spratIssuedDate: inv.technician.spratIssuedDate,
          spratExpirationDate: inv.technician.spratExpirationDate,
          spratDocuments: inv.technician.spratDocuments,
          spratVerifiedAt: inv.technician.spratVerifiedAt,
          spratVerificationStatus: inv.technician.spratVerificationStatus,
          // First Aid certification
          hasFirstAid: inv.technician.hasFirstAid,
          firstAidType: inv.technician.firstAidType,
          firstAidExpiry: inv.technician.firstAidExpiry,
          firstAidDocuments: inv.technician.firstAidDocuments,
          // Driver's license
          driversLicenseNumber: inv.technician.driversLicenseNumber,
          driversLicenseProvince: inv.technician.driversLicenseProvince,
          driversLicenseExpiry: inv.technician.driversLicenseExpiry,
          driversLicenseDocuments: inv.technician.driversLicenseDocuments,
          // Bank info (encrypted - decrypted by storage)
          bankTransitNumber: inv.technician.bankTransitNumber,
          bankInstitutionNumber: inv.technician.bankInstitutionNumber,
          bankAccountNumber: inv.technician.bankAccountNumber,
          bankDocuments: inv.technician.bankDocuments,
          // SIN (encrypted - decrypted by storage)
          socialInsuranceNumber: inv.technician.socialInsuranceNumber,
          // Photo
          photoUrl: inv.technician.photoUrl,
        }
      }));
      
      res.json({ invitations: safeInvitations });
    } catch (error) {
      console.error("Get accepted invitations error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get pending onboarding invitations (acknowledged but not converted - technician has no hourlyRate)
  // Get pending invitations SENT by this company (not yet responded)
  app.get("/api/sent-invitations", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and authorized roles can view sent invitations
      const authorizedRoles = ['owner', 'company', 'admin', 'operations_manager'];
      if (!authorizedRoles.includes(user.role)) {
        return res.status(403).json({ message: "Only authorized users can view sent invitations" });
      }
      
      const invitations = await storage.getPendingSentInvitationsForCompany(companyId);
      
      const safeInvitations = invitations.map(inv => ({
        id: inv.id,
        createdAt: inv.createdAt,
        message: inv.message,
        technician: {
          id: inv.technician.id,
          name: inv.technician.name,
          email: inv.technician.email,
          employeePhoneNumber: inv.technician.employeePhoneNumber,
          role: inv.technician.role,
        }
      }));
      
      res.json({ invitations: safeInvitations });
    } catch (error) {
      console.error("Get sent invitations error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Cancel a pending invitation
  app.delete("/api/sent-invitations/:invitationId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { invitationId } = req.params;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and authorized roles can cancel invitations
      const authorizedRoles = ['owner', 'company', 'admin', 'operations_manager'];
      if (!authorizedRoles.includes(user.role)) {
        return res.status(403).json({ message: "Only authorized users can cancel invitations" });
      }
      
      // Verify the invitation exists and belongs to this company
      const invitation = await storage.getTeamInvitationById(invitationId);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      
      if (invitation.companyId !== companyId) {
        return res.status(403).json({ message: "You can only cancel your own company's invitations" });
      }
      
      if (invitation.status !== 'pending') {
        return res.status(400).json({ message: "Only pending invitations can be cancelled" });
      }
      
      await storage.cancelTeamInvitation(invitationId);
      
      console.log(`[Team-Invite] Company ${companyId} cancelled invitation ${invitationId}`);
      
      res.json({ success: true, message: "Invitation cancelled successfully" });
    } catch (error) {
      console.error("Cancel invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/pending-onboarding-invitations", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and admins can view pending onboarding invitations
      if (user.role !== 'owner' && user.role !== 'company' && user.role !== 'admin') {
        return res.status(403).json({ message: "Only owners and admins can view pending onboarding" });
      }
      
      // Get all accepted invitations that have been acknowledged but technician has no hourlyRate
      const invitations = await storage.getPendingOnboardingInvitationsForCompany(companyId);
      
      // Return full technician info for employee form pre-population
      const safeInvitations = invitations.map(inv => ({
        id: inv.id,
        respondedAt: inv.respondedAt,
        acknowledgedAt: inv.ownerAcknowledgedAt,
        technician: {
          id: inv.technician.id,
          name: inv.technician.name,
          email: inv.technician.email,
          employeePhoneNumber: inv.technician.employeePhoneNumber,
          smsNotificationsEnabled: inv.technician.smsNotificationsEnabled,
          employeeStreetAddress: inv.technician.employeeStreetAddress,
          employeeCity: inv.technician.employeeCity,
          employeeProvinceState: inv.technician.employeeProvinceState,
          employeeCountry: inv.technician.employeeCountry,
          employeePostalCode: inv.technician.employeePostalCode,
          homeAddress: inv.technician.homeAddress,
          birthday: inv.technician.birthday,
          emergencyContactName: inv.technician.emergencyContactName,
          emergencyContactPhone: inv.technician.emergencyContactPhone,
          emergencyContactRelationship: inv.technician.emergencyContactRelationship,
          specialMedicalConditions: inv.technician.specialMedicalConditions,
          irataLevel: inv.technician.irataLevel,
          irataLicenseNumber: inv.technician.irataLicenseNumber,
          irataIssuedDate: inv.technician.irataIssuedDate,
          irataExpirationDate: inv.technician.irataExpirationDate,
          irataDocuments: inv.technician.irataDocuments,
          irataVerifiedAt: inv.technician.irataVerifiedAt,
          irataVerificationStatus: inv.technician.irataVerificationStatus,
          spratLevel: inv.technician.spratLevel,
          spratLicenseNumber: inv.technician.spratLicenseNumber,
          spratIssuedDate: inv.technician.spratIssuedDate,
          spratExpirationDate: inv.technician.spratExpirationDate,
          spratDocuments: inv.technician.spratDocuments,
          spratVerifiedAt: inv.technician.spratVerifiedAt,
          spratVerificationStatus: inv.technician.spratVerificationStatus,
          hasFirstAid: inv.technician.hasFirstAid,
          firstAidType: inv.technician.firstAidType,
          firstAidExpiry: inv.technician.firstAidExpiry,
          firstAidDocuments: inv.technician.firstAidDocuments,
          driversLicenseNumber: inv.technician.driversLicenseNumber,
          driversLicenseProvince: inv.technician.driversLicenseProvince,
          driversLicenseExpiry: inv.technician.driversLicenseExpiry,
          driversLicenseDocuments: inv.technician.driversLicenseDocuments,
          bankTransitNumber: inv.technician.bankTransitNumber,
          bankInstitutionNumber: inv.technician.bankInstitutionNumber,
          bankAccountNumber: inv.technician.bankAccountNumber,
          bankDocuments: inv.technician.bankDocuments,
          socialInsuranceNumber: inv.technician.socialInsuranceNumber,
          photoUrl: inv.technician.photoUrl,
        }
      }));
      
      res.json({ invitations: safeInvitations });
    } catch (error) {
      console.error("Get pending onboarding invitations error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Acknowledge an accepted invitation (owner clicks "Next")
  app.post("/api/invitations/:invitationId/acknowledge", requireAuth, async (req: Request, res: Response) => {
    try {
      const { invitationId } = req.params;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and admins can acknowledge invitations
      if (user.role !== 'owner' && user.role !== 'company' && user.role !== 'admin') {
        return res.status(403).json({ message: "Only owners and admins can acknowledge invitations" });
      }
      
      const invitation = await storage.getTeamInvitationById(invitationId);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      
      // Verify invitation belongs to this company
      if (invitation.companyId !== companyId) {
        return res.status(403).json({ message: "This invitation does not belong to your company" });
      }
      
      if (invitation.status !== "accepted") {
        return res.status(400).json({ message: "This invitation has not been accepted" });
      }
      
      // Check if already acknowledged
      if (invitation.ownerAcknowledgedAt) {
        return res.status(400).json({ message: "This invitation has already been acknowledged" });
      }
      
      await storage.acknowledgeTeamInvitation(invitationId, companyId);
      
      console.log(`[Team-Invite] Owner ${user.id} acknowledged invitation ${invitationId}`);
      
      res.json({ 
        success: true, 
        message: "Invitation acknowledged"
      });
    } catch (error) {
      console.error("Acknowledge invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Convert accepted invitation to employee (set salary, permissions, link to company)
  app.post("/api/accepted-invitations/:invitationId/convert", requireAuth, async (req: Request, res: Response) => {
    try {
      const { invitationId } = req.params;
      const { 
        hourlyRate, 
        isSalary, 
        salary, 
        role,
        permissions,
        hasFirstAid,
        firstAidType,
        firstAidExpiry,
        firstAidDocuments,
      } = req.body;
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = (user.role === 'owner' || user.role === 'company') ? user.id : user.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      
      // Only company owners and admins can convert invitations
      if (user.role !== 'owner' && user.role !== 'company' && user.role !== 'admin') {
        return res.status(403).json({ message: "Only owners and admins can add employees" });
      }
      
      const invitation = await storage.getTeamInvitationById(invitationId);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      
      // Verify invitation belongs to this company
      if (invitation.companyId !== companyId) {
        return res.status(403).json({ message: "This invitation does not belong to your company" });
      }
      
      if (invitation.status !== "accepted") {
        return res.status(400).json({ message: "This invitation has not been accepted" });
      }
      
      // Note: ownerAcknowledgedAt being set is EXPECTED here
      // The acknowledge step happens when owner sees the celebration dialog
      // The convert step happens when they submit the employee form
      // So we should NOT reject if ownerAcknowledgedAt is set
      
      // Get the technician
      const technician = await storage.getUserById(invitation.technicianId);
      if (!technician) {
        return res.status(404).json({ message: "Technician not found" });
      }
      
      // Check if technician is linked to a DIFFERENT company (protect against cross-company hijacking)
      // If linked to THIS company (via accepting invitation), that's expected and allowed
      // PLUS technicians can be linked to multiple companies, so we skip this check for them
      if (technician.companyId && technician.companyId !== companyId && !technician.hasPlusAccess) {
        return res.status(400).json({ message: "This technician is already linked to a different company" });
      }
      
      // Check seat limits
      const company = await storage.getUserById(companyId);
      if (company) {
        const employees = await db.select({ id: users.id })
          .from(users)
          .where(eq(users.companyId, companyId));
        
        const currentSeats = employees.length;
        const tier = company.subscriptionTier || 'none';
        
        // Get seat limits based on tier
        const seatLimits: Record<string, number> = {
          'none': 0,
          'basic': 5,
          'starter': 15,
          'premium': 50,
          'enterprise': 999999,
        };
        const baseLimit = seatLimits[tier] || 0;
        const additionalSeats = company.additionalSeatsCount || 0;
        const totalLimit = baseLimit + additionalSeats;
        
        if (currentSeats >= totalLimit && tier !== 'enterprise') {
          return res.status(400).json({ 
            message: "Seat limit reached. Please upgrade your plan or purchase additional seats.",
            seatLimitReached: true 
          });
        }
      }
      
      // Get current date for start date
      const today = new Date();
      const startDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
      
      // For PLUS technicians who already have a primary employer, create an employer_connection
      // instead of changing their companyId
      const isPlusWithExistingEmployer = technician.hasPlusAccess && technician.companyId && technician.companyId !== companyId;
      
      if (isPlusWithExistingEmployer) {
        // Check if connection already exists
        const existingConnection = await db.select().from(technicianEmployerConnections)
          .where(and(
            eq(technicianEmployerConnections.technicianId, technician.id),
            eq(technicianEmployerConnections.companyId, companyId)
          )).limit(1);
        
        if (existingConnection.length === 0) {
          // Create a new employer connection for PLUS technician
          await db.insert(technicianEmployerConnections).values({
            technicianId: technician.id,
            companyId: companyId,
            isPrimary: false,
            status: "active",
            invitationId: invitationId,
            hourlyRate: hourlyRate || null,
            isSalary: isSalary || false,
            salary: isSalary && salary ? salary : null,
          });
          
          console.log(`[Team-Invite] PLUS technician ${technician.id} added as secondary employee to company ${companyId}`);
        } else {
          // Update existing connection
          await db.update(technicianEmployerConnections)
            .set({
              status: "active",
              hourlyRate: hourlyRate || null,
              isSalary: isSalary || false,
              salary: isSalary && salary ? salary : null,
            })
            .where(eq(technicianEmployerConnections.id, existingConnection[0].id));
        }
      } else {
        // Regular flow: Update the technician record to link to company and set employee details
        const updateData: any = {
          companyId: companyId,
          role: role || 'rope_access_tech',
          permissions: permissions || [],
          startDate: startDate,
          isSalary: isSalary || false,
        };
        
        // Set compensation
        if (isSalary && salary) {
          updateData.salary = salary;
          updateData.hourlyRate = null;
        } else if (hourlyRate) {
          updateData.hourlyRate = hourlyRate;
          updateData.salary = null;
        }
        
        // Update first aid info if provided
        if (hasFirstAid !== undefined) {
          updateData.hasFirstAid = hasFirstAid;
        }
        if (firstAidType !== undefined) {
          updateData.firstAidType = firstAidType;
        }
        if (firstAidExpiry !== undefined) {
          updateData.firstAidExpiry = firstAidExpiry;
        }
        if (firstAidDocuments !== undefined) {
          updateData.firstAidDocuments = firstAidDocuments;
        }
        
        await storage.updateUser(invitation.technicianId, updateData);
      }
      
      // Mark invitation as acknowledged
      await storage.acknowledgeTeamInvitation(invitationId, companyId);
      
      console.log(`[Team-Invite] Owner ${user.id} converted invitation ${invitationId} to employee for technician ${invitation.technicianId}`);
      
      // Get updated employee data
      const updatedEmployee = await storage.getUserById(invitation.technicianId);
      
      res.json({ 
        success: true, 
        message: "Employee added successfully",
        employee: updatedEmployee ? {
          id: updatedEmployee.id,
          name: updatedEmployee.name,
          email: updatedEmployee.email,
          role: updatedEmployee.role,
        } : null
      });
    } catch (error) {
      console.error("Convert invitation error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== IRATA/SPRAT VERIFICATION ROUTES ====================
  
  // Verify IRATA/SPRAT license via screenshot analysis
  const { analyzeIrataScreenshot, analyzeSpratScreenshot, normalizeExpiryDate } = await import("./gemini");
  
  const verificationUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/')) {
        cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    }
  });
  
  app.post("/api/verify-irata-screenshot", requireAuth, verificationUpload.single('screenshot'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No screenshot file provided" });
      }
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Convert file buffer to base64
      const imageBase64 = req.file.buffer.toString('base64');
      const mimeType = req.file.mimetype;
      
      console.log(`[IRATA-Verify] Analyzing screenshot for user ${user.id} (${user.name})`);
      
      // Analyze the screenshot with Gemini
      const result = await analyzeIrataScreenshot(imageBase64, mimeType);
      
      console.log(`[IRATA-Verify] Result:`, JSON.stringify(result));
      
      // If verification was successful, update the user's verification status
      if (result.isValid && result.confidence !== "low") {
        // Build update object with verification data extracted by AI
        const updateData: any = {
          irataVerifiedAt: new Date(),
          irataVerificationStatus: result.status || "Verified",
        };
        
        // Save extracted expiry date if available (normalized to ISO format)
        // Always set to clear any prior invalid data
        if (result.expiryDate) {
          const normalizedDate = normalizeExpiryDate(result.expiryDate);
          if (normalizedDate) {
            updateData.irataExpirationDate = normalizedDate;
            console.log(`[IRATA-Verify] Extracted expiry date: ${result.expiryDate} -> normalized to: ${normalizedDate}`);
          } else {
            // Normalization failed - clear any prior invalid value
            updateData.irataExpirationDate = null;
            console.log(`[IRATA-Verify] Could not normalize expiry date: ${result.expiryDate} - clearing field`);
          }
        }
        
        // Save extracted level if available and different from current
        if (result.irataLevel) {
          updateData.irataLevel = `Level ${result.irataLevel}`;
          console.log(`[IRATA-Verify] Extracted level: Level ${result.irataLevel}`);
        }
        
        // Save extracted license number if available, but preserve the level/number format
        // IMPORTANT: Don't overwrite if user already has a properly formatted license number
        // The stored format is "level/number" (e.g., "3/123456") which is used for login
        if (result.irataNumber && result.irataLevel) {
          // Format as "level/number" to match registration format for login compatibility
          const formattedLicense = `${result.irataLevel}/${result.irataNumber}`;
          updateData.irataLicenseNumber = formattedLicense;
          console.log(`[IRATA-Verify] Extracted and formatted license: ${formattedLicense}`);
        } else if (result.irataNumber && !user.irataLicenseNumber) {
          // Only set if user doesn't have one yet (shouldn't happen normally)
          updateData.irataLicenseNumber = result.irataNumber;
          console.log(`[IRATA-Verify] Extracted license number: ${result.irataNumber}`);
        } else {
          console.log(`[IRATA-Verify] Preserving existing license number: ${user.irataLicenseNumber}`);
        }
        
        await storage.updateUser(user.id, updateData);
        
        console.log(`[IRATA-Verify] User ${user.id} IRATA license verified successfully`);
      }
      
      res.json({
        success: result.isValid,
        verification: result,
        message: result.isValid 
          ? "IRATA license verification successful!" 
          : result.error || "Could not verify IRATA license from this screenshot"
      });
    } catch (error: any) {
      console.error("IRATA screenshot verification error:", error);
      res.status(500).json({ message: error.message || "Failed to analyze screenshot" });
    }
  });
  
  // SPRAT screenshot verification endpoint
  app.post("/api/verify-sprat-screenshot", requireAuth, verificationUpload.single('screenshot'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No screenshot file provided" });
      }
      
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Convert file buffer to base64
      const imageBase64 = req.file.buffer.toString('base64');
      const mimeType = req.file.mimetype;
      
      console.log(`[SPRAT-Verify] Analyzing screenshot for user ${user.id} (${user.name})`);
      
      // Analyze the screenshot with Gemini
      const result = await analyzeSpratScreenshot(imageBase64, mimeType);
      
      console.log(`[SPRAT-Verify] Result:`, JSON.stringify(result));
      
      // If verification was successful, update the user's verification status
      if (result.isValid && result.confidence !== "low") {
        // Build update object with verification data extracted by AI
        const updateData: any = {
          spratVerifiedAt: new Date(),
          spratVerificationStatus: result.status || "Verified",
        };
        
        // Save extracted expiry date if available (normalized to ISO format)
        // Always set to clear any prior invalid data
        if (result.expiryDate) {
          const normalizedDate = normalizeExpiryDate(result.expiryDate);
          if (normalizedDate) {
            updateData.spratExpirationDate = normalizedDate;
            console.log(`[SPRAT-Verify] Extracted expiry date: ${result.expiryDate} -> normalized to: ${normalizedDate}`);
          } else {
            // Normalization failed - clear any prior invalid value
            updateData.spratExpirationDate = null;
            console.log(`[SPRAT-Verify] Could not normalize expiry date: ${result.expiryDate} - clearing field`);
          }
        }
        
        // Save extracted level if available
        if (result.spratLevel) {
          updateData.spratLevel = `Level ${result.spratLevel}`;
          console.log(`[SPRAT-Verify] Extracted level: Level ${result.spratLevel}`);
        }
        
        // Save extracted certification number if available
        if (result.spratNumber) {
          updateData.spratLicenseNumber = result.spratNumber;
          console.log(`[SPRAT-Verify] Extracted certification number: ${result.spratNumber}`);
        }
        
        await storage.updateUser(user.id, updateData);
        
        console.log(`[SPRAT-Verify] User ${user.id} SPRAT license verified successfully`);
      }
      
      res.json({
        success: result.isValid,
        verification: result,
        message: result.isValid 
          ? "SPRAT license verification successful!" 
          : result.error || "Could not verify SPRAT license from this screenshot"
      });
    } catch (error: any) {
      console.error("SPRAT screenshot verification error:", error);
      res.status(500).json({ message: error.message || "Failed to analyze screenshot" });
    }
  });
  
  // ==================== DOCUMENT OCR ROUTES ====================
  
  // OCR scan driver's license to extract license number and expiry date
  app.post("/api/ocr/drivers-license", verificationUpload.single("image"), async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Unauthorized - Please log in" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }
      
      const imageBase64 = req.file.buffer.toString("base64");
      const mimeType = req.file.mimetype;
      
      console.log(`[OCR] Analyzing driver's license for user ${req.session.userId}`);
      
      const { analyzeDriversLicense } = await import("./gemini");
      const result = await analyzeDriversLicense(imageBase64, mimeType);
      
      res.json({
        success: result.success,
        data: {
          licenseNumber: result.licenseNumber,
          expiryDate: result.expiryDate,
          issuedDate: result.issuedDate,
          name: result.name
        },
        confidence: result.confidence,
        error: result.error
      });
    } catch (error: any) {
      console.error("Driver's license OCR error:", error);
      res.status(500).json({ message: error.message || "Failed to analyze driver's license" });
    }
  });
  
  // OCR scan void cheque to extract banking info
  app.post("/api/ocr/void-cheque", verificationUpload.single("image"), async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Unauthorized - Please log in" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }
      
      const imageBase64 = req.file.buffer.toString("base64");
      const mimeType = req.file.mimetype;
      
      console.log(`[OCR] Analyzing void cheque for user ${req.session.userId}`);
      
      const { analyzeVoidCheque } = await import("./gemini");
      const result = await analyzeVoidCheque(imageBase64, mimeType);
      
      res.json({
        success: result.success,
        data: {
          transitNumber: result.transitNumber,
          institutionNumber: result.institutionNumber,
          accountNumber: result.accountNumber
        },
        confidence: result.confidence,
        error: result.error
      });
    } catch (error: any) {
      console.error("Void cheque OCR error:", error);
      res.status(500).json({ message: error.message || "Failed to analyze void cheque" });
    }
  });
  
  // ==================== PROJECT ROUTES ====================
  
  // Upload rope access plan PDF
  const upload = multer({ 
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max
    fileFilter: (req, file, cb) => {
      if (file.mimetype === 'application/pdf') {
        cb(null, true);
      } else {
        cb(new Error('Only PDF files are allowed'));
      }
    }
  });
  
  // Upload images (photos) - supports HEIC/HEIF from iPhones
  const imageUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max for high-res photos
    fileFilter: (req, file, cb) => {
      // Check MIME type or file extension for HEIC/HEIF support (browsers often report wrong MIME type)
      const fileName = file.originalname.toLowerCase();
      const isHeicOrHeif = fileName.endsWith('.heic') || fileName.endsWith('.heif');
      const isImage = file.mimetype.startsWith('image/') || isHeicOrHeif;
      
      if (isImage) {
        cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    }
  });

  // Upload employee documents (images or PDFs)
  const documentUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
        cb(null, true);
      } else {
        cb(new Error('Only image or PDF files are allowed'));
      }
    }
  });

  // Property Manager: Save building instructions for a project's building
  app.put("/api/property-managers/vendors/:linkId/projects/:projectId/building-instructions", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId, projectId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Get project to verify access
      const projectDetails = await storage.getPropertyManagerProjectDetails(
        projectId, 
        ownedLink.companyId
      );
      
      if (!projectDetails.project.strataPlanNumber) {
        return res.status(400).json({ message: "Project does not have a strata/building number" });
      }
      
      // Find the building by strata plan number
      const building = await storage.getBuildingByStrata(projectDetails.project.strataPlanNumber);
      
      if (!building) {
        return res.status(404).json({ message: "Building not found in the global database" });
      }
      
      // Save or update building instructions
      // Property managers save with createdByUserId = null since they're not in users table for this company
      const instructionsData = {
        buildingId: building.id,
        buildingAccess: req.body.buildingAccess || null,
        keysAndFob: req.body.keysAndFob || null,
        keysReturnPolicy: req.body.keysReturnPolicy || null,
        roofAccess: req.body.roofAccess || null,
        buildingManagerName: req.body.buildingManagerName || null,
        buildingManagerPhone: req.body.buildingManagerPhone || null,
        conciergeNames: req.body.conciergeNames || null,
        conciergePhone: req.body.conciergePhone || null,
        conciergeHours: req.body.conciergeHours || null,
        maintenanceName: req.body.maintenanceName || null,
        maintenancePhone: req.body.maintenancePhone || null,
        councilMemberUnits: req.body.councilMemberUnits || null,
        tradeParkingInstructions: req.body.tradeParkingInstructions || null,
        tradeParkingSpots: req.body.tradeParkingSpots || null,
        tradeWashroomLocation: req.body.tradeWashroomLocation || null,
        specialRequests: req.body.specialRequests || null,
        createdByUserId: null, // Property manager - not in company users table
      };
      
      const result = await storage.upsertBuildingInstructions(instructionsData);
      res.json({ success: true, instructions: result });
    } catch (error: any) {
      console.error("Property manager save building instructions error:", error);
      if (error.message?.includes('not found') || error.message?.includes('access denied')) {
        return res.status(404).json({ message: error.message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Upload anchor inspection document
  app.post("/api/property-managers/vendors/:linkId/projects/:projectId/anchor-inspection", requireAuth, requireRole("property_manager"), documentUpload.single('document'), async (req: Request, res: Response) => {
    try {
      const { linkId, projectId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      // Get project to verify access and get company info
      const projectDetails = await storage.getPropertyManagerProjectDetails(
        projectId, 
        ownedLink.companyId
      );
      
      // Upload file to object storage
      const objectStorageService = new ObjectStorageService();
      const fileUrl = await objectStorageService.uploadPublicFile(
        req.file.originalname,
        req.file.buffer,
        req.file.mimetype
      );
      
      // Get property manager info for uploaded by name
      const propertyManager = await storage.getUserById(propertyManagerId);
      const uploadedByName = propertyManager?.name || 
                             `${propertyManager?.firstName} ${propertyManager?.lastName}`.trim() || 
                             'Property Manager';
      
      // Create company document with equipment_inspection type
      await storage.createCompanyDocument({
        companyId: ownedLink.companyId,
        documentType: 'equipment_inspection',
        fileName: req.file.originalname,
        fileUrl,
        uploadedById: propertyManagerId,
        uploadedByName,
        projectId,
      });
      
      // Also update the project's anchorInspectionCertificateUrl field
      await storage.updateProject(projectId, {
        anchorInspectionCertificateUrl: fileUrl,
      });
      
      res.json({ 
        message: "Anchor inspection document uploaded successfully",
        fileUrl 
      });
    } catch (error: any) {
      console.error("Upload anchor inspection document error:", error);
      if (error.message?.includes('not found') || error.message?.includes('access denied')) {
        return res.status(404).json({ message: error.message });
      }
      res.status(500).json({ message: "Failed to upload document. Please try again." });
    }
  });

  // Upload employee document (driver's license, abstract, etc.)
  app.post("/api/upload-employee-document", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), documentUpload.single('document'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      // Generate unique filename
      const timestamp = Date.now();
      const extension = req.file.mimetype === 'application/pdf' ? 'pdf' : req.file.mimetype.split('/')[1];
      const filename = `employee-document-${timestamp}.${extension}`;

      // Upload to public object storage (same as resident portal and quotes)
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        req.file.mimetype
      );

      res.json({ url });
    } catch (error) {
      console.error("Employee document upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload document";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // ==================== COMPANY BRANDING ROUTES ====================
  
  // Upload company logo for white label branding
  app.post("/api/company/branding/logo", requireAuth, requireRole("company"), imageUpload.single('logo'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser || currentUser.role !== "company") {
        return res.status(403).json({ message: "Access denied" });
      }

      // Generate unique filename
      const timestamp = Date.now();
      const extension = req.file.mimetype.split('/')[1];
      const filename = `company-logo-${currentUser.id}-${timestamp}.${extension}`;

      // Upload to public object storage (so residents can see it)
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        req.file.mimetype
      );

      // Update company's branding logo URL
      await storage.updateUser(currentUser.id, {
        brandingLogoUrl: url
      });

      res.json({ url });
    } catch (error) {
      console.error("Logo upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload logo";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Update company branding colors
  app.patch("/api/company/branding", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser || currentUser.role !== "company") {
        return res.status(403).json({ message: "Access denied" });
      }

      const { colors } = req.body;

      // Validate that colors is an array
      if (!Array.isArray(colors)) {
        return res.status(400).json({ message: "Colors must be an array" });
      }

      // Validate hex color format for each color
      const hexColorRegex = /^#[0-9A-Fa-f]{6}$/;
      for (const color of colors) {
        if (color && !hexColorRegex.test(color)) {
          return res.status(400).json({ message: `Invalid color format: ${color}` });
        }
      }

      // Update branding colors
      await storage.updateUser(currentUser.id, {
        brandingColors: colors
      });

      res.json({ message: "Branding updated successfully" });
    } catch (error) {
      console.error("Branding update error:", error);
      res.status(500).json({ message: "Failed to update branding" });
    }
  });
  
  // Get company branding (public endpoint for residents)
  app.get("/api/company/:companyId/branding", async (req: Request, res: Response) => {
    try {
      const { companyId } = req.params;
      
      const company = await storage.getUserById(companyId);
      
      if (!company || company.role !== "company") {
        return res.status(404).json({ message: "Company not found" });
      }

      // Return branding info (public, safe to expose)
      // Only return branding details if subscription is active
      res.json({
        logoUrl: company.whitelabelBrandingActive ? company.brandingLogoUrl : null,
        colors: company.whitelabelBrandingActive ? (company.brandingColors || []) : [],
        companyName: company.companyName,
        subscriptionActive: company.whitelabelBrandingActive || false,
        pwaAppIconUrl: company.whitelabelBrandingActive ? company.pwaAppIconUrl : null,
      });
    } catch (error) {
      console.error("Error fetching company branding:", error);
      res.status(500).json({ message: "Failed to fetch branding" });
    }
  });
  
  // Upload PWA app icon for white label branding
  app.post("/api/company/branding/pwa-icon", requireAuth, requireRole("company"), imageUpload.single('icon'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser || currentUser.role !== "company") {
        return res.status(403).json({ message: "Access denied" });
      }

      // Generate unique filename
      const timestamp = Date.now();
      const filename = `pwa-icon-${currentUser.id}-${timestamp}.png`;

      // Upload to public object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        'image/png'
      );

      // Update company's PWA app icon URL
      await storage.updateUser(currentUser.id, {
        pwaAppIconUrl: url
      });

      res.json({ url });
    } catch (error) {
      console.error("PWA icon upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload icon";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Dynamic manifest.json for PWA white-label support
  app.get("/api/manifest.json", async (req: Request, res: Response) => {
    try {
      // Default manifest
      const defaultManifest = {
        name: 'OnRopePro - Rope Access Management',
        short_name: 'OnRopePro',
        description: 'Professional rope access and building maintenance management platform',
        theme_color: '#1e293b',
        background_color: '#ffffff',
        display: 'standalone',
        orientation: 'portrait',
        start_url: '/',
        scope: '/',
        icons: [
          {
            src: '/pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: '/pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ]
      };

      // Check if user is logged in as a COMPANY and has white-label branding
      // Note: Technician portal is owned by the technician, NOT the company
      // So we only apply company branding for company role users
      if (req.session && req.session.userId) {
        const user = await storage.getUserById(req.session.userId);
        
        // Only apply white-label branding for company role users (not technicians)
        if (user && user.role === 'company' && user.whitelabelBrandingActive && user.pwaAppIconUrl) {
          // Return white-labeled manifest for company users only
          const customManifest = {
            ...defaultManifest,
            name: user.companyName || defaultManifest.name,
            short_name: user.companyName?.substring(0, 12) || defaultManifest.short_name,
            theme_color: user.brandingColors?.[0] || defaultManifest.theme_color,
            icons: [
              {
                src: user.pwaAppIconUrl,
                sizes: '192x192',
                type: 'image/png'
              },
              {
                src: user.pwaAppIconUrl,
                sizes: '512x512',
                type: 'image/png',
                purpose: 'any maskable'
              }
            ]
          };
          
          res.setHeader('Content-Type', 'application/manifest+json');
          return res.json(customManifest);
        }
      }

      res.setHeader('Content-Type', 'application/manifest+json');
      res.json(defaultManifest);
    } catch (error) {
      console.error("Error serving manifest:", error);
      // Return default manifest on error
      res.setHeader('Content-Type', 'application/manifest+json');
      res.json({
        name: 'OnRopePro - Rope Access Management',
        short_name: 'OnRopePro',
        display: 'standalone',
        start_url: '/',
        icons: [
          { src: '/pwa-192x192.png', sizes: '192x192', type: 'image/png' },
          { src: '/pwa-512x512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' }
        ]
      });
    }
  });
  
  // Dynamic apple-touch-icon for Safari/macOS "Add to Dock" white-label support
  // Note: Only applies to company role users - technician portal stays independent
  app.get("/api/apple-touch-icon.png", async (req: Request, res: Response) => {
    try {
      // Only apply white-label branding for company role users (not technicians)
      if (req.session && req.session.userId) {
        const user = await storage.getUserById(req.session.userId);
        
        if (user && user.role === 'company' && user.whitelabelBrandingActive && user.pwaAppIconUrl) {
          // Redirect to the custom icon URL for company users only
          return res.redirect(user.pwaAppIconUrl);
        }
      }

      // Serve default apple-touch-icon for everyone else (including technicians)
      res.redirect('/apple-touch-icon.png');
    } catch (error) {
      console.error("Error serving apple-touch-icon:", error);
      res.redirect('/apple-touch-icon.png');
    }
  });
  
  // ==================== RESIDENTS ROUTES ====================
  
  // Get all residents for the company
  app.get("/api/residents", requireAuth, requireRole("company", "operations_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get all residents associated with this company's projects
      const residents = await storage.getResidentsByCompany(companyId);
      
      // Get all clients to find building names
      const clients = await storage.getClientsByCompany(companyId);
      
      // Create a map of strata plan number to building name
      const strataPlanToBuilding = new Map<string, string>();
      clients.forEach(client => {
        if (client.lmsNumbers && Array.isArray(client.lmsNumbers)) {
          client.lmsNumbers.forEach((lms: any) => {
            if (lms.number && lms.buildingName) {
              strataPlanToBuilding.set(lms.number, lms.buildingName);
            }
          });
        }
      });
      
      // Return residents without sensitive data, with building names
      const safeResidents = residents.map(resident => ({
        id: resident.id,
        name: resident.name,
        email: resident.email,
        phone: resident.phoneNumber,
        unit: resident.unitNumber,
        parkingStall: resident.parkingStallNumber,
        strataPlan: resident.strataPlanNumber,
        buildingName: resident.strataPlanNumber ? strataPlanToBuilding.get(resident.strataPlanNumber) : undefined,
        buildingId: resident.strataPlanNumber, // Keep for backwards compatibility
        companyId: companyId,
      }));
      
      res.json(safeResidents);
    } catch (error) {
      console.error("Error fetching residents:", error);
      res.status(500).json({ message: "Failed to fetch residents" });
    }
  });
  
  // ==================== CLIENT ROUTES ====================
  
  // Search property managers by pmCode, name, or email (for company owners)
  app.get("/api/property-managers/search", requireAuth, requireRole("company", "employee"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check manage_clients permission
      if (!canManageClients(currentUser)) {
        return res.status(403).json({ message: "Access denied - insufficient permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const query = (req.query.q as string || "").trim().toLowerCase();
      if (!query || query.length < 2) {
        return res.json({ results: [] });
      }
      
      // Search users with role 'property_manager' by pmCode, name (firstName + lastName), or email
      const allPMs = await db.select({
        id: users.id,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
        pmCode: users.pmCode,
        propertyManagementCompany: users.propertyManagementCompany,
        propertyManagerPhoneNumber: users.propertyManagerPhoneNumber,
      }).from(users).where(eq(users.role, 'property_manager'));
      
      // Filter by search query
      const results = allPMs.filter(pm => {
        const fullName = `${pm.firstName || ''} ${pm.lastName || ''}`.toLowerCase().trim();
        const email = (pm.email || '').toLowerCase();
        const pmCode = (pm.pmCode || '').toLowerCase();
        
        return pmCode.includes(query) || 
               fullName.includes(query) || 
               email.includes(query);
      }).slice(0, 20); // Limit to 20 results
      
      // Check if any of these PMs are already linked to this company
      const linkedPMs = await db.select({ propertyManagerId: propertyManagerCompanyLinks.propertyManagerId })
        .from(propertyManagerCompanyLinks)
        .where(eq(propertyManagerCompanyLinks.companyId, companyId));
      const linkedPMIds = new Set(linkedPMs.map(l => l.propertyManagerId));
      
      // Return results with linked status
      const resultsWithStatus = results.map(pm => ({
        id: pm.id,
        email: pm.email,
        name: `${pm.firstName || ''} ${pm.lastName || ''}`.trim() || pm.email,
        pmCode: pm.pmCode,
        company: pm.propertyManagementCompany,
        phone: pm.propertyManagerPhoneNumber,
        isLinked: linkedPMIds.has(pm.id),
      }));
      
      res.json({ results: resultsWithStatus });
    } catch (error) {
      console.error("Error searching property managers:", error);
      res.status(500).json({ message: "Failed to search property managers" });
    }
  });
  
  // Get all linked property managers for this company (for quote recipient dropdown)
  app.get("/api/property-managers/linked", requireAuth, requireRole("company", "employee"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get all PM links for this company
      const pmLinks = await db.select()
        .from(propertyManagerCompanyLinks)
        .where(eq(propertyManagerCompanyLinks.companyId, companyId));
      
      // Fetch full PM details for each link
      const linkedPMs = await Promise.all(
        pmLinks.map(async (link) => {
          const pm = await storage.getUserById(link.propertyManagerId);
          if (!pm || pm.role !== 'property_manager') return null;
          return {
            id: pm.id,
            name: `${pm.firstName || ''} ${pm.lastName || ''}`.trim() || pm.email,
            email: pm.email,
            phone: pm.propertyManagerPhoneNumber,
            company: pm.propertyManagementCompany,
            smsOptIn: pm.propertyManagerSmsOptIn,
            strataNumber: link.strataNumber,
          };
        })
      );
      
      res.json(linkedPMs.filter(Boolean));
    } catch (error) {
      console.error("Error fetching linked property managers:", error);
      res.status(500).json({ message: "Failed to fetch linked property managers" });
    }
  });
  
  // Link a property manager to this company
  app.post("/api/property-managers/:pmId/link", requireAuth, requireRole("company", "employee"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check manage_clients permission
      if (!canManageClients(currentUser)) {
        return res.status(403).json({ message: "Access denied - insufficient permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const pmId = req.params.pmId;
      
      // Get the company to access propertyManagerCode
      const company = currentUser.role === "company" ? currentUser : await storage.getUserById(companyId);
      if (!company || !company.propertyManagerCode) {
        return res.status(400).json({ message: "Company does not have a property manager code configured" });
      }
      
      // Verify the PM exists and is a property_manager
      const pm = await storage.getUserById(pmId);
      if (!pm || pm.role !== 'property_manager') {
        return res.status(404).json({ message: "Property manager not found" });
      }
      
      // Check if already linked
      const existingLinks = await db.select()
        .from(propertyManagerCompanyLinks)
        .where(and(
          eq(propertyManagerCompanyLinks.propertyManagerId, pmId),
          eq(propertyManagerCompanyLinks.companyId, companyId)
        ));
      
      if (existingLinks.length > 0) {
        return res.status(400).json({ message: "Property manager is already linked to your company" });
      }
      
      // Check if a client already exists for this PM email
      const existingClients = await storage.getClientsByCompany(companyId);
      const existingClient = existingClients.find((c: any) => 
        c.email && pm.email && c.email.toLowerCase() === pm.email.toLowerCase()
      );
      
      // Create the link with company code
      await db.insert(propertyManagerCompanyLinks).values({
        id: crypto.randomUUID(),
        propertyManagerId: pmId,
        companyId: companyId,
        companyCode: company.propertyManagerCode,
      });
      
      // Create a client record for this PM if one doesn't exist
      if (!existingClient) {
        const pmName = `${pm.firstName || ''} ${pm.lastName || ''}`.trim();
        await storage.createClient({
          companyId: companyId,
          firstName: pm.firstName || '',
          lastName: pm.lastName || '',
          company: pm.propertyManagementCompany || '',
          email: pm.email || '',
          phoneNumber: pm.propertyManagerPhoneNumber || '',
          address: '',
          billingAddress: '',
        });
      }
      
      res.json({ success: true, message: "Property manager linked and added to client database" });
    } catch (error) {
      console.error("Error linking property manager:", error);
      res.status(500).json({ message: "Failed to link property manager" });
    }
  });
  
  // Get all clients for the company
  app.get("/api/clients", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      let clients: any[] = [];
      
      if (currentUser.role === "property_manager") {
        // Property managers can see clients from all linked companies
        const links = await storage.getPropertyManagerCompanyLinks(currentUser.id);
        const allClients = await Promise.all(
          links.map(link => storage.getClientsByCompany(link.companyId))
        );
        clients = allClients.flat();
      } else {
        // Company users and employees see their own company's clients
        const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
        
        if (!companyId) {
          return res.status(403).json({ message: "Access denied" });
        }
        
        clients = await storage.getClientsByCompany(companyId);
      }
      
      res.json({ clients });
    } catch (error) {
      console.error("Error fetching clients:", error);
      res.status(500).json({ message: "Failed to fetch clients" });
    }
  });
  
  // Get single client by ID
  app.get("/api/clients/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const client = await storage.getClientById(req.params.id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      // Verify access
      if (currentUser.role === "property_manager") {
        // Property managers can access clients from linked companies
        const links = await storage.getPropertyManagerCompanyLinks(currentUser.id);
        const linkedCompanyIds = links.map(link => link.companyId);
        
        if (!linkedCompanyIds.includes(client.companyId)) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else {
        // Company users and employees can only access their own company's clients
        const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
        
        if (client.companyId !== companyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      res.json(client);
    } catch (error) {
      console.error("Error fetching client:", error);
      res.status(500).json({ message: "Failed to fetch client" });
    }
  });
  
  // Create new client
  app.post("/api/clients", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const validatedData = insertClientSchema.parse(req.body);
      
      const newClient = await storage.createClient({
        ...validatedData,
        companyId,
      });
      
      res.json(newClient);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating client:", error);
      res.status(500).json({ message: "Failed to create client" });
    }
  });
  
  // Update client
  app.patch("/api/clients/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const client = await storage.getClientById(req.params.id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (client.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const updates = insertClientSchema.partial().parse(req.body);
      const updatedClient = await storage.updateClient(req.params.id, updates);
      
      res.json(updatedClient);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating client:", error);
      res.status(500).json({ message: "Failed to update client" });
    }
  });
  
  // Delete client
  app.delete("/api/clients/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const client = await storage.getClientById(req.params.id);
      
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (client.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteClient(req.params.id);
      res.json({ message: "Client deleted successfully" });
    } catch (error) {
      console.error("Error deleting client:", error);
      res.status(500).json({ message: "Failed to delete client" });
    }
  });

  // Scan business card with AI to extract contact information
  app.post("/api/clients/scan-business-card", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const { frontImage, backImage, frontMimeType, backMimeType } = req.body;
      
      if (!frontImage) {
        return res.status(400).json({ message: "Front image is required" });
      }
      
      // Validate image data
      const validMimeTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"];
      if (frontMimeType && !validMimeTypes.includes(frontMimeType)) {
        return res.status(400).json({ message: "Invalid front image type" });
      }
      if (backMimeType && !validMimeTypes.includes(backMimeType)) {
        return res.status(400).json({ message: "Invalid back image type" });
      }
      
      // Import the business card analyzer
      const { analyzeBusinessCard } = await import("./gemini");
      
      // Analyze the business card
      const result = await analyzeBusinessCard(
        frontImage,
        backImage || undefined,
        frontMimeType || "image/jpeg",
        backMimeType || "image/jpeg"
      );
      
      res.json(result);
    } catch (error) {
      console.error("Error scanning business card:", error);
      res.status(500).json({ 
        success: false,
        error: "Failed to analyze business card. Please try again."
      });
    }
  });
  
  app.post("/api/upload-rope-access-plan", requireAuth, requireRole("company", "operations_manager", "rope_access_tech"), upload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      // Generate unique filename
      const timestamp = Date.now();
      const filename = `rope-access-plan-${timestamp}.pdf`;
      
      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        'application/pdf'
      );
      
      res.json({ url });
    } catch (error) {
      console.error("File upload error details:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload file";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Update project's rope access plan
  app.patch("/api/projects/:id/rope-access-plan", requireAuth, requireRole("company", "operations_manager", "rope_access_tech"), upload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      const projectId = req.params.id;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the project to verify access
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify user has access to this project (same company)
      const userCompanyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (project.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Generate unique filename
      const timestamp = Date.now();
      const filename = `rope-access-plan-${timestamp}.pdf`;
      
      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        'application/pdf'
      );
      
      // Add to documents array (keep all uploaded PDFs)
      const currentDocuments = project.documentUrls || [];
      const updatedDocuments = [...currentDocuments, url];
      
      // Update project with new PDF URL and add to documents array
      const updatedProject = await storage.updateProject(projectId, { 
        ropeAccessPlanUrl: url,
        documentUrls: updatedDocuments
      });
      
      res.json({ project: updatedProject, url });
    } catch (error) {
      console.error("File upload error details:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload file";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Upload anchor inspection certificate
  app.post("/api/upload-anchor-certificate", requireAuth, requireRole("company", "operations_manager", "rope_access_tech"), upload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      // Generate unique filename
      const timestamp = Date.now();
      const filename = `anchor-inspection-certificate-${timestamp}.pdf`;
      
      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        'application/pdf'
      );
      
      res.json({ url });
    } catch (error) {
      console.error("Anchor certificate upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload file";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Update project's anchor inspection certificate
  app.patch("/api/projects/:id/anchor-certificate", requireAuth, requireRole("company", "operations_manager", "rope_access_tech"), upload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      const projectId = req.params.id;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the project to verify access
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify user has access to this project (same company)
      const userCompanyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (project.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Generate unique filename
      const timestamp = Date.now();
      const filename = `anchor-inspection-certificate-${timestamp}.pdf`;
      
      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        'application/pdf'
      );
      
      // Update project with new certificate URL
      const updatedProject = await storage.updateProject(projectId, { 
        anchorInspectionCertificateUrl: url
      });
      
      res.json({ project: updatedProject, url });
    } catch (error) {
      console.error("Anchor certificate upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload file";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });
  
  // Upload image to project with optional unit number and comment
  app.post("/api/projects/:id/images", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), imageUpload.single('file'), async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      const projectId = req.params.id;
      const { unitNumber, comment, isMissedUnit, missedUnitNumber, isMissedStall, missedStallNumber } = req.body;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the project to verify access
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify user has access to this project (same company) and determine companyId
      const userCompanyId = currentUser.role === "company" ? currentUser.id : (currentUser.companyId ?? project.companyId);
      if (project.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Validate missed unit fields
      const isMissed = isMissedUnit === 'true' || isMissedUnit === true;
      if (isMissed) {
        // Only allow missed unit marking for in-suite dryer vent projects
        if (project.jobType !== 'in_suite_dryer_vent_cleaning') {
          return res.status(400).json({ message: "Missed units can only be marked for in-suite dryer vent cleaning projects" });
        }
        
        // Require unit number when marking as missed
        if (!missedUnitNumber || missedUnitNumber.trim() === '') {
          return res.status(400).json({ message: "Unit number is required when marking a photo as a missed unit" });
        }
      }
      
      // Validate missed stall fields
      const isMissedStallBool = isMissedStall === 'true' || isMissedStall === true;
      if (isMissedStallBool) {
        // Only allow missed stall marking for parkade projects
        if (project.jobType !== 'parkade_pressure_cleaning') {
          return res.status(400).json({ message: "Missed stalls can only be marked for parkade pressure cleaning projects" });
        }
        
        // Require stall number when marking as missed
        if (!missedStallNumber || missedStallNumber.trim() === '') {
          return res.status(400).json({ message: "Stall number is required when marking a photo as a missed stall" });
        }
      }
      
      // Generate unique filename
      const timestamp = Date.now();
      const ext = req.file.mimetype.split('/')[1];
      const filename = `project-image-${projectId}-${timestamp}.${ext}`;
      
      // Upload to object storage
      const objectStorageService = new ObjectStorageService();
      const url = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        req.file.mimetype
      );
      
      // Create photo record in database with optional unit number and comment
      const photo = await storage.createProjectPhoto({
        projectId,
        companyId: userCompanyId,
        uploadedBy: currentUser.id,
        imageUrl: url,
        unitNumber: unitNumber || null,
        comment: comment || null,
        isMissedUnit: isMissed,
        missedUnitNumber: isMissed ? missedUnitNumber : null,
        isMissedStall: isMissedStallBool,
        missedStallNumber: isMissedStallBool ? missedStallNumber : null,
      });
      
      res.json({ photo, url });
    } catch (error) {
      console.error("Image upload error details:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to upload image";
      res.status(500).json({ message: `Upload failed: ${errorMessage}` });
    }
  });

  // Get photos for a project
  app.get("/api/projects/:id/photos", requireAuth, async (req: Request, res: Response) => {
    try {
      const projectId = req.params.id;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the project to verify access
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify user has access to this project
      const userCompanyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      const userStrataPlan = currentUser.role === "resident" ? currentUser.strataPlanNumber : null;
      
      if (currentUser.role === "resident") {
        // Residents can only see photos for projects matching their strata plan
        if (project.strataPlanNumber !== userStrataPlan) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else {
        // Staff must be from same company
        if (project.companyId !== userCompanyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      let photos = await storage.getProjectPhotos(projectId);
      console.log(`[PHOTOS DEBUG] Fetched ${photos.length} photos for project ${projectId}`);
      console.log(`[PHOTOS DEBUG] First photo:`, photos[0]);
      
      // Filter photos for residents to only show their unit
      if (currentUser.role === "resident" && currentUser.unitNumber) {
        photos = photos.filter(photo => photo.unitNumber === currentUser.unitNumber);
      }
      
      res.json({ photos });
    } catch (error) {
      console.error("Get photos error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to get photos";
      res.status(500).json({ message: errorMessage });
    }
  });

  // Get photos for resident's unit or parking stall
  app.get("/api/my-unit-photos", requireAuth, requireRole("resident"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser || !currentUser.strataPlanNumber) {
        return res.status(400).json({ message: "Strata plan number not found" });
      }
      
      // Get photos by unit number OR parking stall number and strata plan number (works across all companies)
      // Match on either unitNumber or parkingStallNumber fields
      const unitNumber = currentUser.unitNumber || '';
      const parkingStallNumber = currentUser.parkingStallNumber || '';
      
      const photos = await storage.getPhotosByUnitAndStrataPlan(
        unitNumber, 
        currentUser.strataPlanNumber,
        parkingStallNumber
      );
      
      res.json({ photos });
    } catch (error) {
      console.error("Get unit photos error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to get unit photos";
      res.status(500).json({ message: errorMessage });
    }
  });
  
  // Serve public files from object storage
  app.get("/public-objects/:filePath(*)", async (req: Request, res: Response) => {
    const filePath = req.params.filePath;
    const objectStorageService = new ObjectStorageService();
    try {
      const file = await objectStorageService.searchPublicObject(filePath);
      if (!file) {
        return res.status(404).json({ error: "File not found" });
      }
      objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error("Error searching for public object:", error);
      return res.status(500).json({ error: "Internal server error" });
    }
  });

  // Serve private documents (authenticated users only)
  app.get("/api/private-documents/:fileName(*)", requireAuth, async (req: Request, res: Response) => {
    const fileName = req.params.fileName;
    const objectStorageService = new ObjectStorageService();
    try {
      const file = await objectStorageService.getPrivateFile(fileName);
      if (!file) {
        return res.status(404).json({ error: "Document not found" });
      }
      objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error("Error retrieving private document:", error);
      return res.status(500).json({ error: "Internal server error" });
    }
  });
  
  // Get custom job types for a company
  app.get("/api/custom-job-types", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get company ID (company themselves or the employee's company)
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const customJobTypes = await storage.getCustomJobTypesByCompany(companyId);
      res.json({ customJobTypes });
    } catch (error) {
      console.error("Get custom job types error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete a custom job type
  app.delete("/api/custom-job-types/:id", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      await storage.deleteCustomJobType(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete custom job type error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get custom notice templates for a company
  app.get("/api/custom-notice-templates", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const templates = await db.select().from(customNoticeTemplates)
        .where(eq(customNoticeTemplates.companyId, companyId))
        .orderBy(desc(customNoticeTemplates.createdAt));
      
      res.json({ templates });
    } catch (error) {
      console.error("Get custom notice templates error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Create a custom notice template
  app.post("/api/custom-notice-templates", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { jobType, title, details } = req.body;
      
      if (!jobType || !title || !details) {
        return res.status(400).json({ message: "Job type, title, and details are required" });
      }
      
      const result = await db.insert(customNoticeTemplates).values({
        companyId,
        jobType,
        title,
        details,
      }).returning();
      
      res.json({ template: result[0] });
    } catch (error) {
      console.error("Create custom notice template error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete a custom notice template
  app.delete("/api/custom-notice-templates/:id", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the template belongs to this company
      const [template] = await db.select().from(customNoticeTemplates)
        .where(eq(customNoticeTemplates.id, req.params.id))
        .limit(1);
        
      if (!template || template.companyId !== companyId) {
        return res.status(404).json({ message: "Template not found" });
      }
      
      await db.delete(customNoticeTemplates).where(eq(customNoticeTemplates.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Delete custom notice template error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Create project
  app.post("/api/projects", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get company ID (company themselves or the employee's company)
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Job types that don't use drop-based tracking (hours-based or non-elevation jobs)
      const nonDropJobTypes = ['in_suite_dryer_vent_cleaning', 'parkade_pressure_cleaning', 'ground_window_cleaning', 'general_pressure_washing'];
      const isNdtJob = req.body.jobType?.startsWith('ndt_');
      
      // Use job type's default elevation requirement if not explicitly provided
      // This ensures ground-level jobs (ground_window_cleaning, in_suite, parkade) don't require rope access docs
      const defaultElevation = getDefaultElevation(req.body.jobType);
      const requiresElevation = req.body.requiresElevation !== undefined ? req.body.requiresElevation : defaultElevation;
      
      const isNonDropJob = nonDropJobTypes.includes(req.body.jobType) || isNdtJob || requiresElevation === false;
      
      const projectData = insertProjectSchema.parse({
        ...req.body,
        strataPlanNumber: normalizeStrataPlan(req.body.strataPlanNumber),
        companyId,
        jobCategory: req.body.jobCategory || 'building_maintenance',
        requiresElevation,
        targetCompletionDate: req.body.targetCompletionDate || null,
        // Default dailyDropTarget to 0 for non-drop job types
        dailyDropTarget: isNonDropJob ? 0 : req.body.dailyDropTarget,
      });
      
      const project = await storage.createProject(projectData);
      
      // Auto-create building in global SuperUser database if strata number exists
      if (project.strataPlanNumber) {
        try {
          await storage.ensureBuildingExists({
            strataPlanNumber: project.strataPlanNumber,
            buildingName: project.buildingName,
            buildingAddress: project.buildingAddress,
            floorCount: project.floorCount,
            totalStalls: project.totalStalls,
            totalDropsNorth: project.totalDropsNorth,
            totalDropsEast: project.totalDropsEast,
            totalDropsSouth: project.totalDropsSouth,
            totalDropsWest: project.totalDropsWest,
            totalFloors: project.totalFloors,
            buildingFloors: project.buildingFloors,
            dailyDropTarget: project.dailyDropTarget,
            latitude: project.latitude,
            longitude: project.longitude,
          });
        } catch (buildingError) {
          // Log but don't fail project creation if building creation fails
          console.error("[Buildings] Failed to auto-create building:", buildingError);
        }
      }
      
      // If a clientId is provided, add the building to the client's lmsNumbers if not already present
      if (project.clientId && project.strataPlanNumber) {
        try {
          const client = await storage.getClientById(project.clientId);
          if (client) {
            const normalizedStrata = normalizeStrataPlan(project.strataPlanNumber);
            const existingBuildings = client.lmsNumbers || [];
            
            // Check if this strata already exists in the client's buildings
            const strataExists = existingBuildings.some(
              (b: { number: string }) => normalizeStrataPlan(b.number) === normalizedStrata
            );
            
            if (!strataExists) {
              // Add the new building to the client's lmsNumbers
              const newBuilding = {
                number: project.strataPlanNumber,
                buildingName: project.buildingName || undefined,
                address: project.buildingAddress || '',
                stories: project.floorCount || project.buildingFloors || undefined,
                parkingStalls: project.totalStalls || undefined,
                dailyDropTarget: project.dailyDropTarget || undefined,
                totalDropsNorth: project.totalDropsNorth || undefined,
                totalDropsEast: project.totalDropsEast || undefined,
                totalDropsSouth: project.totalDropsSouth || undefined,
                totalDropsWest: project.totalDropsWest || undefined,
              };
              
              await storage.updateClient(project.clientId, {
                lmsNumbers: [...existingBuildings, newBuilding],
              });
              
              console.log(`[Clients] Added new building ${normalizedStrata} to client ${client.firstName} ${client.lastName}`);
            }
          }
        } catch (clientError) {
          // Log but don't fail project creation
          console.error("[Clients] Failed to add building to client:", clientError);
        }
      }
      
      // If this is a custom job type, save it to the company's custom job types list (if not already exists)
      if ((project.jobType === "other" || project.jobType === "ndt_other") && project.customJobType) {
        const existingCustomJobType = await storage.getCustomJobTypeByName(companyId, project.customJobType);
        if (!existingCustomJobType) {
          await storage.createCustomJobType({
            companyId,
            jobTypeName: project.customJobType,
          });
        }
      }
      
      // Automatically create a scheduled job for this project if start/end dates are provided
      if (project.startDate && project.endDate) {
        const startDate = new Date(project.startDate);
        const endDate = new Date(project.endDate);
        
        // Create job title based on building name or strata plan number
        const jobTitle = project.buildingName || (project.strataPlanNumber ? `${normalizeStrataPlan(project.strataPlanNumber)} - ${project.jobType.replace(/_/g, ' ')}` : project.jobType.replace(/_/g, ' '));
        
        const job = await storage.createScheduledJob({
          companyId,
          projectId: project.id,
          title: jobTitle,
          description: `Auto-scheduled from project creation`,
          jobType: project.jobType,
          customJobType: project.customJobType,
          startDate,
          endDate,
          status: "upcoming",
          location: project.buildingAddress || null,
          color: project.calendarColor || "#3b82f6",
          estimatedHours: project.estimatedHours || null,
          actualHours: null,
          notes: null,
          createdBy: currentUser.id,
        });
        
        // Assign employees to the job if any were selected
        if (project.assignedEmployees && project.assignedEmployees.length > 0) {
          // Check for double-booking conflicts (unless forceAssignment is true)
          if (!req.body.forceAssignment) {
            const conflicts = await storage.checkEmployeeConflicts(project.assignedEmployees, startDate, endDate, job.id);
            
            if (conflicts.length > 0) {
              // Delete the job and project we just created
              await storage.deleteScheduledJob(job.id);
              await storage.deleteProject(project.id);
              return res.status(409).json({
                message: "Schedule conflict detected",
                conflicts,
              });
            }
          }
          
          await storage.replaceJobAssignments(job.id, project.assignedEmployees, currentUser.id);
        }
      }
      
      res.json({ project });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create project error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update project
  app.patch("/api/projects/:id", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { id } = req.params;
      
      // Get existing project to verify ownership
      const existingProject = await storage.getProjectById(id);
      if (!existingProject) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify access
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (existingProject.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Build update object with all allowed fields
      const allowedUpdates: any = {
        buildingName: req.body.buildingName,
        buildingAddress: req.body.buildingAddress,
        strataPlanNumber: req.body.strataPlanNumber,
        jobType: req.body.jobType,
        targetCompletionDate: req.body.targetCompletionDate || null,
        estimatedHours: req.body.estimatedHours,
        startDate: req.body.startDate || null,
        endDate: req.body.endDate || null,
      };
      
      // Add building height fields (for IRATA logbook tracking)
      if (req.body.buildingHeight !== undefined) allowedUpdates.buildingHeight = req.body.buildingHeight || null;
      if (req.body.floorCount !== undefined) allowedUpdates.floorCount = req.body.floorCount;
      if (req.body.buildingFloors !== undefined) allowedUpdates.buildingFloors = req.body.buildingFloors;
      
      // Add job-type specific fields
      if (req.body.totalDropsNorth !== undefined) allowedUpdates.totalDropsNorth = req.body.totalDropsNorth;
      if (req.body.totalDropsEast !== undefined) allowedUpdates.totalDropsEast = req.body.totalDropsEast;
      if (req.body.totalDropsSouth !== undefined) allowedUpdates.totalDropsSouth = req.body.totalDropsSouth;
      if (req.body.totalDropsWest !== undefined) allowedUpdates.totalDropsWest = req.body.totalDropsWest;
      if (req.body.dailyDropTarget !== undefined) allowedUpdates.dailyDropTarget = req.body.dailyDropTarget;
      if (req.body.totalFloors !== undefined) allowedUpdates.totalFloors = req.body.totalFloors;
      if (req.body.floorsPerDay !== undefined) allowedUpdates.floorsPerDay = req.body.floorsPerDay;
      if (req.body.totalStalls !== undefined) allowedUpdates.totalStalls = req.body.totalStalls;
      if (req.body.stallsPerDay !== undefined) allowedUpdates.stallsPerDay = req.body.stallsPerDay;
      
      // Add drop adjustment fields for correcting employee entries
      if (req.body.dropsAdjustmentNorth !== undefined) allowedUpdates.dropsAdjustmentNorth = req.body.dropsAdjustmentNorth;
      if (req.body.dropsAdjustmentEast !== undefined) allowedUpdates.dropsAdjustmentEast = req.body.dropsAdjustmentEast;
      if (req.body.dropsAdjustmentSouth !== undefined) allowedUpdates.dropsAdjustmentSouth = req.body.dropsAdjustmentSouth;
      if (req.body.dropsAdjustmentWest !== undefined) allowedUpdates.dropsAdjustmentWest = req.body.dropsAdjustmentWest;
      
      const updatedProject = await storage.updateProject(id, allowedUpdates);
      res.json({ project: updatedProject });
    } catch (error) {
      console.error("Update project error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all projects (filtered by role)
  app.get("/api/projects", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get status filter from query params (return all projects if not specified)
      const statusFilter = req.query.status as string | undefined;
      
      let projects: Project[];
      
      if (currentUser.role === "company") {
        // Return only THIS company's projects, filtered by status (all if not specified)
        projects = await storage.getProjectsByCompany(currentUser.id, statusFilter);
      } else if (EMPLOYEE_ROLES.includes(currentUser.role)) {
        // Return projects for their company, filtered by status (all if not specified)
        const companyId = currentUser.companyId;
        if (companyId) {
          projects = await storage.getProjectsByCompany(companyId, statusFilter);
        } else {
          projects = [];
        }
      } else if (currentUser.role === "resident") {
        // Return projects matching resident's company AND strata plan
        if (currentUser.companyId && currentUser.linkedResidentCode) {
          // Resident has linked - but first verify their code still matches
          const company = await storage.getUserById(currentUser.companyId);
          
          if (company && company.residentCode === currentUser.linkedResidentCode) {
            // Code still matches - show company's projects at this strata plan
            const allCompanyProjects = await storage.getProjectsByCompany(currentUser.companyId, statusFilter);
            projects = allCompanyProjects.filter(p => p.strataPlanNumber === currentUser.strataPlanNumber);
          } else {
            // Code has changed - unlink the resident (treat as not linked)
            console.log(`[/api/projects] Resident ${currentUser.email} code mismatch - unlinking`);
            await storage.updateUser(currentUser.id, { 
              companyId: null,
              linkedResidentCode: null
            });
            projects = []; // No projects - they need to re-link
          }
        } else {
          // Resident hasn't linked - no projects
          projects = [];
        }
      } else if (currentUser.role === "property_manager") {
        // Return projects from all linked companies
        projects = await storage.getProjectsForPropertyManager(currentUser.id, statusFilter);
      } else {
        projects = [];
      }
      
      // Filter out completed/deleted projects for users without view_past_projects permission
      // Company owners, property managers, and management roles have access by default
      const MANAGEMENT_ROLES_BACKEND = [
        'company', 'owner_ceo', 'human_resources', 'accounting', 
        'operations_manager', 'general_supervisor', 'rope_access_supervisor', 'account_manager'
      ];
      const hasViewPastProjectsPermission = 
        currentUser.role === 'company' ||
        currentUser.role === 'property_manager' ||
        MANAGEMENT_ROLES_BACKEND.includes(currentUser.role) ||
        (currentUser.permissions?.includes('view_past_projects') ?? false);
      
      if (!hasViewPastProjectsPermission) {
        // Filter to only active projects
        projects = projects.filter(p => p.status === 'active');
      }
      
      // Add completedDrops, totalDrops, and totalHoursWorked to each project
      const projectsWithProgress = await Promise.all(
        projects.map(async (project) => {
          const { total } = await storage.getProjectProgress(project.id);
          const totalDrops = (project.totalDropsNorth ?? 0) + 
                            (project.totalDropsEast ?? 0) + 
                            (project.totalDropsSouth ?? 0) + 
                            (project.totalDropsWest ?? 0);
          
          // Calculate total hours worked from work sessions (for hours-based tracking)
          const projectWorkSessions = await storage.getWorkSessionsByProject(project.id);
          const completedSessions = projectWorkSessions.filter(s => s.endTime);
          const totalHoursWorked = completedSessions.reduce((sum, session) => {
            if (session.startTime && session.endTime) {
              const hours = (new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / (1000 * 60 * 60);
              return sum + hours;
            }
            return sum;
          }, 0);
          
          // For percentage-based jobs, use the overallCompletionPercentage field (set by "last one out" technician)
          // Fall back to summing session percentages for backward compatibility with existing data
          let latestCompletionPercentage: number | null = null;
          
          if (project.overallCompletionPercentage !== null && project.overallCompletionPercentage !== undefined) {
            // Use the new "last one out" progress tracking system
            latestCompletionPercentage = project.overallCompletionPercentage;
          } else {
            // Fall back to legacy cumulative session percentage calculation
            const sessionsWithPercentage = completedSessions.filter(s => s.manualCompletionPercentage !== null && s.manualCompletionPercentage !== undefined);
            const cumulativeCompletionPercentage = sessionsWithPercentage.length > 0
              ? sessionsWithPercentage.reduce((sum: number, s) => sum + Number(s.manualCompletionPercentage ?? 0), 0)
              : null;
            // Cap at 100% and guard against NaN
            latestCompletionPercentage = cumulativeCompletionPercentage !== null && !isNaN(cumulativeCompletionPercentage)
              ? Math.min(100, cumulativeCompletionPercentage) 
              : null;
          }
          
          // Get assigned technicians from scheduled jobs and active workers
          const technicianMap = new Map<string, { id: string; name: string; photoUrl?: string | null; isActive: boolean }>();
          
          // 1. Get active workers (currently clocked in - endTime is null)
          const activeSessions = projectWorkSessions.filter(s => !s.endTime);
          for (const session of activeSessions) {
            if (!technicianMap.has(session.employeeId)) {
              const emp = await storage.getUserById(session.employeeId);
              if (emp) {
                technicianMap.set(session.employeeId, {
                  id: emp.id,
                  name: emp.fullName || emp.email,
                  photoUrl: emp.photoUrl,
                  isActive: true,
                });
              }
            }
          }
          
          // 2. Get scheduled technicians from jobAssignments linked to this project
          const projectScheduledJobs = await db.select().from(scheduledJobs)
            .where(eq(scheduledJobs.projectId, project.id));
          
          for (const job of projectScheduledJobs) {
            const assignments = await db.select().from(jobAssignments)
              .where(eq(jobAssignments.jobId, job.id));
            
            for (const assignment of assignments) {
              if (!technicianMap.has(assignment.employeeId)) {
                const emp = await storage.getUserById(assignment.employeeId);
                if (emp) {
                  technicianMap.set(assignment.employeeId, {
                    id: emp.id,
                    name: emp.fullName || emp.email,
                    photoUrl: emp.photoUrl,
                    isActive: false,
                  });
                }
              }
            }
          }
          
          // Convert map to array - active workers first
          const techArray = Array.from(technicianMap.values());
          techArray.sort((a, b) => {
            if (a.isActive && !b.isActive) return -1;
            if (!a.isActive && b.isActive) return 1;
            return a.name.localeCompare(b.name);
          });
          
          return {
            ...project,
            completedDrops: total,
            totalDrops,
            totalHoursWorked,
            latestCompletionPercentage,
            assignedTechnicians: techArray,
          };
        })
      );
      
      // Calculate project usage for dashboard display (company users only)
      // Note: Projects are unlimited for all tiers, so no limit enforcement needed
      let projectInfo = null;
      if (currentUser.role === "company") {
        const tier = currentUser.subscriptionTier || 'none';
        // Count active (non-completed) projects for display purposes
        const projectsUsed = projectsWithProgress.filter(p => p.status !== "completed").length;
        
        projectInfo = {
          tier,
          projectsUsed,
        };
      }
      
      // Disable caching to ensure fresh data
      res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
      res.json({ 
        projects: projectsWithProgress,
        projectInfo
      });
    } catch (error) {
      console.error("Get projects error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get single project
  app.get("/api/projects/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before returning project
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const project = await storage.getProjectById(req.params.id);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.role === "operations_manager" || 
                                    currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      // Check if user can view safety documents (rope access plans)
      const canViewSafetyDocs = canViewSafetyDocuments(currentUser);
      
      // Fetch company's resident code
      let companyResidentCode: string | null = null;
      try {
        const company = await storage.getUserById(project.companyId);
        if (company && company.residentCode) {
          companyResidentCode = company.residentCode;
        }
      } catch (error) {
        console.error('[/api/projects/:id] Failed to fetch company resident code:', error);
      }
      
      // Add completed drops (total and per-elevation) to the project
      const { north, east, south, west, total } = await storage.getProjectProgress(project.id);
      const projectWithProgress = {
        ...project,
        completedDrops: total,
        completedDropsNorth: north,
        completedDropsEast: east,
        completedDropsSouth: south,
        completedDropsWest: west,
        companyResidentCode, // Include company's resident code for all staff
      };
      
      // Filter sensitive data based on permissions
      let filteredProject = { ...projectWithProgress };
      
      // Filter financial data if user doesn't have financial permissions
      if (!canViewFinancialData) {
        filteredProject.estimatedHours = null;
      }
      
      // Filter rope access plan if user doesn't have safety document permissions
      if (!canViewSafetyDocs) {
        filteredProject.ropeAccessPlanUrl = null;
      }
      
      res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
      res.json({ project: filteredProject });
    } catch (error) {
      console.error("Get project error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get residents for a project
  app.get("/api/projects/:id/residents", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only company and management roles can view residents
      if (!["company", "operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor"].includes(currentUser.role)) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Verify access to this project
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const project = await storage.getProjectById(req.params.id);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Get all residents with matching strata plan number
      const residents = project.strataPlanNumber 
        ? await storage.getResidentsByStrataPlan(project.strataPlanNumber)
        : [];
      
      // Return residents without sensitive data
      const residentsData = residents.map(resident => ({
        id: resident.id,
        email: resident.email,
        name: resident.name,
        unitNumber: resident.unitNumber,
        phoneNumber: resident.phoneNumber,
        strataPlanNumber: resident.strataPlanNumber,
      }));
      
      res.json({ residents: residentsData });
    } catch (error) {
      console.error("Get project residents error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update project status
  app.patch("/api/projects/:id/status", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before updating
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const { status } = req.body;
      
      if (!["active", "completed"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }
      
      const project = await storage.updateProjectStatus(req.params.id, status);
      res.json({ project });
    } catch (error) {
      console.error("Update project status error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete project
  app.delete("/api/projects/:id", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before deleting
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteProject(req.params.id);
      res.json({ message: "Project deleted successfully" });
    } catch (error) {
      console.error("Delete project error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get deleted projects
  app.get("/api/projects/deleted/list", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const deletedProjects = await storage.getDeletedProjects(companyId);
      res.json({ projects: deletedProjects });
    } catch (error) {
      console.error("Get deleted projects error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Restore deleted project
  app.post("/api/projects/:id/restore", requireAuth, requireRole("company", "operations_manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const restoredProject = await storage.restoreProject(req.params.id);
      res.json({ project: restoredProject });
    } catch (error) {
      console.error("Restore project error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== WORK NOTICES ROUTES ====================
  
  // Get work notices for a project
  app.get("/api/projects/:projectId/work-notices", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify project access
      const hasAccess = await storage.verifyProjectAccess(
        req.params.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const notices = await db.select().from(workNotices)
        .where(eq(workNotices.projectId, req.params.projectId))
        .orderBy(desc(workNotices.createdAt));
      
      res.json({ notices });
    } catch (error) {
      console.error("Get work notices error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Create work notice for a project
  app.post("/api/projects/:projectId/work-notices", requireAuth, requireRole("company", "operations_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the project to auto-fill details
      const project = await storage.getProjectById(req.params.projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify project access
      const hasAccess = await storage.verifyProjectAccess(
        req.params.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get company info
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const company = await storage.getUserById(companyId);
      
      // Validate request body
      const validatedData = insertWorkNoticeSchema.parse({
        ...req.body,
        projectId: req.params.projectId,
        companyId: companyId,
        buildingName: project.buildingName,
        buildingAddress: project.buildingAddress,
        strataPlanNumber: project.strataPlanNumber,
        contractorName: company?.companyName || "Contractor",
        jobType: project.jobType,
        customJobType: project.customJobType,
        companyLogoUrl: company?.whitelabelBrandingActive ? company.brandingLogoUrl : null,
      });
      
      const [notice] = await db.insert(workNotices).values(validatedData).returning();
      
      res.status(201).json({ notice });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create work notice error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update work notice
  app.patch("/api/work-notices/:id", requireAuth, requireRole("company", "operations_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the notice first
      const [existingNotice] = await db.select().from(workNotices)
        .where(eq(workNotices.id, req.params.id));
      
      if (!existingNotice) {
        return res.status(404).json({ message: "Work notice not found" });
      }
      
      // Verify company access
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (existingNotice.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const { startDate, endDate, noticeTitle, noticeDetails, additionalInstructions, isPublished, propertyManagerName } = req.body;
      
      const [updatedNotice] = await db.update(workNotices)
        .set({
          startDate: startDate ?? existingNotice.startDate,
          endDate: endDate ?? existingNotice.endDate,
          noticeTitle: noticeTitle ?? existingNotice.noticeTitle,
          noticeDetails: noticeDetails ?? existingNotice.noticeDetails,
          additionalInstructions: additionalInstructions !== undefined ? additionalInstructions : existingNotice.additionalInstructions,
          propertyManagerName: propertyManagerName !== undefined ? propertyManagerName : existingNotice.propertyManagerName,
          isPublished: isPublished !== undefined ? isPublished : existingNotice.isPublished,
          updatedAt: new Date(),
        })
        .where(eq(workNotices.id, req.params.id))
        .returning();
      
      res.json({ notice: updatedNotice });
    } catch (error) {
      console.error("Update work notice error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete work notice
  app.delete("/api/work-notices/:id", requireAuth, requireRole("company", "operations_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the notice first
      const [existingNotice] = await db.select().from(workNotices)
        .where(eq(workNotices.id, req.params.id));
      
      if (!existingNotice) {
        return res.status(404).json({ message: "Work notice not found" });
      }
      
      // Verify company access
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (existingNotice.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await db.delete(workNotices).where(eq(workNotices.id, req.params.id));
      
      res.json({ message: "Work notice deleted successfully" });
    } catch (error) {
      console.error("Delete work notice error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get work notices for resident (based on their strata plan number)
  app.get("/api/resident/work-notices", requireAuth, requireRole("resident"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!currentUser.strataPlanNumber) {
        return res.status(400).json({ message: "No building linked to your account" });
      }
      
      // Get published work notices for the resident's building
      const rawNotices = await db.select().from(workNotices)
        .where(and(
          eq(workNotices.strataPlanNumber, currentUser.strataPlanNumber),
          eq(workNotices.isPublished, true)
        ))
        .orderBy(desc(workNotices.createdAt));
      
      // Map field names for frontend compatibility and fetch company branding
      const notices = await Promise.all(rawNotices.map(async (notice) => {
        // Get company branding if available (from users table brandingLogoUrl)
        let logoUrl = notice.companyLogoUrl;
        if (!logoUrl && notice.companyId) {
          const [company] = await db.select({ brandingLogoUrl: users.brandingLogoUrl })
            .from(users)
            .where(eq(users.id, notice.companyId))
            .limit(1);
          if (company?.brandingLogoUrl) {
            logoUrl = company.brandingLogoUrl;
          }
        }
        
        return {
          ...notice,
          // Map to frontend-expected field names
          title: notice.noticeTitle,
          content: notice.noticeDetails,
          workStartDate: notice.startDate,
          workEndDate: notice.endDate,
          logoUrl: logoUrl,
          contractors: notice.contractorName,
          // Ensure unit schedule is included
          unitSchedule: notice.unitSchedule,
          jobType: notice.jobType,
        };
      }));
      
      res.json({ notices });
    } catch (error) {
      console.error("Get resident work notices error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get project progress
  app.get("/api/projects/:id/progress", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before returning progress
      const hasAccess = await storage.verifyProjectAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const project = await storage.getProjectById(req.params.id);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      const { north, east, south, west, total } = await storage.getProjectProgress(req.params.id);
      const totalDrops = (project.totalDropsNorth ?? 0) + 
                        (project.totalDropsEast ?? 0) + 
                        (project.totalDropsSouth ?? 0) + 
                        (project.totalDropsWest ?? 0);
      
      // For in-suite dryer vent cleaning, use floorCount as total units instead of totalDrops
      const isInSuite = project.jobType === 'in_suite_dryer_vent_cleaning';
      const isParkade = project.jobType === 'parkade_pressure_cleaning';
      
      // Check if this job uses percentage-based progress (hours-based or non-elevation jobs)
      const usesPercentage = usesPercentageProgress(project.jobType, project.requiresElevation ?? true);
      
      const totalUnits = isInSuite 
        ? (project.floorCount ?? 0) 
        : isParkade 
        ? (project.floorCount ?? 0)  // For parkade, floorCount stores total stalls
        : totalDrops;
      
      // For percentage-based jobs, use overallCompletionPercentage from the project
      // For unit-based jobs, calculate from completed units
      let progressPercentage: number;
      if (usesPercentage) {
        progressPercentage = project.overallCompletionPercentage ?? 0;
      } else {
        progressPercentage = totalUnits > 0 ? (total / totalUnits) * 100 : 0;
      }
      
      res.json({
        completedDrops: total,
        completedDropsNorth: north,
        completedDropsEast: east,
        completedDropsSouth: south,
        completedDropsWest: west,
        totalDrops: isInSuite ? (project.floorCount ?? 0) : isParkade ? (project.floorCount ?? 0) : totalDrops,
        totalDropsNorth: project.totalDropsNorth ?? 0,
        totalDropsEast: project.totalDropsEast ?? 0,
        totalDropsSouth: project.totalDropsSouth ?? 0,
        totalDropsWest: project.totalDropsWest ?? 0,
        totalStalls: isParkade ? (project.floorCount ?? 0) : undefined,
        completedStalls: isParkade ? total : undefined,
        progressPercentage: Math.round(progressPercentage),
        usesPercentageProgress: usesPercentage,
        overallCompletionPercentage: project.overallCompletionPercentage,
      });
    } catch (error) {
      console.error("Get project progress error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== DROP LOG ROUTES ====================
  
  // Create or update drop log - allow all employee roles to log drops
  app.post("/api/drops", requireAuth, requireRole("rope_access_tech", "operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const dropData = insertDropLogSchema.parse({
        ...req.body,
        userId: req.session.userId,
      });
      
      // Verify tech has access to this project before logging drops
      const hasAccess = await storage.verifyProjectAccess(
        dropData.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied - you cannot log drops for this project" });
      }
      
      // Check if drop log already exists for this project/user/date
      const existingLog = await storage.getDropLogByProjectAndDate(
        dropData.projectId,
        dropData.userId,
        dropData.date
      );
      
      let dropLog;
      if (existingLog) {
        // Update existing log with directional drops (method expects 5 args: id + 4 numbers)
        dropLog = await storage.updateDropLog(
          existingLog.id,
          dropData.dropsCompletedNorth || 0,
          dropData.dropsCompletedEast || 0,
          dropData.dropsCompletedSouth || 0,
          dropData.dropsCompletedWest || 0
        );
      } else {
        // Create new log
        dropLog = await storage.createDropLog(dropData);
      }
      
      res.json({ dropLog });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create drop log error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get drop logs for a project
  app.get("/api/projects/:projectId/drops", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before returning drops
      const hasAccess = await storage.verifyProjectAccess(
        req.params.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const drops = await storage.getDropLogsByProject(req.params.projectId);
      res.json({ drops });
    } catch (error) {
      console.error("Get drop logs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get current user's drops for today (for daily target tracking)
  app.get("/api/my-drops-today", requireAuth, async (req: Request, res: Response) => {
    try {
      const today = new Date().toISOString().split('T')[0];
      const dropLogs = await storage.getDropLogsByUserAndDate(req.session.userId!, today);
      
      // Sum up all directional drops
      const totalDropsToday = dropLogs.reduce((sum, log) => {
        return sum + (log.dropsCompletedNorth || 0) + (log.dropsCompletedEast || 0) + 
               (log.dropsCompletedSouth || 0) + (log.dropsCompletedWest || 0);
      }, 0);
      
      res.json({ 
        totalDropsToday,
        dropLogs 
      });
    } catch (error) {
      console.error("Get today's drops error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== WORK SESSION ROUTES ====================

  // ==================== ROPE ACCESS PLAN SIGNATURE ROUTES ====================
  
  // Check if employee needs to sign rope access plan for a project
  app.get("/api/projects/:projectId/rope-access-plan/check", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const project = await storage.getProjectById(projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // If no rope access plan exists, no signature needed
      if (!project.ropeAccessPlanUrl) {
        return res.json({ 
          needsSignature: false, 
          hasPlan: false,
          message: "No rope access plan uploaded for this project"
        });
      }
      
      // Check if employee already signed
      const existingSignature = await storage.getRopeAccessPlanSignature(projectId, currentUser.id);
      
      if (existingSignature) {
        return res.json({ 
          needsSignature: false, 
          hasPlan: true,
          alreadySigned: true,
          signedAt: existingSignature.signedAt
        });
      }
      
      // Plan exists but not signed
      return res.json({ 
        needsSignature: true, 
        hasPlan: true,
        planUrl: project.ropeAccessPlanUrl,
        projectName: project.name
      });
    } catch (error) {
      console.error("Check rope access plan error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Sign the rope access plan
  app.post("/api/projects/:projectId/rope-access-plan/sign", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const { signatureDataUrl } = req.body;
      
      if (!signatureDataUrl) {
        return res.status(400).json({ message: "Signature is required" });
      }
      
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      if (!project.ropeAccessPlanUrl) {
        return res.status(400).json({ message: "No rope access plan exists for this project" });
      }
      
      // Check if already signed
      const existingSignature = await storage.getRopeAccessPlanSignature(projectId, currentUser.id);
      if (existingSignature) {
        return res.status(400).json({ message: "You have already signed this rope access plan" });
      }
      
      // Create signature record
      const signature = await storage.createRopeAccessPlanSignature({
        companyId: project.companyId,
        projectId: projectId,
        employeeId: currentUser.id,
        documentName: `Rope Access Plan - ${project.name}`,
        fileUrl: project.ropeAccessPlanUrl,
        signatureDataUrl: signatureDataUrl,
      });
      
      res.json({ signature, message: "Rope access plan signed successfully" });
    } catch (error) {
      console.error("Sign rope access plan error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all signatures for a project's rope access plan (for audits)
  app.get("/api/projects/:projectId/rope-access-plan/signatures", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const project = await storage.getProjectById(projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify company access
      if (project.companyId !== currentUser.companyId && currentUser.role !== 'superuser') {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const signatures = await storage.getRopeAccessPlanSignatures(projectId);
      
      // Add employee names to signatures
      const signaturesWithNames = await Promise.all(
        signatures.map(async (sig: any) => {
          const employee = await storage.getUserById(sig.employeeId);
          return {
            ...sig,
            employeeName: employee ? `${employee.firstName} ${employee.lastName}` : 'Unknown Employee'
          };
        })
      );
      
      res.json({ 
        signatures: signaturesWithNames,
        hasPlan: !!project.ropeAccessPlanUrl,
        planUrl: project.ropeAccessPlanUrl,
        projectName: project.name
      });
    } catch (error) {
      console.error("Get rope access plan signatures error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Generate PDF of rope access plan with all signatures (for audits)
  app.get("/api/projects/:projectId/rope-access-plan/pdf", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const project = await storage.getProjectById(projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify company access
      if (project.companyId !== currentUser.companyId && currentUser.role !== 'superuser') {
        return res.status(403).json({ message: "Access denied" });
      }
      
      if (!project.ropeAccessPlanUrl) {
        return res.status(400).json({ message: "No rope access plan exists for this project" });
      }
      
      // Get all signatures
      const signatures = await storage.getRopeAccessPlanSignatures(projectId);
      
      // Use jspdf to create PDF with signature sheet
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF();
      
      // Header
      doc.setFontSize(18);
      doc.text('Rope Access Plan Signature Sheet', 105, 20, { align: 'center' });
      
      doc.setFontSize(12);
      doc.text(`Project: ${project.name}`, 20, 35);
      doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 42);
      doc.text(`Total Signatures: ${signatures.length}`, 20, 49);
      
      // Horizontal line
      doc.line(20, 55, 190, 55);
      
      // Signatures table header
      let yPos = 65;
      doc.setFontSize(10);
      doc.setFont(undefined, 'bold');
      doc.text('Employee Name', 20, yPos);
      doc.text('Signed Date', 100, yPos);
      doc.text('Signature', 150, yPos);
      doc.setFont(undefined, 'normal');
      
      yPos += 10;
      
      // Add each signature
      for (const sig of signatures) {
        // Check if we need a new page
        if (yPos > 270) {
          doc.addPage();
          yPos = 20;
        }
        
        const employee = await storage.getUserById(sig.employeeId);
        const employeeName = employee ? `${employee.firstName} ${employee.lastName}` : 'Unknown Employee';
        const signedDate = sig.signedAt ? new Date(sig.signedAt).toLocaleString() : 'N/A';
        
        doc.text(employeeName, 20, yPos);
        doc.text(signedDate, 100, yPos);
        
        // Add signature image if available
        if (sig.signatureDataUrl && sig.signatureDataUrl.startsWith('data:image')) {
          try {
            doc.addImage(sig.signatureDataUrl, 'PNG', 150, yPos - 6, 30, 12);
          } catch (imgError) {
            doc.text('[Signature]', 150, yPos);
          }
        } else {
          doc.text('[Signed]', 150, yPos);
        }
        
        yPos += 15;
      }
      
      // Footer
      doc.setFontSize(8);
      doc.text('This document certifies that all listed employees have reviewed and signed the Rope Access Plan.', 105, 290, { align: 'center' });
      
      // Send PDF
      const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="rope-access-plan-signatures-${project.name.replace(/[^a-zA-Z0-9]/g, '-')}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Generate rope access plan PDF error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  
  // Start a work session
  app.post("/api/projects/:projectId/work-sessions/start", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const { startLatitude, startLongitude, workDate } = req.body;
      
      // Verify employee has access to this project
      const hasAccess = await storage.verifyProjectAccess(
        projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied - you cannot work on this project" });
      }
      
      // Check if there's already an active session (billable or non-billable) anywhere
      const existingSession = await storage.getAnyActiveSession(currentUser.id);
      
      if (existingSession) {
        if (existingSession.type === 'billable') {
          return res.status(400).json({ 
            message: `You already have an active work session at "${existingSession.projectName || 'another project'}". Please clock out first.`,
            activeSession: {
              type: 'billable',
              projectName: existingSession.projectName,
              startTime: existingSession.session.startTime
            }
          });
        } else {
          return res.status(400).json({ 
            message: `You already have an active non-billable session ("${existingSession.description || 'activity'}"). Please clock out first.`,
            activeSession: {
              type: 'non_billable',
              description: existingSession.description,
              startTime: existingSession.session.startTime
            }
          });
        }
      }
      
      // Get project to access company ID
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Check if rope access plan exists and requires signature
      if (project.ropeAccessPlanUrl) {
        const existingSignature = await storage.getRopeAccessPlanSignature(projectId, currentUser.id);
        if (!existingSignature) {
          return res.status(400).json({ 
            message: "You must review and sign the Rope Access Plan before starting work on this project.",
            requiresSignature: true,
            ropeAccessPlan: {
              projectId: projectId,
              projectName: project.name,
              planUrl: project.ropeAccessPlanUrl
            }
          });
        }
      }
      
      // Create new work session
      const now = new Date();
      // Use client's local date if provided, otherwise fall back to server date
      const sessionDate = workDate || now.toISOString().split('T')[0];
      const session = await storage.startWorkSession({
        projectId,
        employeeId: currentUser.id,
        companyId: project.companyId,
        workDate: sessionDate, // Use client's local date
        startTime: now,
        startLatitude: startLatitude || null,
        startLongitude: startLongitude || null,
      });
      
      res.json({ session });
    } catch (error) {
      console.error("Start work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // End a work session
  app.patch("/api/projects/:projectId/work-sessions/:sessionId/end", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { sessionId } = req.params;
      const { dropsCompletedNorth, dropsCompletedEast, dropsCompletedSouth, dropsCompletedWest, shortfallReason, validShortfallReasonCode, endLatitude, endLongitude, manualCompletionPercentage, ropeAccessTaskHours } = req.body;
      
      // Get the session to verify ownership
      const activeSession = await storage.getActiveWorkSession(currentUser.id, req.params.projectId);
      
      if (!activeSession || activeSession.id !== sessionId) {
        return res.status(403).json({ message: "Access denied - not your active session" });
      }
      
      // Get project to check daily target
      const project = await storage.getProjectById(req.params.projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Validate manual completion percentage for percentage-based job types
      // Use shared utility that accounts for hours-based jobs AND non-elevation drop-based jobs
      const isPercentageBasedJob = usesPercentageProgress(project.jobType, project.requiresElevation);
      let validatedPercentage: number | undefined = undefined;
      
      // For percentage-based jobs, the completion percentage is NOT required upfront
      // Only the "last one out" will be prompted to update overall project progress AFTER session ends
      // If a percentage is provided (optional), validate it
      if (isPercentageBasedJob && manualCompletionPercentage !== undefined && manualCompletionPercentage !== null) {
        // Only accept string or number types
        if (typeof manualCompletionPercentage !== 'string' && typeof manualCompletionPercentage !== 'number') {
          return res.status(400).json({ message: "Completion percentage must be a number" });
        }
        
        // Strict validation: reject malformed numeric strings
        let percentageValue: number;
        if (typeof manualCompletionPercentage === 'string') {
          const trimmed = manualCompletionPercentage.trim();
          // Reject empty or whitespace-only strings
          if (trimmed.length === 0) {
            return res.status(400).json({ message: "Completion percentage cannot be empty" });
          }
          // Strict regex: only allow decimal numbers (blocks hex like 0x10, binary, etc.)
          if (!/^\d+(\.\d+)?$/.test(trimmed)) {
            return res.status(400).json({ message: "Completion percentage must be a valid decimal number" });
          }
          percentageValue = Number(trimmed);
          // Explicit NaN check after conversion (defensive)
          if (isNaN(percentageValue)) {
            return res.status(400).json({ message: "Completion percentage must be a valid number" });
          }
        } else {
          percentageValue = manualCompletionPercentage;
          // Check for NaN in numeric inputs
          if (isNaN(percentageValue)) {
            return res.status(400).json({ message: "Completion percentage must be a valid number" });
          }
        }
        
        // Range validation
        if (percentageValue < 0 || percentageValue > 100) {
          return res.status(400).json({ message: "Completion percentage must be between 0 and 100" });
        }
        
        validatedPercentage = percentageValue;
      }
      
      // For percentage-based jobs, ignore drop counts entirely - set to 0
      // For drop-based jobs, validate elevation drops (ensure they are numbers and non-negative)
      let north = 0, east = 0, south = 0, west = 0;
      let totalDropsCompleted = 0;
      
      if (!isPercentageBasedJob) {
        north = typeof dropsCompletedNorth === 'number' ? dropsCompletedNorth : 0;
        east = typeof dropsCompletedEast === 'number' ? dropsCompletedEast : 0;
        south = typeof dropsCompletedSouth === 'number' ? dropsCompletedSouth : 0;
        west = typeof dropsCompletedWest === 'number' ? dropsCompletedWest : 0;
        
        if (north < 0 || east < 0 || south < 0 || west < 0) {
          return res.status(400).json({ message: "Invalid drops completed value" });
        }
        
        totalDropsCompleted = north + east + south + west;
        
        // If drops < target, require either a valid reason code OR shortfall explanation (only if dailyDropTarget is set)
        const approvedCodes = VALID_SHORTFALL_REASONS.map(r => r.code);
        const isCodeApproved = validShortfallReasonCode && approvedCodes.includes(validShortfallReasonCode);
        
        // Reject unknown codes
        if (validShortfallReasonCode && validShortfallReasonCode !== '' && !isCodeApproved) {
          return res.status(400).json({ message: "Invalid shortfall reason code" });
        }
        
        const hasValidReasonCode = isCodeApproved && validShortfallReasonCode !== 'other';
        const hasOtherWithExplanation = validShortfallReasonCode === 'other' && shortfallReason?.trim();
        const hasShortfallExplanation = shortfallReason?.trim();
        
        if (project.dailyDropTarget && totalDropsCompleted < project.dailyDropTarget && !hasValidReasonCode && !hasOtherWithExplanation && !hasShortfallExplanation) {
          return res.status(400).json({ message: "A reason is required when drops completed is less than the daily target" });
        }
      }
      
      // Calculate overtime breakdown
      const now = new Date();
      const overtimeBreakdown = await calculateOvertimeHours(
        project.companyId,
        currentUser.id,
        new Date(activeSession.workDate),
        new Date(activeSession.startTime),
        now
      );
      
      // Prepare manual completion percentage (rounded to integer for hours-based jobs)
      // Use the validatedPercentage from earlier validation
      const completionPercentage = validatedPercentage !== undefined ? Math.round(validatedPercentage) : undefined;
      
      // Calculate peace work pay if project has peace work enabled
      let peaceWorkPay: number | null = null;
      if (project.peaceWork && project.pricePerDrop) {
        peaceWorkPay = totalDropsCompleted * project.pricePerDrop;
        console.log(`[PEACE WORK] Project ${project.id}: ${totalDropsCompleted} drops Ã— $${project.pricePerDrop} = $${peaceWorkPay}`);
      }
      
      // Calculate labor cost (total hours Ã— employee hourly rate)
      const employeeHourlyRate = currentUser.hourlyRate ? parseFloat(currentUser.hourlyRate) : null;
      const totalHoursWorked = overtimeBreakdown.regularHours + overtimeBreakdown.overtimeHours + overtimeBreakdown.doubleTimeHours;
      // Calculate labor cost: regular hours at base rate, OT at 1.5x, double time at 2x
      let laborCost: number | null = null;
      if (employeeHourlyRate !== null) {
        laborCost = (overtimeBreakdown.regularHours * employeeHourlyRate) +
                    (overtimeBreakdown.overtimeHours * employeeHourlyRate * 1.5) +
                    (overtimeBreakdown.doubleTimeHours * employeeHourlyRate * 2);
        console.log(`[LABOR COST] Session ${sessionId}: ${totalHoursWorked.toFixed(2)}hrs Ã— $${employeeHourlyRate}/hr = $${laborCost.toFixed(2)}`);
      }
      
      // Validate rope access task hours - OPTIONAL, only validate if provided
      let validatedRopeAccessHours: number | null = null;
      if (ropeAccessTaskHours !== undefined && ropeAccessTaskHours !== null && ropeAccessTaskHours !== '') {
        const hoursValue = typeof ropeAccessTaskHours === 'number' ? ropeAccessTaskHours : parseFloat(String(ropeAccessTaskHours));
        if (isNaN(hoursValue)) {
          return res.status(400).json({ message: "Rope access task hours must be a valid number" });
        }
        if (hoursValue < 0 || hoursValue > 24) {
          return res.status(400).json({ message: "Rope access task hours must be between 0 and 24" });
        }
        // Enforce quarter-hour increments for IRATA/SPRAT compliance
        if ((hoursValue * 4) % 1 !== 0) {
          return res.status(400).json({ message: "Rope access task hours must be in quarter-hour increments (0.25, 0.5, 0.75, etc.)" });
        }
        validatedRopeAccessHours = hoursValue;
      }
      
      // End the session with elevation-specific drops and overtime hours
      // For percentage-based jobs, never record shortfall reason (they don't use drop targets)
      const shouldRecordReason = !isPercentageBasedJob && project.dailyDropTarget && totalDropsCompleted < project.dailyDropTarget;
      const session = await storage.endWorkSession(
        sessionId,
        north,
        east,
        south,
        west,
        shouldRecordReason ? shortfallReason : undefined,
        endLatitude || null,
        endLongitude || null,
        overtimeBreakdown.regularHours,
        overtimeBreakdown.overtimeHours,
        overtimeBreakdown.doubleTimeHours,
        completionPercentage,
        peaceWorkPay,
        laborCost,
        employeeHourlyRate,
        shouldRecordReason ? validShortfallReasonCode : undefined,
        validatedRopeAccessHours
      );
      
      // Check if this is a percentage-based job and if this tech is the "last one out" for today
      let requiresProgressPrompt = false;
      // isPercentageBasedJob was already computed above for validation
      
      console.log("[END SESSION] Job type:", project.jobType, "requiresElevation:", project.requiresElevation, "isPercentageBasedJob:", isPercentageBasedJob);
      
      if (isPercentageBasedJob) {
        // Check if there are other sessions that overlap with today's calendar work day
        // Using project-local timezone for accurate day boundary calculations
        const allProjectSessions = await storage.getWorkSessionsByProject(project.id, project.companyId);
        
        // Get company to determine timezone (project timezone overrides company default)
        const company = await storage.getUserById(project.companyId);
        const projectTimezone = getProjectTimezone(project, company || {});
        
        console.log("[END SESSION] Total project sessions:", allProjectSessions.length, "Timezone:", projectTimezone);
        
        const otherActiveSessions = allProjectSessions.filter(s => {
          if (s.id === sessionId) return false; // Not the session we just ended
          if (!s.startTime) return false; // Invalid session (no start time)
          if (s.endTime) return false; // Session already ended - not active
          
          const sessionStart = new Date(s.startTime);
          
          // Check if this still-active session overlaps with today's window in project timezone
          const overlaps = sessionOverlapsDay(sessionStart, null, projectTimezone);
          console.log("[END SESSION] Active session", s.id, "overlaps today:", overlaps);
          return overlaps;
        });
        
        console.log("[END SESSION] Other active sessions overlapping today:", otherActiveSessions.length);
        
        // If no other sessions overlap with today, this tech is the "last one out"
        if (otherActiveSessions.length === 0) {
          requiresProgressPrompt = true;
        }
      }
      
      console.log("[END SESSION] Returning requiresProgressPrompt:", requiresProgressPrompt);
      
      res.json({ 
        session,
        requiresProgressPrompt,
        currentOverallProgress: isPercentageBasedJob ? (project.overallCompletionPercentage ?? 0) : undefined
      });
    } catch (error) {
      console.error("End work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update project overall completion percentage (called by "last one out" technician)
  app.patch("/api/projects/:projectId/overall-progress", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { projectId } = req.params;
      const { completionPercentage, skip } = req.body;
      
      // Get project
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify the user belongs to this company
      const userCompanyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (project.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if this is a percentage-based job
      const isPercentageBasedJob = usesPercentageProgress(project.jobType, project.requiresElevation);
      if (!isPercentageBasedJob) {
        return res.status(400).json({ message: "This project does not use percentage-based progress tracking" });
      }
      
      // If skip is true, just return success without updating
      if (skip === true) {
        return res.json({ 
          message: "Progress update skipped",
          project: { 
            id: project.id, 
            overallCompletionPercentage: project.overallCompletionPercentage 
          } 
        });
      }
      
      // Validate completion percentage
      if (completionPercentage === undefined || completionPercentage === null) {
        return res.status(400).json({ message: "Completion percentage is required" });
      }
      
      const percentage = typeof completionPercentage === 'string' 
        ? parseInt(completionPercentage, 10) 
        : completionPercentage;
      
      if (isNaN(percentage) || percentage < 0 || percentage > 100) {
        return res.status(400).json({ message: "Completion percentage must be between 0 and 100" });
      }
      
      // Update the project with the new overall completion percentage
      const updatedProject = await storage.updateProject(projectId, {
        overallCompletionPercentage: percentage,
        lastProgressUpdateBy: currentUser.id,
        lastProgressUpdateAt: new Date(),
      });
      
      console.log(`[PROGRESS UPDATE] Project ${projectId}: Updated to ${percentage}% by ${currentUser.fullName || currentUser.email}`);
      
      res.json({ 
        message: "Progress updated successfully",
        project: { 
          id: updatedProject.id, 
          overallCompletionPercentage: updatedProject.overallCompletionPercentage 
        } 
      });
    } catch (error) {
      console.error("Update project progress error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Edit/update existing work session (requires financial permission)
  app.patch("/api/work-sessions/:sessionId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // CRITICAL SECURITY: Check financial permission before allowing edits
      const hasFinancialPermission = currentUser.role === "company" || 
                                     currentUser.viewFinancialData === true ||
                                     currentUser.role === "operations_manager" || 
                                     currentUser.role === "supervisor" || 
                                     currentUser.role === "general_supervisor" || 
                                     currentUser.role === "rope_access_supervisor" || 
                                     currentUser.permissions?.includes("view_financial_data");
      
      if (!hasFinancialPermission) {
        return res.status(403).json({ message: "Access denied - financial permission required to edit work sessions" });
      }
      
      const { sessionId } = req.params;
      const { startTime, endTime, dropsCompletedNorth, dropsCompletedEast, dropsCompletedSouth, dropsCompletedWest, manualCompletionPercentage, isBillable } = req.body;
      
      // CRITICAL SECURITY: Get company ID and fetch session with company-scoped query
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(403).json({ message: "Unable to determine company" });
      }
      
      // Company-scoped query ensures session belongs to requester's company
      const existingSession = await storage.getWorkSessionForCompany(sessionId, companyId);
      if (!existingSession) {
        // Either session doesn't exist OR it belongs to another company (intentionally ambiguous for security)
        return res.status(404).json({ message: "Work session not found" });
      }
      
      // Get project to check job type for validation (company ownership already verified)
      const project = await storage.getProjectById(existingSession.projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Prepare updates object
      const updates: any = {};
      
      // Handle time updates and recalculate overtime if both times provided
      if (startTime !== undefined) {
        updates.startTime = new Date(startTime);
      }
      if (endTime !== undefined) {
        updates.endTime = endTime ? new Date(endTime) : null;
      }
      
      // Recalculate overtime hours if both start and end times are available
      if ((updates.startTime || existingSession.startTime) && (updates.endTime || existingSession.endTime)) {
        const finalStartTime = updates.startTime || new Date(existingSession.startTime);
        const finalEndTime = updates.endTime || new Date(existingSession.endTime);
        
        const overtimeBreakdown = await calculateOvertimeHours(
          project.companyId,
          existingSession.employeeId,
          finalStartTime,
          finalStartTime,
          finalEndTime
        );
        
        updates.regularHours = overtimeBreakdown.regularHours.toString();
        updates.overtimeHours = overtimeBreakdown.overtimeHours.toString();
        updates.doubleTimeHours = overtimeBreakdown.doubleTimeHours.toString();
      }
      
      // Handle drops completed for elevation-based projects
      if (dropsCompletedNorth !== undefined) updates.dropsCompletedNorth = parseInt(dropsCompletedNorth);
      if (dropsCompletedEast !== undefined) updates.dropsCompletedEast = parseInt(dropsCompletedEast);
      if (dropsCompletedSouth !== undefined) updates.dropsCompletedSouth = parseInt(dropsCompletedSouth);
      if (dropsCompletedWest !== undefined) updates.dropsCompletedWest = parseInt(dropsCompletedWest);
      
      // Handle manual completion percentage for hours-based projects
      const isHoursBased = project.jobType === "general_pressure_washing" || project.jobType === "ground_window_cleaning";
      if (isHoursBased && manualCompletionPercentage !== undefined) {
        const percentage = parseInt(manualCompletionPercentage);
        if (percentage < 0 || percentage > 100) {
          return res.status(400).json({ message: "Completion percentage must be between 0 and 100" });
        }
        updates.manualCompletionPercentage = percentage;
      }
      
      // Handle billable status
      if (isBillable !== undefined) {
        updates.isBillable = isBillable;
      }
      
      // Update the session
      const updatedSession = await storage.updateWorkSession(sessionId, updates);
      
      res.json({ session: updatedSession });
    } catch (error) {
      console.error("Update work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get work sessions for a project (management and tech view)
  app.get("/api/projects/:projectId/work-sessions", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get company ID
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify access to project
      const hasAccess = await storage.verifyProjectAccess(
        req.params.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.role === "operations_manager" || 
                                    currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      const sessions = await storage.getWorkSessionsByProject(req.params.projectId, companyId);
      
      // Filter financial data if user doesn't have financial permissions
      const filteredSessions = canViewFinancialData ? sessions : sessions.map(session => ({
        ...session,
        techHourlyRate: null,
      }));
      
      res.json({ sessions: filteredSessions });
    } catch (error) {
      console.error("Get work sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all work sessions across all company projects
  app.get("/api/all-work-sessions", requireAuth, async (req: Request, res: Response) => {
    // Disable caching to ensure fresh data (drops change frequently)
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Determine company ID
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.role === "operations_manager" || 
                                    currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      // Get all projects for the company
      const projects = await storage.getProjectsByCompany(companyId);
      
      // Collect all work sessions across all projects with their project's daily target
      const allSessions = [];
      for (const project of projects) {
        const projectSessions = await storage.getWorkSessionsByProject(project.id, companyId);
        
        // Determine the correct target field based on job type
        let dailyTarget = project.dailyDropTarget || 0;
        if (project.jobType === 'parkade_pressure_cleaning') {
          dailyTarget = project.stallsPerDay || 0;
        } else if (project.jobType === 'in_suite_dryer_vent_cleaning') {
          dailyTarget = project.floorsPerDay || project.suitesPerDay || 0;
        }
        
        // Add dailyDropTarget and calculate total dropsCompleted from elevation fields
        // Also enrich with employee name by fetching user
        const sessionsWithTarget = await Promise.all(projectSessions.map(async (session) => {
          // Fetch employee name from users table
          const employee = await storage.getUserById(session.employeeId);
          
          return {
            ...session,
            employeeName: employee?.name || null, // Add employeeName for GPS legend
            dailyDropTarget: dailyTarget,
            projectName: project.buildingName, // Add project name for map popups
            dropsCompleted: (session.dropsCompletedNorth || 0) + 
                           (session.dropsCompletedEast || 0) + 
                           (session.dropsCompletedSouth || 0) + 
                           (session.dropsCompletedWest || 0),
          };
        }));
        allSessions.push(...sessionsWithTarget);
      }
      
      // Filter financial data if user doesn't have financial permissions
      const filteredSessions = canViewFinancialData ? allSessions : allSessions.map(session => ({
        ...session,
        techHourlyRate: null,
      }));
      
      res.json({ sessions: filteredSessions });
    } catch (error) {
      console.error("Failed to fetch all work sessions:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Generate sample work sessions for testing
  app.post("/api/projects/:projectId/generate-sample-sessions", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const projectId = req.params.projectId;
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Verify project belongs to current company
      if (project.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get employees for this company
      const employees = await storage.getAllEmployees(currentUser.id);
      const techs = employees.filter(e => e.role === 'rope_access_tech' && !e.terminatedDate);
      
      if (techs.length === 0) {
        return res.status(400).json({ message: "No active technicians found. Please create employees first." });
      }
      
      const generatedSessions = [];
      const now = new Date();
      
      // Generate sessions spanning 3 years (2023, 2024, 2025)
      for (let year = 2023; year <= 2025; year++) {
        // For each year, generate sessions across different months
        const monthsToGenerate = year === 2025 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] : [0, 2, 4, 6, 8, 10]; // More in current year
        
        for (const month of monthsToGenerate) {
          // Generate 3-8 sessions per month
          const sessionsThisMonth = Math.floor(Math.random() * 6) + 3;
          
          for (let i = 0; i < sessionsThisMonth; i++) {
            // Random day in the month
            const day = Math.floor(Math.random() * 28) + 1;
            const workDate = new Date(year, month, day);
            
            // Skip future dates
            if (workDate > now) continue;
            
            // Random tech
            const tech = techs[Math.floor(Math.random() * techs.length)];
            
            // Random start time (6 AM to 10 AM)
            const startHour = Math.floor(Math.random() * 4) + 6;
            const startMinute = Math.random() > 0.5 ? 0 : 30;
            const startTime = new Date(year, month, day, startHour, startMinute, 0);
            
            // Work duration (6-10 hours)
            const workHours = Math.floor(Math.random() * 5) + 6;
            const endTime = new Date(startTime.getTime() + workHours * 60 * 60 * 1000);
            
            // Random drops completed per elevation
            const dailyTarget = project.dailyDropTarget || 20;
            const totalTarget = dailyTarget;
            
            // 70% chance of meeting target
            const meetTarget = Math.random() < 0.7;
            const totalDrops = meetTarget 
              ? totalTarget + Math.floor(Math.random() * 5) 
              : Math.floor(totalTarget * (0.6 + Math.random() * 0.3));
            
            // Distribute drops across elevations
            const dropsNorth = Math.floor(totalDrops * 0.3);
            const dropsEast = Math.floor(totalDrops * 0.25);
            const dropsSouth = Math.floor(totalDrops * 0.25);
            const dropsWest = totalDrops - dropsNorth - dropsEast - dropsSouth;
            
            const shortfallReason = !meetTarget ? [
              "Weather conditions",
              "Equipment issues",
              "Building access delays",
              "Staff shortage",
              "Client requested changes"
            ][Math.floor(Math.random() * 5)] : null;
            
            // Insert directly into database (id is auto-generated, don't specify it)
            await db.insert(workSessions).values({
              employeeId: tech.id,
              projectId: projectId,
              companyId: project.companyId,
              workDate: workDate.toISOString().split('T')[0],
              startTime: new Date(startTime),
              endTime: new Date(endTime),
              dropsCompletedNorth: dropsNorth,
              dropsCompletedEast: dropsEast,
              dropsCompletedSouth: dropsSouth,
              dropsCompletedWest: dropsWest,
              regularHours: workHours.toString(),
              overtimeHours: '0',
              doubleTimeHours: '0',
              shortfallReason: shortfallReason,
              startLatitude: null,
              startLongitude: null,
              endLatitude: null,
              endLongitude: null,
            });
            
            generatedSessions.push({
              workDate: workDate.toISOString().split('T')[0],
              techName: tech.name,
              totalDrops: dropsNorth + dropsEast + dropsSouth + dropsWest,
            });
          }
        }
      }
      
      res.json({ 
        message: `Generated ${generatedSessions.length} sample work sessions`,
        count: generatedSessions.length,
        sessions: generatedSessions.slice(0, 10) // Return first 10 as preview
      });
    } catch (error) {
      console.error("Generate sample sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get active workers (sessions without end time) - Management only
  app.get("/api/active-workers", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Determine company ID
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.role === "operations_manager" || 
                                    currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      // Get all projects for the company
      const projects = await storage.getProjectsByCompany(companyId);
      
      // Collect all active work sessions (no end time)
      const activeSessions = [];
      for (const project of projects) {
        const projectSessions = await storage.getWorkSessionsByProject(project.id, companyId);
        // Filter for active sessions and add project info
        const activeProjectSessions = projectSessions
          .filter(session => !session.endTime)
          .map(session => ({
            ...session,
            projectName: project.buildingName,
            strataPlanNumber: project.strataPlanNumber,
            jobType: project.jobType,
          }));
        activeSessions.push(...activeProjectSessions);
      }
      
      // Sort by start time (oldest first)
      activeSessions.sort((a, b) => {
        const aTime = a.startTime ? new Date(a.startTime).getTime() : 0;
        const bTime = b.startTime ? new Date(b.startTime).getTime() : 0;
        return aTime - bTime;
      });
      
      // Filter financial data if user doesn't have financial permissions
      const filteredSessions = canViewFinancialData ? activeSessions : activeSessions.map(session => ({
        ...session,
        techHourlyRate: null,
      }));
      
      res.json({ sessions: filteredSessions });
    } catch (error) {
      console.error("Failed to fetch active workers:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all completed work sessions for the current user (across all projects)
  app.get("/api/my-work-sessions", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get all work sessions for this user
      const allSessions = await storage.getAllWorkSessionsByEmployee(currentUser.id);
      
      // Filter to only completed sessions and enrich with project info
      const completedSessions = await Promise.all(
        allSessions
          .filter(session => session.endTime)
          .map(async (session) => {
            // Get project info
            const project = await storage.getProjectById(session.projectId);
            
            // Calculate hours worked
            const startTime = new Date(session.startTime);
            const endTime = new Date(session.endTime!);
            const hoursWorked = ((endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60)).toFixed(2);
            
            // Get company name
            let companyName = null;
            if (session.companyId) {
              const company = await storage.getUserById(session.companyId);
              companyName = company?.companyName || company?.name || null;
            }
            
            // Calculate total drops
            const totalDrops = (session.dropsCompletedNorth || 0) + 
                              (session.dropsCompletedEast || 0) + 
                              (session.dropsCompletedSouth || 0) + 
                              (session.dropsCompletedWest || 0);
            
            // Get IRATA task log for this session if exists
            const irataTaskLog = await storage.getIrataTaskLogByWorkSession(session.id);
            
            return {
              ...session,
              hoursWorked,
              totalDrops,
              dropsNorth: session.dropsCompletedNorth || 0,
              dropsEast: session.dropsCompletedEast || 0,
              dropsSouth: session.dropsCompletedSouth || 0,
              dropsWest: session.dropsCompletedWest || 0,
              buildingName: project?.buildingName || null,
              buildingAddress: project?.buildingAddress || null,
              buildingHeight: project?.buildingHeight || null,
              companyName,
              // Include IRATA task log data
              tasksPerformed: irataTaskLog?.tasksPerformed || [],
              notes: irataTaskLog?.notes || null,
              ropeAccessTaskHours: irataTaskLog?.ropeAccessTaskHours || null,
            };
          })
      );
      
      // Sort by work date descending (most recent first)
      completedSessions.sort((a, b) => {
        const dateA = new Date(a.workDate).getTime();
        const dateB = new Date(b.workDate).getTime();
        return dateB - dateA;
      });
      
      res.json({ sessions: completedSessions });
    } catch (error) {
      console.error("Get my work sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get employee's own work sessions for a project
  app.get("/api/projects/:projectId/my-work-sessions", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access to project
      const hasAccess = await storage.verifyProjectAccess(
        req.params.projectId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const sessions = await storage.getWorkSessionsByEmployee(currentUser.id, req.params.projectId);
      res.json({ sessions });
    } catch (error) {
      console.error("Get my work sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== TECHNICIAN PERFORMANCE METRICS ====================
  
  // Get technician performance metrics for their work sessions
  app.get("/api/my-performance-metrics", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get all completed work sessions for this tech
      const allSessions = await storage.getAllWorkSessionsByEmployee(currentUser.id);
      const completedSessions = allSessions.filter(s => s.endTime !== null);
      
      // Get all harness inspections for this tech
      const inspections = await storage.getHarnessInspectionsByWorker(currentUser.id);
      const inspectionDates = new Set(inspections.map(i => i.inspectionDate));
      
      // Get document compliance data
      // Count all documents assigned to this employee for review and how many are signed
      let documentCompliance = 100; // Default to 100% if no assigned documents
      let requiredDocsCount = 0;
      let signedDocsCount = 0;
      
      if (currentUser.companyId) {
        // Get all document review assignments for this employee at their current company
        const employeeSignatures = await storage.getDocumentReviewSignaturesByEmployee(currentUser.id);
        // Filter to only documents from current company
        const assignedDocs = employeeSignatures.filter(s => s.companyId === currentUser.companyId);
        requiredDocsCount = assignedDocs.length;
        
        if (requiredDocsCount > 0) {
          // Count how many have been signed
          signedDocsCount = assignedDocs.filter(s => s.signedAt !== null).length;
          documentCompliance = Math.round((signedDocsCount / requiredDocsCount) * 100);
        }
      }
      
      // Calculate metrics for each session
      // New weighting: Drops 35%, Harness 25%, Hours 20%, Document Compliance 20%
      const sessionMetrics: Array<{
        sessionId: string;
        projectId: string;
        workDate: string;
        totalDrops: number;
        dailyDropTarget: number | null;
        dropPerformance: number; // 0-100+
        dropRating: 'exceeded' | 'on_target' | 'below_target' | 'na';
        hoursWorked: number;
        hoursRating: 'excellent' | 'good' | 'short' | 'na';
        harnessInspectionDone: boolean;
        documentCompliance: number; // 0-100
        overallScore: number; // 0-100
        overallRating: 'excellent' | 'good' | 'needs_improvement' | 'poor';
      }> = [];
      
      for (const session of completedSessions) {
        // Get project for daily drop target
        const project = await storage.getProjectById(session.projectId);
        const dailyDropTarget = project?.dailyDropTarget || null;
        
        // Calculate total drops for this session
        const totalDrops = (session.dropsCompletedNorth || 0) + 
                          (session.dropsCompletedEast || 0) + 
                          (session.dropsCompletedSouth || 0) + 
                          (session.dropsCompletedWest || 0);
        
        // Drop performance calculation (35% weight)
        let dropPerformance = 100;
        let dropRating: 'exceeded' | 'on_target' | 'below_target' | 'na' = 'na';
        
        if (dailyDropTarget && dailyDropTarget > 0) {
          const dropRatio = totalDrops / dailyDropTarget;
          dropPerformance = Math.min(dropRatio * 100, 120); // Cap at 120%
          
          if (dropRatio >= 1.1) {
            dropRating = 'exceeded';
          } else if (dropRatio >= 0.9) {
            dropRating = 'on_target';
          } else {
            dropRating = 'below_target';
          }
        }
        
        // Hours calculation (20% weight)
        const startTime = new Date(session.startTime);
        const endTime = new Date(session.endTime!);
        const hoursWorked = (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);
        
        // Standard workday is 8 hours - rate based on actual work
        let hoursScore = 100;
        let hoursRating: 'excellent' | 'good' | 'short' | 'na' = 'na';
        
        if (hoursWorked >= 7) {
          hoursScore = 100;
          hoursRating = 'excellent';
        } else if (hoursWorked >= 5) {
          hoursScore = 80;
          hoursRating = 'good';
        } else if (hoursWorked >= 3) {
          hoursScore = 60;
          hoursRating = 'short';
        } else {
          hoursScore = 40;
          hoursRating = 'short';
        }
        
        // Harness inspection check (25% weight)
        const harnessInspectionDone = inspectionDates.has(session.workDate);
        const harnessScore = harnessInspectionDone ? 100 : 0;
        
        // Document compliance score (20% weight) - calculated once at the top, same for all sessions
        const docScore = documentCompliance;
        
        // Calculate overall score (weighted average)
        // Rating is based ONLY on safety compliance: Harness Inspection 50%, Document Review 50%
        // Performance metrics (drops, hours) are tracked but not included in the rating
        let overallScore: number;
        overallScore = (harnessScore * 0.50) + (docScore * 0.50);
        overallScore = Math.min(Math.round(overallScore), 100);
        
        // Overall rating
        let overallRating: 'excellent' | 'good' | 'needs_improvement' | 'poor';
        if (overallScore >= 85) {
          overallRating = 'excellent';
        } else if (overallScore >= 70) {
          overallRating = 'good';
        } else if (overallScore >= 50) {
          overallRating = 'needs_improvement';
        } else {
          overallRating = 'poor';
        }
        
        sessionMetrics.push({
          sessionId: session.id,
          projectId: session.projectId,
          workDate: session.workDate,
          totalDrops,
          dailyDropTarget,
          dropPerformance: Math.round(dropPerformance),
          dropRating,
          hoursWorked: Math.round(hoursWorked * 10) / 10,
          hoursRating,
          harnessInspectionDone,
          documentCompliance,
          overallScore,
          overallRating,
        });
      }
      
      // Calculate overall average
      let averageScore = 0;
      let harnessCompliance = 0;
      if (sessionMetrics.length > 0) {
        averageScore = Math.round(
          sessionMetrics.reduce((sum, m) => sum + m.overallScore, 0) / sessionMetrics.length
        );
        harnessCompliance = Math.round(
          (sessionMetrics.filter(m => m.harnessInspectionDone).length / sessionMetrics.length) * 100
        );
      }
      
      // Determine overall rating
      let overallAverageRating: 'excellent' | 'good' | 'needs_improvement' | 'poor' | 'no_data';
      if (sessionMetrics.length === 0) {
        overallAverageRating = 'no_data';
      } else if (averageScore >= 85) {
        overallAverageRating = 'excellent';
      } else if (averageScore >= 70) {
        overallAverageRating = 'good';
      } else if (averageScore >= 50) {
        overallAverageRating = 'needs_improvement';
      } else {
        overallAverageRating = 'poor';
      }
      
      res.json({
        metrics: sessionMetrics,
        summary: {
          totalSessions: sessionMetrics.length,
          averageScore,
          harnessCompliance,
          documentCompliance,
          overallRating: overallAverageRating,
        },
      });
    } catch (error) {
      console.error("Get performance metrics error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== NON-BILLABLE WORK SESSION ROUTES ====================
  
  // Start a non-billable work session
  app.post("/api/non-billable-sessions", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if there's already an active session (billable or non-billable) anywhere
      const existingSession = await storage.getAnyActiveSession(currentUser.id);
      
      if (existingSession) {
        if (existingSession.type === 'billable') {
          return res.status(400).json({ 
            message: `You already have an active work session at "${existingSession.projectName || 'a project'}". Please clock out first.`,
            activeSession: {
              type: 'billable',
              projectName: existingSession.projectName,
              startTime: existingSession.session.startTime
            }
          });
        } else {
          return res.status(400).json({ 
            message: `You already have an active non-billable session ("${existingSession.description || 'activity'}"). Please clock out first.`,
            activeSession: {
              type: 'non_billable',
              description: existingSession.description,
              startTime: existingSession.session.startTime
            }
          });
        }
      }
      
      // Use client's local date if provided, otherwise fall back to server date
      const now = new Date();
      const sessionDate = req.body.workDate || now.toISOString().split('T')[0];
      
      console.log("Creating non-billable session with data:", {
        employeeId: currentUser.id,
        companyId: currentUser.companyId || currentUser.id,
        workDate: sessionDate,
        startTime: now,
        endTime: null,
        description: req.body.description,
      });
      
      const session = await storage.createNonBillableWorkSession({
        employeeId: currentUser.id,
        companyId: currentUser.companyId || currentUser.id,
        workDate: sessionDate,
        startTime: now,
        endTime: null,
        description: req.body.description,
      });
      
      console.log("Session created successfully:", session);
      res.json({ session });
    } catch (error) {
      console.error("Start non-billable session error:", error);
      console.error("Error stack:", (error as Error).stack);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // End a non-billable work session
  app.patch("/api/non-billable-sessions/:sessionId/end", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const session = await storage.getNonBillableSessionById(req.params.sessionId);
      if (!session) {
        return res.status(404).json({ message: "Session not found" });
      }
      
      // Verify ownership
      if (session.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "You can only end your own sessions" });
      }
      
      if (session.endTime) {
        return res.status(400).json({ message: "Session already ended" });
      }
      
      // Calculate overtime breakdown for non-billable session
      const now = new Date();
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      const overtimeBreakdown = await calculateOvertimeHours(
        companyId!,
        currentUser.id,
        new Date(session.workDate),
        new Date(session.startTime),
        now
      );
      
      const updatedSession = await storage.endNonBillableWorkSession(
        req.params.sessionId,
        overtimeBreakdown.regularHours,
        overtimeBreakdown.overtimeHours,
        overtimeBreakdown.doubleTimeHours
      );
      res.json({ session: updatedSession });
    } catch (error) {
      console.error("End non-billable session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get active non-billable session for current user
  app.get("/api/non-billable-sessions/active", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const session = await storage.getActiveNonBillableSession(currentUser.id);
      res.json({ session: session || null });
    } catch (error) {
      console.error("Get active non-billable session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all non-billable sessions for company (management only)
  app.get("/api/non-billable-sessions", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      const sessions = await storage.getAllNonBillableSessions(companyId!);
      res.json({ sessions });
    } catch (error) {
      console.error("Get non-billable sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get non-billable sessions by employee (management only)
  app.get("/api/non-billable-sessions/employee/:employeeId", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const sessions = await storage.getNonBillableSessionsByEmployee(req.params.employeeId);
      res.json({ sessions });
    } catch (error) {
      console.error("Get non-billable sessions by employee error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== IRATA TASK LOG ROUTES ====================
  
  // Valid IRATA task IDs derived from canonical schema definition
  const VALID_IRATA_TASK_IDS = IRATA_TASK_TYPES.map(t => t.id);
  
  // Create IRATA task log (when ending a work session)
  app.post("/api/irata-task-logs", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { workSessionId, tasksPerformed, notes } = req.body;
      
      // Validate required fields
      if (!workSessionId || !tasksPerformed || tasksPerformed.length === 0) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      
      // Validate workSessionId exists and belongs to the current user
      const workSession = await storage.getWorkSessionById(workSessionId);
      if (!workSession) {
        return res.status(400).json({ message: "Work session not found" });
      }
      
      if (workSession.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "You can only log tasks for your own work sessions" });
      }
      
      // Ensure work session is completed (has endTime)
      if (!workSession.endTime) {
        return res.status(400).json({ message: "Cannot log tasks for an incomplete work session" });
      }
      
      // Check for duplicate log for this work session
      const existingLog = await storage.getIrataTaskLogByWorkSession(workSessionId);
      if (existingLog) {
        return res.status(400).json({ message: "IRATA tasks have already been logged for this work session" });
      }
      
      // Validate tasksPerformed is an array of strings
      if (!Array.isArray(tasksPerformed) || tasksPerformed.length === 0) {
        return res.status(400).json({ message: "Tasks performed must be a non-empty array" });
      }
      
      // Validate all entries are strings
      if (tasksPerformed.some(t => typeof t !== 'string')) {
        return res.status(400).json({ message: "All task IDs must be strings" });
      }
      
      // Canonicalize: filter to valid task IDs only, ensure uniqueness
      const canonicalTasks = [...new Set(
        tasksPerformed
          .filter((t: string) => VALID_IRATA_TASK_IDS.includes(t))
      )];
      
      // Reject if no valid tasks remain after canonicalization
      if (canonicalTasks.length === 0) {
        return res.status(400).json({ message: "At least one valid IRATA task must be selected" });
      }
      
      // Report invalid task IDs that were filtered out
      const invalidTasks = tasksPerformed.filter((t: string) => !VALID_IRATA_TASK_IDS.includes(t));
      if (invalidTasks.length > 0) {
        return res.status(400).json({ message: `Invalid task IDs: ${invalidTasks.join(', ')}` });
      }
      
      // Compute hoursWorked and workDate from the authoritative work session data
      const sessionStart = new Date(workSession.startTime);
      const sessionEnd = new Date(workSession.endTime);
      const hoursWorked = ((sessionEnd.getTime() - sessionStart.getTime()) / (1000 * 60 * 60)).toFixed(2);
      const workDate = sessionStart.toISOString().split('T')[0]; // YYYY-MM-DD format
      
      // Get project info from the work session's project (authoritative source)
      const project = await storage.getProjectById(workSession.projectId);
      const derivedBuildingName = project?.buildingName || null;
      const derivedBuildingAddress = project?.buildingAddress || null;
      
      // Derive building height from buildingHeight field, or calculate from buildingFloors if available
      let derivedBuildingHeight = project?.buildingHeight || null;
      if (!derivedBuildingHeight && project?.buildingFloors) {
        const floors = project.buildingFloors;
        const heightFeet = floors * 9;
        const heightMeters = Math.round(heightFeet / 3.281);
        derivedBuildingHeight = `${heightFeet}ft (${heightMeters}m)`;
      }
      
      // Get company ID from work session (authoritative source)
      const companyId = workSession.companyId;
      
      try {
        const log = await storage.createIrataTaskLog({
          workSessionId,
          employeeId: currentUser.id,
          companyId,
          projectId: workSession.projectId,
          buildingName: derivedBuildingName,
          buildingAddress: derivedBuildingAddress,
          buildingHeight: derivedBuildingHeight,
          tasksPerformed: canonicalTasks,
          workDate,
          hoursWorked,
          notes: typeof notes === 'string' ? notes : null,
        });
        
        res.json({ log });
      } catch (dbError: any) {
        // Handle unique constraint violation (duplicate insert race condition)
        if (dbError.code === '23505') {
          return res.status(400).json({ message: "IRATA tasks have already been logged for this work session" });
        }
        throw dbError;
      }
    } catch (error) {
      console.error("Create IRATA task log error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get my IRATA task logs (employee's own logs)
  app.get("/api/my-irata-task-logs", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const logs = await storage.getIrataTaskLogsByEmployee(currentUser.id);
      
      // Enrich logs with building height, company name, and drop counts from work session
      const enrichedLogs = await Promise.all(logs.map(async (log) => {
        let enrichedLog: any = { ...log };
        
        // Get company name from companyId
        if (log.companyId) {
          const company = await storage.getUserById(log.companyId);
          if (company) {
            enrichedLog.companyName = company.companyName || company.name || null;
          }
        }
        
        // Get drop counts from the associated work session
        if (log.workSessionId) {
          const workSession = await storage.getWorkSessionById(log.workSessionId);
          if (workSession) {
            const dropsNorth = workSession.dropsCompletedNorth || 0;
            const dropsEast = workSession.dropsCompletedEast || 0;
            const dropsSouth = workSession.dropsCompletedSouth || 0;
            const dropsWest = workSession.dropsCompletedWest || 0;
            enrichedLog.totalDrops = dropsNorth + dropsEast + dropsSouth + dropsWest;
            enrichedLog.dropsNorth = dropsNorth;
            enrichedLog.dropsEast = dropsEast;
            enrichedLog.dropsSouth = dropsSouth;
            enrichedLog.dropsWest = dropsWest;
          }
        }
        
        // If log already has building height, skip height derivation
        if (!log.buildingHeight && log.projectId) {
          // Try to get building height from the associated project
          const project = await storage.getProjectById(log.projectId);
          if (project) {
            let derivedHeight = project.buildingHeight || null;
            
            // Calculate from floors if no explicit height
            if (!derivedHeight && project.buildingFloors) {
              const floors = project.buildingFloors;
              const heightFeet = floors * 9;
              const heightMeters = Math.round(heightFeet / 3.281);
              derivedHeight = `${heightFeet}ft (${heightMeters}m)`;
            }
            
            if (derivedHeight) {
              enrichedLog.buildingHeight = derivedHeight;
            }
          }
        }
        
        return enrichedLog;
      }));
      
      res.json({ logs: enrichedLogs });
    } catch (error) {
      console.error("Get my IRATA task logs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all IRATA task logs for company (management only)
  app.get("/api/irata-task-logs", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const logs = await storage.getIrataTaskLogsByCompany(companyId);
      res.json({ logs });
    } catch (error) {
      console.error("Get IRATA task logs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get IRATA task logs by employee ID (management only)
  app.get("/api/irata-task-logs/employee/:employeeId", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const logs = await storage.getIrataTaskLogsByEmployee(req.params.employeeId);
      res.json({ logs });
    } catch (error) {
      console.error("Get IRATA task logs by employee error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get IRATA task log by work session ID
  app.get("/api/irata-task-logs/work-session/:workSessionId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const log = await storage.getIrataTaskLogByWorkSession(req.params.workSessionId);
      res.json({ log: log || null });
    } catch (error) {
      console.error("Get IRATA task log by work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update IRATA task log
  app.patch("/api/irata-task-logs/:logId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify ownership
      const existingLog = await storage.getIrataTaskLogById(req.params.logId);
      if (!existingLog || existingLog.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const { tasksPerformed, notes } = req.body;
      
      const log = await storage.updateIrataTaskLog(req.params.logId, {
        tasksPerformed: tasksPerformed || existingLog.tasksPerformed,
        notes: notes !== undefined ? notes : existingLog.notes,
      });
      
      res.json({ log });
    } catch (error) {
      console.error("Update IRATA task log error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete IRATA task log
  app.delete("/api/irata-task-logs/:logId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify ownership or management role
      const existingLog = await storage.getIrataTaskLogById(req.params.logId);
      if (!existingLog) {
        return res.status(404).json({ message: "Log not found" });
      }
      
      const isManagement = ["company", "owner_ceo", "operations_manager", "supervisor"].includes(currentUser.role);
      if (existingLog.employeeId !== currentUser.id && !isManagement) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteIrataTaskLog(req.params.logId);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete IRATA task log error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update my IRATA baseline hours (for logbook)
  const baselineHoursSchema = z.object({
    baselineHours: z.number().min(0, "Hours must be non-negative").max(100000, "Hours seems unreasonably high"),
  });
  
  app.patch("/api/my-irata-baseline-hours", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const parseResult = baselineHoursSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "Invalid input", 
          errors: parseResult.error.flatten().fieldErrors 
        });
      }
      
      const { baselineHours } = parseResult.data;
      
      await storage.updateUser(currentUser.id, {
        irataBaselineHours: baselineHours.toString(),
      });
      
      const updatedUser = await storage.getUserById(currentUser.id);
      const { passwordHash, ...userWithoutPassword } = updatedUser!;
      
      res.json({ 
        success: true, 
        user: userWithoutPassword,
        message: "Baseline hours updated successfully" 
      });
    } catch (error) {
      console.error("Update IRATA baseline hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== HISTORICAL HOURS ROUTES ====================
  
  // Get my historical hours (previous work not counted toward totals)
  // Only technicians can access historical hours
  app.get("/api/my-historical-hours", requireAuth, requireRole("company", "rope_access_tech", "owner_ceo", "operations_manager", "general_supervisor", "rope_access_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const historicalHours = await storage.getHistoricalHoursByEmployee(currentUser.id);
      res.json({ historicalHours });
    } catch (error) {
      console.error("Get historical hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Create historical hours entry
  const historicalHoursSchema = z.object({
    startDate: z.string().min(1, "Start date is required"),
    endDate: z.string().min(1, "End date is required"),
    hoursWorked: z.string().or(z.number()).transform(v => {
      const num = parseFloat(String(v));
      if (isNaN(num) || num <= 0) {
        throw new Error("Hours must be a positive number");
      }
      return String(num);
    }),
    buildingName: z.string().optional().nullable(),
    buildingAddress: z.string().optional().nullable(),
    buildingHeight: z.string().optional().nullable(),
    tasksPerformed: z.array(z.string()).min(1, "At least one task is required"),
    notes: z.string().optional().nullable(),
    previousEmployer: z.string().optional().nullable(),
    countsTowardTotal: z.boolean().optional().default(false), // true = manual hours (counted), false = previous hours (reference only)
  });
  
  // Only technicians can add historical hours
  app.post("/api/my-historical-hours", requireAuth, requireRole("company", "rope_access_tech", "owner_ceo", "operations_manager", "general_supervisor", "rope_access_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const parseResult = historicalHoursSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "Invalid input", 
          errors: parseResult.error.flatten().fieldErrors 
        });
      }
      
      const data = parseResult.data;
      
      const entry = await storage.createHistoricalHours({
        employeeId: currentUser.id,
        startDate: data.startDate,
        endDate: data.endDate,
        hoursWorked: data.hoursWorked,
        buildingName: data.buildingName || null,
        buildingAddress: data.buildingAddress || null,
        buildingHeight: data.buildingHeight || null,
        tasksPerformed: data.tasksPerformed,
        notes: data.notes || null,
        previousEmployer: data.previousEmployer || null,
        countsTowardTotal: data.countsTowardTotal ?? false,
      });
      
      wsHub.notifyHistoricalHoursUpdated(currentUser.id);
      res.json({ historicalHours: entry, message: "Previous hours added successfully" });
    } catch (error) {
      console.error("Create historical hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Delete historical hours entry - only technicians can delete their own entries
  app.delete("/api/my-historical-hours/:id", requireAuth, requireRole("company", "rope_access_tech", "owner_ceo", "operations_manager", "general_supervisor", "rope_access_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const entry = await storage.getHistoricalHoursById(req.params.id);
      
      if (!entry) {
        return res.status(404).json({ message: "Historical hours entry not found" });
      }
      
      if (entry.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "Not authorized to delete this entry" });
      }
      
      await storage.deleteHistoricalHours(req.params.id);
      wsHub.notifyHistoricalHoursUpdated(currentUser.id);
      res.json({ success: true, message: "Previous hours deleted successfully" });
    } catch (error) {
      console.error("Delete historical hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Scan logbook page with Gemini AI to extract historical hours entries
  const { analyzeLogbookPage } = await import("./gemini");
  
  app.post("/api/my-historical-hours/scan-logbook", requireAuth, requireRole("company", "rope_access_tech", "owner_ceo", "operations_manager", "general_supervisor", "rope_access_supervisor"), imageUpload.single('image'), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "No image provided" });
      }
      
      // Validate file type
      const validMimeTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif'];
      if (!validMimeTypes.includes(req.file.mimetype)) {
        return res.status(400).json({ message: "Invalid image type. Please upload a JPEG, PNG, or WebP image." });
      }
      
      // Convert buffer to base64
      const imageBase64 = req.file.buffer.toString('base64');
      
      console.log(`[Logbook-Scan] Analyzing logbook page for user ${currentUser.id}`);
      
      // Analyze with Gemini
      const result = await analyzeLogbookPage(imageBase64, req.file.mimetype);
      
      if (!result.success) {
        return res.status(400).json({ 
          message: result.error || "Failed to analyze logbook page",
          warnings: result.pageWarnings
        });
      }
      
      console.log(`[Logbook-Scan] Extracted ${result.entries.length} entries`);
      
      res.json({
        success: true,
        entries: result.entries,
        warnings: result.pageWarnings
      });
    } catch (error) {
      console.error("Logbook scan error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Bulk create historical hours entries (for committing scanned logbook entries)
  app.post("/api/my-historical-hours/bulk", requireAuth, requireRole("company", "rope_access_tech", "owner_ceo", "operations_manager", "general_supervisor", "rope_access_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { entries } = req.body;
      
      if (!Array.isArray(entries) || entries.length === 0) {
        return res.status(400).json({ message: "No entries provided" });
      }
      
      // Validate and create each entry
      const createdEntries = [];
      const errors = [];
      
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        
        try {
          // Validate required fields
          if (!entry.startDate || !entry.endDate || !entry.hoursWorked) {
            errors.push({ index: i, message: "Missing required fields (startDate, endDate, hoursWorked)" });
            continue;
          }
          
          const historicalData = insertHistoricalHoursSchema.parse({
            employeeId: currentUser.id,
            startDate: entry.startDate,
            endDate: entry.endDate,
            hoursWorked: entry.hoursWorked.toString(),
            buildingName: entry.buildingName || null,
            buildingAddress: entry.buildingAddress || null,
            buildingHeight: entry.buildingHeight || null,
            tasksPerformed: entry.tasksPerformed || [],
            notes: entry.notes || null,
            previousEmployer: entry.previousEmployer || null,
          });
          
          const created = await storage.createHistoricalHours(historicalData);
          createdEntries.push(created);
        } catch (entryError) {
          console.error(`Error creating entry ${i}:`, entryError);
          errors.push({ index: i, message: "Validation error" });
        }
      }
      
      console.log(`[Logbook-Scan] Created ${createdEntries.length} entries, ${errors.length} errors`);
      
      // Notify across devices
      if (createdEntries.length > 0) {
        wsHub.notifyHistoricalHoursUpdated(currentUser.id);
      }
      
      res.json({
        success: true,
        created: createdEntries.length,
        errors: errors.length > 0 ? errors : undefined,
        message: `Successfully added ${createdEntries.length} previous hours entries`
      });
    } catch (error) {
      console.error("Bulk create historical hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ==================== COMPLAINT ROUTES ====================
  
  // Create complaint (with optional photo upload via resilient queue)
  app.post("/api/complaints", requireAuth, imageUpload.single('photo'), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      let companyId = req.body.companyId;
      
      // Resolve companyId before validation
      if (!companyId) {
        // If projectId is provided, get company from project
        if (req.body.projectId) {
          const project = await storage.getProjectById(req.body.projectId);
          if (project) {
            companyId = project.companyId;
          }
        }
        // For residents without projectId, find company from their strataPlanNumber
        else if (currentUser?.role === "resident" && currentUser.strataPlanNumber) {
          const projects = await storage.getAllProjectsByStrataPlan(currentUser.strataPlanNumber);
          if (projects.length > 0) {
            companyId = projects[0].companyId;
          } else {
            return res.status(400).json({ 
              message: "No company found for your building. Please contact support." 
            });
          }
        }
      }
      
      // Create complaint first (without photo URL - will be updated async)
      const complaintData = insertComplaintSchema.parse({
        ...req.body,
        companyId,
        photoUrl: null, // Photo will be added asynchronously after queue processing
        residentId: currentUser?.role === "resident" ? currentUser.id : null,
      });
      
      const complaint = await storage.createComplaint(complaintData);
      
      // Queue photo upload asynchronously (never blocks complaint creation)
      let photoStatus = null;
      if (req.file) {
        try {
          const timestamp = Date.now();
          const objectKey = `${companyId}/${timestamp}-${req.file.originalname}`;
          const payload = req.file.buffer.toString("base64");
          
          await storage.enqueueResidentPhoto({
            complaintId: complaint.id,
            objectKey,
            contentType: req.file.mimetype,
            fileSize: req.file.size,
            payload,
          });
          
          photoStatus = "queued";
          console.log(`[Complaints] Photo queued for complaint ${complaint.id}`);
        } catch (queueError: any) {
          // Even if queuing fails, complaint is already saved
          console.error(`[Complaints] Failed to queue photo: ${queueError.message}`);
          photoStatus = "queue_failed";
        }
      }
      
      res.json({ complaint, photoStatus });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create complaint error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get photo upload status for a complaint
  app.get("/api/complaints/:id/photo-status", requireAuth, async (req: Request, res: Response) => {
    try {
      const complaintId = req.params.id;
      const queueEntry = await storage.getPhotoQueueStatus(complaintId);
      
      if (!queueEntry) {
        // No photo was uploaded for this complaint
        const complaint = await storage.getComplaintById(complaintId);
        if (complaint?.photoUrl) {
          return res.json({ status: "uploaded", photoUrl: complaint.photoUrl });
        }
        return res.json({ status: "none" });
      }
      
      res.json({ 
        status: queueEntry.status,
        photoUrl: queueEntry.uploadedUrl || null,
        retryCount: queueEntry.retryCount,
        lastError: queueEntry.status === "failed" ? queueEntry.lastError : null,
      });
    } catch (error) {
      console.error("Get photo status error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Serve resident photos from dedicated bucket (supports nested path with complaintId folder)
  // Converts HEIC/HEIF to JPEG on-the-fly for browser compatibility
  app.get("/api/resident-photos/:folderId/:fileName", async (req: Request, res: Response) => {
    try {
      const objectStorageService = new ObjectStorageService();
      const fullPath = `${req.params.folderId}/${req.params.fileName}`;
      const file = await objectStorageService.getResidentPhoto(fullPath);
      
      if (!file) {
        return res.status(404).json({ message: "Photo not found" });
      }
      
      const [metadata] = await file.getMetadata();
      const contentType = metadata.contentType || "image/jpeg";
      const fileName = req.params.fileName.toLowerCase();
      const isHeic = fileName.endsWith(".heic") || fileName.endsWith(".heif");
      
      // If HEIC/HEIF, convert to JPEG for browser compatibility
      if (isHeic) {
        const chunks: Buffer[] = [];
        const stream = file.createReadStream();
        
        stream.on("data", (chunk: Buffer) => chunks.push(chunk));
        stream.on("end", async () => {
          try {
            const heicBuffer = Buffer.concat(chunks);
            const jpegBuffer = await convert({
              buffer: heicBuffer,
              format: "JPEG",
              quality: 0.9,
            });
            
            res.setHeader("Content-Type", "image/jpeg");
            res.setHeader("Cache-Control", "public, max-age=31536000");
            res.send(jpegBuffer);
          } catch (conversionError) {
            console.error("HEIC conversion error:", conversionError);
            // Fallback: send original HEIC (won't display in most browsers but won't error)
            res.setHeader("Content-Type", contentType);
            res.setHeader("Cache-Control", "public, max-age=31536000");
            res.send(Buffer.concat(chunks));
          }
        });
        stream.on("error", (err: Error) => {
          console.error("Stream error:", err);
          res.status(500).json({ message: "Error reading photo" });
        });
      } else {
        // Non-HEIC: stream directly
        res.setHeader("Content-Type", contentType);
        res.setHeader("Cache-Control", "public, max-age=31536000");
        const stream = file.createReadStream();
        stream.pipe(res);
      }
    } catch (error) {
      console.error("Get resident photo error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get all complaints (filtered by role) - for management dashboard
  app.get("/api/complaints", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      let complaints;
      
      if (currentUser.role === "resident") {
        // Residents only see complaints they submitted
        complaints = await storage.getComplaintsForResident(currentUser.id);
      } else if (currentUser.role === "company") {
        // Company sees all complaints for their projects
        complaints = await storage.getComplaintsForCompany(currentUser.id);
      } else if (currentUser.role === "operations_manager" || currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || currentUser.role === "rope_access_tech") {
        // Staff sees complaints for their company's projects
        const companyId = currentUser.companyId;
        if (companyId) {
          complaints = await storage.getComplaintsForCompany(companyId);
        } else {
          complaints = [];
        }
      } else {
        complaints = [];
      }
      
      res.json({ complaints });
    } catch (error) {
      console.error("Get complaints error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get complaints for a specific project
  app.get("/api/projects/:id/complaints", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const projectId = req.params.id;
      
      // Verify user has access to this project
      const project = await storage.getProjectById(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Check access based on role
      if (currentUser.role === "company") {
        if (project.companyId !== currentUser.id) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else if (currentUser.role === "operations_manager" || currentUser.role === "supervisor" || currentUser.role === "general_supervisor" || currentUser.role === "rope_access_supervisor" || currentUser.role === "rope_access_tech") {
        if (project.companyId !== currentUser.companyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get complaints for this project
      const complaints = await storage.getComplaintsByProject(projectId);
      
      res.json({ complaints });
    } catch (error) {
      console.error("Get project complaints error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get single complaint
  app.get("/api/complaints/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before returning complaint
      const hasAccess = await storage.verifyComplaintAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const complaint = await storage.getComplaintById(req.params.id);
      
      if (!complaint) {
        return res.status(404).json({ message: "Complaint not found" });
      }
      
      // Mark as viewed when staff access it (not residents)
      if (currentUser.role !== "resident") {
        await storage.markComplaintAsViewed(req.params.id);
      }
      
      res.json({ complaint });
    } catch (error) {
      console.error("Get complaint error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get complaint notes (staff only, residents cannot see notes)
  app.get("/api/complaints/:id/notes", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before returning notes
      const hasAccess = await storage.verifyComplaintAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const allNotes = await storage.getNotesByComplaint(req.params.id);
      
      // Residents can only see notes marked as visible to residents
      // Staff can see all notes
      const notes = currentUser.role === "resident" 
        ? allNotes.filter(note => note.visibleToResident) 
        : allNotes;
      
      res.json({ notes });
    } catch (error) {
      console.error("Get complaint notes error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Update complaint status (staff can close, residents can reopen)
  app.patch("/api/complaints/:id/status", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before updating
      const hasAccess = await storage.verifyComplaintAccess(
        req.params.id,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const { status } = req.body;
      
      if (!["open", "closed"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }
      
      // Residents can only reopen (change from closed to open)
      // Staff can change to any status
      if (currentUser.role === "resident" && status === "closed") {
        return res.status(403).json({ message: "Residents cannot close complaints" });
      }
      
      const complaint = await storage.updateComplaintStatus(req.params.id, status);
      res.json({ complaint });
    } catch (error) {
      console.error("Update complaint status error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get complaint metrics for a company (average resolution time)
  app.get("/api/complaints/metrics/:companyId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { companyId } = req.params;
      
      // Company owners can view their own metrics
      // Property managers can view metrics for linked companies
      // SuperUsers can view any company's metrics
      if (currentUser.role === "company") {
        if (currentUser.id !== companyId) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else if (currentUser.role === "property_manager") {
        const links = await storage.getPropertyManagerCompanyLinks(currentUser.id);
        const linkedCompanyIds = links.map(link => link.companyId);
        if (!linkedCompanyIds.includes(companyId)) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else if (currentUser.role !== "superuser") {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const metrics = await storage.getComplaintMetrics(companyId);
      res.json({ metrics });
    } catch (error) {
      console.error("Get complaint metrics error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Add complaint note (staff only)
  app.post("/api/complaints/:complaintId/notes", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify access before adding note
      const hasAccess = await storage.verifyComplaintAccess(
        req.params.complaintId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const noteData = insertComplaintNoteSchema.parse({
        complaintId: req.params.complaintId,
        userId: req.session.userId,
        note: req.body.note,
        visibleToResident: req.body.visibleToResident || false,
      });
      
      const noteWithUserName = {
        ...noteData,
        userName: currentUser.name || currentUser.email || "Staff",
      };
      
      const note = await storage.createComplaintNote(noteWithUserName);
      res.json({ note });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create complaint note error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Add resident reply to complaint
  app.post("/api/complaints/:complaintId/resident-reply", requireAuth, requireRole("resident"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify the complaint belongs to this resident
      const hasAccess = await storage.verifyComplaintAccess(
        req.params.complaintId,
        currentUser.id,
        currentUser.role,
        currentUser.companyId
      );
      
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied - You can only reply to your own complaints" });
      }
      
      const noteData = insertComplaintNoteSchema.parse({
        complaintId: req.params.complaintId,
        userId: req.session.userId,
        note: req.body.note,
        visibleToResident: true, // Resident replies are always visible to residents
      });
      
      const noteWithUserName = {
        ...noteData,
        userName: currentUser.name || currentUser.unitNumber || "Resident",
      };
      
      const note = await storage.createComplaintNote(noteWithUserName);
      res.json({ note });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create resident reply error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Equipment Catalog routes - shared database of gear that builds over time
  app.get("/api/equipment-catalog", requireAuth, async (req: Request, res: Response) => {
    try {
      const { type } = req.query;
      
      if (!type || typeof type !== 'string') {
        return res.status(400).json({ message: "Equipment type is required" });
      }
      
      // Fetch all catalog items for this equipment type, ordered by usage count (most popular first)
      const items = await db.select()
        .from(equipmentCatalog)
        .where(eq(equipmentCatalog.equipmentType, type))
        .orderBy(desc(equipmentCatalog.usageCount), asc(equipmentCatalog.brand), asc(equipmentCatalog.model));
      
      res.json({ items });
    } catch (error) {
      console.error("Get equipment catalog error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Add new item to equipment catalog (when user selects "Other")
  app.post("/api/equipment-catalog", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const { equipmentType, brand, model } = req.body;
      
      if (!equipmentType || !brand || !model) {
        return res.status(400).json({ message: "Equipment type, brand, and model are required" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      // Try to insert, if it already exists just return the existing item
      const [existingItem] = await db.select()
        .from(equipmentCatalog)
        .where(and(
          eq(equipmentCatalog.equipmentType, equipmentType),
          eq(equipmentCatalog.brand, brand),
          eq(equipmentCatalog.model, model)
        ));
      
      if (existingItem) {
        // Increment usage count
        await db.update(equipmentCatalog)
          .set({ usageCount: sql`${equipmentCatalog.usageCount} + 1` })
          .where(eq(equipmentCatalog.id, existingItem.id));
        return res.json({ item: existingItem, isNew: false });
      }
      
      // Create new catalog entry
      const [newItem] = await db.insert(equipmentCatalog).values({
        equipmentType,
        brand,
        model,
        isPrePopulated: false,
        addedByCompanyId: companyId,
        usageCount: 1,
      }).returning();
      
      res.json({ item: newItem, isNew: true });
    } catch (error) {
      console.error("Add equipment catalog error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Increment usage count when a catalog item is selected
  app.patch("/api/equipment-catalog/:id/use", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      await db.update(equipmentCatalog)
        .set({ usageCount: sql`${equipmentCatalog.usageCount} + 1` })
        .where(eq(equipmentCatalog.id, id));
      
      res.json({ success: true });
    } catch (error) {
      console.error("Increment usage count error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Gear items routes
  app.get("/api/gear-items", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory view permission
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Storage now returns items with serialEntries already attached
      const items = await storage.getGearItemsByCompany(companyId);
      
      // Get ALL assignments for this company to calculate assigned quantities
      const allAssignments = await db.select()
        .from(gearAssignments)
        .where(eq(gearAssignments.companyId, companyId));
      
      // Calculate assigned quantity for each item (ensure numeric addition)
      const assignedByItem = new Map<string, number>();
      for (const assignment of allAssignments) {
        const current = assignedByItem.get(assignment.gearItemId) || 0;
        const qty = Number(assignment.quantity) || 0;
        assignedByItem.set(assignment.gearItemId, current + qty);
      }
      
      // Debug logging for gear items
      console.log('[GEAR-ITEMS] Company:', companyId);
      console.log('[GEAR-ITEMS] Total assignments fetched:', allAssignments.length);
      console.log('[GEAR-ITEMS] Raw assignments:', allAssignments.map(a => ({ 
        id: a.id.substring(0, 8), 
        itemId: a.gearItemId.substring(0, 8), 
        qty: a.quantity, 
        typeofQty: typeof a.quantity 
      })));
      console.log('[GEAR-ITEMS] Summed by item:', Object.fromEntries(assignedByItem));
      
      // Get all active (non-retired) serial numbers for this company
      const allSerialNumbers = await db.select()
        .from(gearSerialNumbers)
        .where(and(
          eq(gearSerialNumbers.companyId, companyId),
          eq(gearSerialNumbers.isRetired, false)
        ));
      
      // Build set of assigned serial numbers
      const assignedSerials = new Set<string>();
      for (const assignment of allAssignments) {
        if (assignment.serialNumber) {
          assignedSerials.add(assignment.serialNumber);
        }
      }
      
      // Filter out financial data if user doesn't have permission
      const hasFinancialPermission = currentUser.role === "company" || 
        (currentUser.permissions && currentUser.permissions.includes("view_financial_data"));
      
      const filteredItems = items.map(item => {
        const totalQuantity = Number(item.quantity) || 0;
        const assignedQuantity = assignedByItem.get(item.id) || 0;
        // Available slots = total quantity minus assigned (regardless of serial registration)
        const availableSlots = Math.max(0, totalQuantity - assignedQuantity);
        
        // Get unassigned serial numbers for this item (for the picker UI)
        const itemSerials = allSerialNumbers.filter(s => s.gearItemId === item.id);
        const unassignedSerials = itemSerials
          .filter(s => !assignedSerials.has(s.serialNumber))
          .map(s => s.serialNumber);
        const registeredSerialCount = itemSerials.length;
        
        // Get full serial entries for this item (with dates, for edit dialog)
        const fullSerialEntries = (item as any).serialEntries || [];
        
        if (!hasFinancialPermission) {
          const { itemPrice, ...rest } = item;
          return { ...rest, assignedQuantity, availableQuantity: availableSlots, serialNumbers: unassignedSerials, registeredSerialCount, serialEntries: fullSerialEntries };
        }
        return { ...item, assignedQuantity, availableQuantity: availableSlots, serialNumbers: unassignedSerials, registeredSerialCount, serialEntries: fullSerialEntries };
      });
      
      res.json({ items: filteredItems });
    } catch (error) {
      console.error("Get gear items error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/gear-items", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory manage permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Clean empty strings to undefined/null for optional fields
      const cleanedBody = {
        equipmentType: req.body.equipmentType || null,
        brand: req.body.brand || null,
        model: req.body.model || null,
        itemPrice: req.body.itemPrice || null,
        assignedTo: req.body.assignedTo?.trim() || "Not in use",
        notes: req.body.notes || null,
        quantity: req.body.quantity || 1,
        serialNumbers: req.body.serialNumbers || null,
        dateInService: req.body.dateInService || null,
        dateOutOfService: req.body.dateOutOfService || null,
        inService: req.body.inService !== undefined ? req.body.inService : true,
      };
      
      const itemData = insertGearItemSchema.parse({
        ...cleanedBody,
        companyId,
        employeeId: req.session.userId,
      });
      
      // Use storage method with serialEntries support
      const serialEntries = req.body.serialEntries || [];
      const item = await storage.createGearItem(itemData, serialEntries);
      console.log("Created gear item:", item.id);
      
      // If assignment info is provided, create the assignment
      if (req.body.assignEmployeeId && req.body.assignQuantity) {
        console.log("Assignment info provided - employeeId:", req.body.assignEmployeeId, "quantity:", req.body.assignQuantity);
        const assignQuantity = parseInt(req.body.assignQuantity);
        if (assignQuantity > 0 && assignQuantity <= (item.quantity || 0)) {
          console.log("Creating assignment...");
          const assignment = await storage.createGearAssignment({
            gearItemId: item.id,
            companyId,
            employeeId: req.body.assignEmployeeId,
            quantity: assignQuantity,
          });
          console.log("Assignment created:", assignment);
        } else {
          console.log("Assignment validation failed - quantity:", assignQuantity, "item quantity:", item.quantity);
        }
      } else {
        console.log("No assignment info provided");
      }
      
      res.json({ item });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create gear item error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/gear-items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory manage permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Clean empty strings to null for optional fields
      const cleanedBody: Partial<InsertGearItem> = {};
      if (req.body.equipmentType !== undefined) cleanedBody.equipmentType = req.body.equipmentType || null;
      if (req.body.brand !== undefined) cleanedBody.brand = req.body.brand || null;
      if (req.body.model !== undefined) cleanedBody.model = req.body.model || null;
      if (req.body.itemPrice !== undefined) cleanedBody.itemPrice = req.body.itemPrice || null;
      if (req.body.assignedTo !== undefined) cleanedBody.assignedTo = req.body.assignedTo?.trim() || "Not in use";
      if (req.body.notes !== undefined) cleanedBody.notes = req.body.notes || null;
      if (req.body.quantity !== undefined) cleanedBody.quantity = req.body.quantity;
      if (req.body.serialNumbers !== undefined) cleanedBody.serialNumbers = req.body.serialNumbers || null;
      if (req.body.dateInService !== undefined) cleanedBody.dateInService = req.body.dateInService || null;
      if (req.body.dateOutOfService !== undefined) cleanedBody.dateOutOfService = req.body.dateOutOfService || null;
      if (req.body.inService !== undefined) cleanedBody.inService = req.body.inService;
      
      // Pass serialEntries to the storage method for proper persistence
      const serialEntries = req.body.serialEntries || undefined;
      const item = await storage.updateGearItem(req.params.id, cleanedBody, serialEntries);
      res.json({ item });
    } catch (error) {
      console.error("Update gear item error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/gear-items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory manage permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      await storage.deleteGearItem(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete gear item error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Gear assignments routes
  
  // Get all gear assignments (for My Gear view)
  app.get("/api/gear-assignments", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Everyone can see their own gear assignments
      // But viewing ALL assignments requires view_gear_assignments permission
      let assignments;
      if (canViewGearAssignments(currentUser)) {
        // User has permission to view all gear assignments
        assignments = await db.select()
          .from(gearAssignments)
          .where(eq(gearAssignments.companyId, companyId));
      } else {
        // Only show user's own gear assignments
        assignments = await db.select()
          .from(gearAssignments)
          .where(eq(gearAssignments.employeeId, currentUser.id));
      }
      
      res.json({ assignments });
    } catch (error) {
      console.error("Get all gear assignments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Create a gear assignment (manager assigns to employee)
  // Handles both picking existing serials and entering new ones (atomic registration + assignment)
  app.post("/api/gear-assignments", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check assign gear permission
      if (!canAssignGear(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient permissions to assign gear" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const gearItemId = req.body.gearItemId;
      const rawQuantity = parseInt(req.body.quantity);
      const requestedQuantity = isNaN(rawQuantity) || rawQuantity < 1 ? 1 : rawQuantity;
      // Normalize serial number: trim whitespace and convert to uppercase for consistency
      const serialNumber = req.body.serialNumber?.trim().toUpperCase() || undefined;
      
      // Verify the gear item exists and belongs to company
      const gearItem = await db.select().from(gearItems).where(eq(gearItems.id, gearItemId)).limit(1);
      
      if (!gearItem.length || gearItem[0].companyId !== companyId) {
        return res.status(404).json({ message: "Gear item not found" });
      }
      
      // Check available slots (quantity - assigned)
      const existingAssignments = await db.select()
        .from(gearAssignments)
        .where(eq(gearAssignments.gearItemId, gearItemId));
      
      const totalAssigned = existingAssignments.reduce((sum, a) => sum + (a.quantity || 0), 0);
      const totalQuantity = Number(gearItem[0].quantity) || 0;
      const availableSlots = Math.max(0, totalQuantity - totalAssigned);
      
      if (requestedQuantity > availableSlots) {
        return res.status(400).json({ 
          message: `Not enough available. Only ${availableSlots} of ${totalQuantity} available.`,
          availableSlots
        });
      }
      
      // If serial number provided, check if it needs to be registered
      if (serialNumber) {
        // Check if serial already exists for this gear item (case-insensitive due to uppercase normalization)
        const existingSerial = await db.select()
          .from(gearSerialNumbers)
          .where(and(
            eq(gearSerialNumbers.gearItemId, gearItemId),
            eq(gearSerialNumbers.serialNumber, serialNumber)
          ))
          .limit(1);
        
        // Check if serial is already assigned to someone
        const serialAssignment = await db.select()
          .from(gearAssignments)
          .where(and(
            eq(gearAssignments.gearItemId, gearItemId),
            eq(gearAssignments.serialNumber, serialNumber)
          ))
          .limit(1);
        
        if (serialAssignment.length > 0) {
          return res.status(400).json({ 
            message: "This serial number is already assigned to someone else" 
          });
        }
        
        // If serial doesn't exist, register it first (atomic with assignment)
        if (!existingSerial.length) {
          await db.insert(gearSerialNumbers).values({
            gearItemId,
            companyId,
            serialNumber,
            dateOfManufacture: req.body.dateOfManufacture || undefined,
            dateInService: req.body.dateInService || undefined,
          });
        }
      }
      
      // Create assignment
      const assignment = await storage.createGearAssignment({
        gearItemId,
        companyId,
        employeeId: req.body.employeeId,
        quantity: requestedQuantity,
        serialNumber,
        dateOfManufacture: req.body.dateOfManufacture || undefined,
        dateInService: req.body.dateInService || undefined,
      });
      
      res.json({ assignment });
    } catch (error: any) {
      // Handle unique constraint violation (duplicate serial)
      if (error?.code === '23505' && error?.constraint?.includes('serial')) {
        return res.status(400).json({ message: "This serial number already exists for this item" });
      }
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create gear assignment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  app.get("/api/gear-items/:id/assignments", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory view permission (needed to see gear item assignments)
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const assignments = await db.select()
        .from(gearAssignments)
        .where(eq(gearAssignments.gearItemId, req.params.id));
      
      res.json({ assignments });
    } catch (error) {
      console.error("Get gear assignments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/gear-items/:id/assignments", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check assign gear permission
      if (!canAssignGear(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient permissions to assign gear" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const assignmentData = insertGearAssignmentSchema.parse({
        gearItemId: req.params.id,
        companyId,
        employeeId: req.body.employeeId,
        quantity: req.body.quantity,
      });
      
      const [assignment] = await db.insert(gearAssignments)
        .values(assignmentData)
        .returning();
      
      res.json({ assignment });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create gear assignment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get current user's kit (their assigned gear with full details)
  app.get("/api/my-kit", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get all gear assignments for the current user
      const userAssignments = await db
        .select()
        .from(gearAssignments)
        .where(eq(gearAssignments.employeeId, currentUser.id));
      
      // Get full gear item details for each assignment
      const kitItems = await Promise.all(
        userAssignments.map(async (assignment) => {
          const [gearItem] = await db
            .select()
            .from(gearItems)
            .where(eq(gearItems.id, assignment.gearItemId));
          
          // Get serial numbers for this item
          const serialNumbers = await db
            .select()
            .from(gearSerialNumbers)
            .where(eq(gearSerialNumbers.gearItemId, assignment.gearItemId));
          
          return {
            assignmentId: assignment.id,
            gearItemId: gearItem?.id,
            equipmentType: gearItem?.equipmentType,
            brand: gearItem?.brand,
            model: gearItem?.model,
            quantity: assignment.quantity,
            serialNumber: assignment.serialNumber || (serialNumbers.length > 0 ? serialNumbers[0].serialNumber : null),
            serialNumbers: serialNumbers.map(sn => sn.serialNumber),
            dateInService: assignment.dateInService || gearItem?.dateInService,
            dateOfManufacture: assignment.dateOfManufacture || gearItem?.dateOfManufacture,
            inService: gearItem?.inService,
          };
        })
      );
      
      // Filter out any items where gear wasn't found
      const validKitItems = kitItems.filter(item => item.gearItemId);
      
      res.json({ 
        kit: validKitItems,
        employeeName: currentUser.name,
        employeeId: currentUser.id
      });
    } catch (error) {
      console.error("Get my kit error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Self-assign gear - allows any employee to assign gear to themselves
  // Handles both picking existing serials and entering new ones (atomic registration + assignment)
  app.post("/api/gear-assignments/self", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const gearItemId = req.body.gearItemId;
      const rawQuantity = parseInt(req.body.quantity);
      const requestedQuantity = isNaN(rawQuantity) || rawQuantity < 1 ? 1 : rawQuantity;
      // Normalize serial number: trim whitespace and convert to uppercase for consistency
      const serialNumber = req.body.serialNumber?.trim().toUpperCase() || undefined;
      
      // Verify the gear item belongs to the same company
      const gearItem = await db.select().from(gearItems).where(eq(gearItems.id, gearItemId)).limit(1);
      
      if (!gearItem.length || gearItem[0].companyId !== companyId) {
        return res.status(404).json({ message: "Gear item not found" });
      }
      
      // Check available slots (quantity - assigned)
      const existingAssignments = await db.select()
        .from(gearAssignments)
        .where(eq(gearAssignments.gearItemId, gearItemId));
      
      const totalAssigned = existingAssignments.reduce((sum, a) => sum + (a.quantity || 0), 0);
      const totalQuantity = Number(gearItem[0].quantity) || 0;
      const availableSlots = Math.max(0, totalQuantity - totalAssigned);
      
      if (requestedQuantity > availableSlots) {
        return res.status(400).json({ 
          message: `Not enough available. Only ${availableSlots} of ${totalQuantity} available.`,
          availableSlots
        });
      }
      
      // Normalize date values - ensure they are valid date strings or null (not undefined or empty string)
      const dateOfManufacture = req.body.dateOfManufacture && req.body.dateOfManufacture.trim() !== '' 
        ? req.body.dateOfManufacture.trim() 
        : null;
      const dateInService = req.body.dateInService && req.body.dateInService.trim() !== '' 
        ? req.body.dateInService.trim() 
        : null;
      
      // If serial number provided, check if it needs to be registered
      if (serialNumber) {
        // Check if serial already exists for this gear item (case-insensitive due to uppercase normalization)
        const existingSerial = await db.select()
          .from(gearSerialNumbers)
          .where(and(
            eq(gearSerialNumbers.gearItemId, gearItemId),
            eq(gearSerialNumbers.serialNumber, serialNumber)
          ))
          .limit(1);
        
        // Check if serial is already assigned to someone
        const serialAssignment = await db.select()
          .from(gearAssignments)
          .where(and(
            eq(gearAssignments.gearItemId, gearItemId),
            eq(gearAssignments.serialNumber, serialNumber)
          ))
          .limit(1);
        
        if (serialAssignment.length > 0) {
          return res.status(400).json({ 
            message: "This serial number is already assigned to someone else" 
          });
        }
        
        // If serial doesn't exist, register it first (atomic with assignment)
        if (!existingSerial.length) {
          await db.insert(gearSerialNumbers).values({
            gearItemId,
            companyId,
            serialNumber,
            dateOfManufacture,
            dateInService,
          });
        }
      }
      
      // Create assignment to self
      const assignment = await storage.createGearAssignment({
        gearItemId,
        companyId,
        employeeId: currentUser.id,
        quantity: requestedQuantity,
        serialNumber,
        dateOfManufacture,
        dateInService,
      });
      
      res.json({ assignment });
    } catch (error: any) {
      // Handle unique constraint violation (duplicate serial)
      if (error?.code === '23505' && error?.constraint?.includes('serial')) {
        return res.status(400).json({ message: "This serial number already exists for this item" });
      }
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Self-assign gear error:", error);
      console.error("Self-assign gear error details:", {
        message: error?.message,
        code: error?.code,
        detail: error?.detail,
        constraint: error?.constraint,
        stack: error?.stack?.split('\n').slice(0, 5).join('\n'),
      });
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Remove self-assigned gear
  app.delete("/api/gear-assignments/self/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify the assignment belongs to the current user
      const assignment = await db.select().from(gearAssignments).where(eq(gearAssignments.id, req.params.id)).limit(1);
      
      if (!assignment.length) {
        return res.status(404).json({ message: "Assignment not found" });
      }
      
      if (assignment[0].employeeId !== currentUser.id) {
        return res.status(403).json({ message: "You can only remove your own gear assignments" });
      }
      
      await storage.deleteGearAssignment(req.params.id);
      
      res.json({ message: "Gear assignment removed" });
    } catch (error) {
      console.error("Remove self-assigned gear error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update your own gear assignment details
  app.patch("/api/gear-assignments/self/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Verify the assignment belongs to the current user
      const existingAssignment = await db.select().from(gearAssignments).where(eq(gearAssignments.id, req.params.id)).limit(1);
      
      if (!existingAssignment.length) {
        return res.status(404).json({ message: "Assignment not found" });
      }
      
      if (existingAssignment[0].employeeId !== currentUser.id) {
        return res.status(403).json({ message: "You can only edit your own gear assignments" });
      }
      
      // Update the assignment
      const updates: any = { updatedAt: new Date() };
      if (req.body.serialNumber !== undefined) updates.serialNumber = req.body.serialNumber || null;
      if (req.body.dateOfManufacture !== undefined) updates.dateOfManufacture = req.body.dateOfManufacture || null;
      if (req.body.dateInService !== undefined) updates.dateInService = req.body.dateInService || null;
      
      const [assignment] = await db.update(gearAssignments)
        .set(updates)
        .where(eq(gearAssignments.id, req.params.id))
        .returning();
      
      res.json({ assignment });
    } catch (error) {
      console.error("Update self-assigned gear error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/gear-assignments/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check assign gear permission (needed to edit assignments)
      if (!canAssignGear(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient permissions to manage gear assignments" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const updates: Partial<InsertGearAssignment> = {};
      if (req.body.employeeId !== undefined) updates.employeeId = req.body.employeeId;
      if (req.body.quantity !== undefined) updates.quantity = req.body.quantity;
      if (req.body.serialNumber !== undefined) updates.serialNumber = req.body.serialNumber;
      if (req.body.dateOfManufacture !== undefined) updates.dateOfManufacture = req.body.dateOfManufacture || null;
      if (req.body.dateInService !== undefined) updates.dateInService = req.body.dateInService || null;
      
      const [assignment] = await db.update(gearAssignments)
        .set({ ...updates, updatedAt: new Date() })
        .where(eq(gearAssignments.id, req.params.id))
        .returning();
      
      res.json({ assignment });
    } catch (error) {
      console.error("Update gear assignment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/gear-assignments/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check assign gear permission (needed to delete assignments)
      if (!canAssignGear(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient permissions to manage gear assignments" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      await db.delete(gearAssignments)
        .where(eq(gearAssignments.id, req.params.id));
      
      res.json({ success: true });
    } catch (error) {
      console.error("Delete gear assignment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Gear serial numbers routes - per-item serial number tracking with dates
  app.get("/api/gear-items/:id/serial-numbers", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory view permission
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get all serial numbers for this gear item
      const serialNumbers = await db.select()
        .from(gearSerialNumbers)
        .where(eq(gearSerialNumbers.gearItemId, req.params.id));
      
      // Get all assignments for this gear item to determine which serial numbers are taken
      const itemAssignments = await db.select()
        .from(gearAssignments)
        .where(eq(gearAssignments.gearItemId, req.params.id));
      
      // Create a set of assigned serial numbers
      const assignedSerialNumbers = new Set(
        itemAssignments
          .map(a => a.serialNumber)
          .filter((sn): sn is string => sn !== null && sn !== undefined)
      );
      
      // Add isAssigned flag to each serial number
      const serialNumbersWithStatus = serialNumbers.map(sn => ({
        ...sn,
        isAssigned: assignedSerialNumbers.has(sn.serialNumber),
      }));
      
      res.json({ serialNumbers: serialNumbersWithStatus, assignedSerialNumbers: Array.from(assignedSerialNumbers) });
    } catch (error) {
      console.error("Get gear serial numbers error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/gear-items/:id/serial-numbers", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check manage inventory permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const serialData = insertGearSerialNumberSchema.parse({
        gearItemId: req.params.id,
        companyId,
        serialNumber: req.body.serialNumber,
        dateOfManufacture: req.body.dateOfManufacture || undefined,
        dateInService: req.body.dateInService || undefined,
      });
      
      const [serialNumber] = await db.insert(gearSerialNumbers)
        .values(serialData)
        .returning();
      
      res.json({ serialNumber });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create gear serial number error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/gear-serial-numbers/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check manage inventory permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      await db.delete(gearSerialNumbers)
        .where(eq(gearSerialNumbers.id, req.params.id));
      
      res.json({ success: true });
    } catch (error) {
      console.error("Delete gear serial number error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Retire a specific gear serial number (soft delete - keeps record but marks as retired)
  app.patch("/api/gear-serial-numbers/:id/retire", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check manage inventory permission
      if (!canManageInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { reason } = req.body;
      
      if (!reason || typeof reason !== 'string' || reason.trim().length === 0) {
        return res.status(400).json({ message: "Retirement reason is required" });
      }
      
      // Verify the serial number exists and belongs to the company
      const [existingSerial] = await db.select()
        .from(gearSerialNumbers)
        .where(and(
          eq(gearSerialNumbers.id, req.params.id),
          eq(gearSerialNumbers.companyId, companyId)
        ))
        .limit(1);
      
      if (!existingSerial) {
        return res.status(404).json({ message: "Serial number not found" });
      }
      
      if (existingSerial.isRetired) {
        return res.status(400).json({ message: "This item is already retired" });
      }
      
      // If the serial number is assigned to someone, unassign it first
      await db.delete(gearAssignments)
        .where(and(
          eq(gearAssignments.serialNumber, existingSerial.serialNumber),
          eq(gearAssignments.gearItemId, existingSerial.gearItemId),
          eq(gearAssignments.companyId, companyId)
        ));
      
      // Mark as retired
      const [retiredSerial] = await db.update(gearSerialNumbers)
        .set({
          isRetired: true,
          retiredAt: new Date(),
          retiredById: currentUser.id,
          retiredReason: reason.trim(),
          updatedAt: new Date(),
        })
        .where(eq(gearSerialNumbers.id, req.params.id))
        .returning();
      
      // Decrement the quantity on the parent gear item
      const [parentItem] = await db.select()
        .from(gearItems)
        .where(eq(gearItems.id, existingSerial.gearItemId))
        .limit(1);
      
      if (parentItem && parentItem.quantity > 0) {
        await db.update(gearItems)
          .set({
            quantity: parentItem.quantity - 1,
            updatedAt: new Date(),
          })
          .where(eq(gearItems.id, existingSerial.gearItemId));
      }
      
      res.json({ serialNumber: retiredSerial });
    } catch (error) {
      console.error("Retire gear serial number error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get retired gear for a company
  app.get("/api/retired-gear", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check view inventory permission
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get all retired serial numbers with their gear item info
      const retiredItems = await db.select({
        id: gearSerialNumbers.id,
        serialNumber: gearSerialNumbers.serialNumber,
        dateOfManufacture: gearSerialNumbers.dateOfManufacture,
        dateInService: gearSerialNumbers.dateInService,
        retiredAt: gearSerialNumbers.retiredAt,
        retiredById: gearSerialNumbers.retiredById,
        retiredReason: gearSerialNumbers.retiredReason,
        gearItemId: gearSerialNumbers.gearItemId,
        gearItemCategory: gearItems.category,
        gearItemType: gearItems.type,
        gearItemBrand: gearItems.brand,
        gearItemModel: gearItems.model,
      })
        .from(gearSerialNumbers)
        .innerJoin(gearItems, eq(gearSerialNumbers.gearItemId, gearItems.id))
        .where(and(
          eq(gearSerialNumbers.companyId, companyId),
          eq(gearSerialNumbers.isRetired, true)
        ))
        .orderBy(sql`${gearSerialNumbers.retiredAt} DESC`);
      
      // Get the names of people who retired items
      const retiredByIds = [...new Set(retiredItems.filter(i => i.retiredById).map(i => i.retiredById!))];
      const retiredByUsers = retiredByIds.length > 0 
        ? await db.select({ id: users.id, firstName: users.firstName, lastName: users.lastName })
            .from(users)
            .where(inArray(users.id, retiredByIds))
        : [];
      
      const userMap = new Map(retiredByUsers.map(u => [u.id, `${u.firstName || ''} ${u.lastName || ''}`.trim() || 'Unknown']));
      
      const retiredGearWithNames = retiredItems.map(item => ({
        ...item,
        retiredByName: item.retiredById ? userMap.get(item.retiredById) || 'Unknown' : null,
      }));
      
      res.json({ retiredGear: retiredGearWithNames });
    } catch (error) {
      console.error("Get retired gear error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Equipment Damage Report routes
  app.get("/api/equipment-damage-reports", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory view permission
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      // Check sensitive documents permission
      if (!canViewSensitiveDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view sensitive documents" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const reports = await storage.getEquipmentDamageReportsByCompany(companyId);
      res.json({ reports });
    } catch (error) {
      console.error("Get equipment damage reports error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/equipment-damage-reports/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check inventory view permission
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient inventory permissions" });
      }
      
      // Check sensitive documents permission
      if (!canViewSensitiveDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view sensitive documents" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const report = await storage.getEquipmentDamageReportById(req.params.id);
      
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      
      // Verify the report belongs to the user's company
      if (report.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      res.json({ report });
    } catch (error) {
      console.error("Get equipment damage report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/equipment-damage-reports", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Require at least view inventory permission to report damage
      if (!canViewInventory(currentUser)) {
        return res.status(403).json({ message: "Access denied - Insufficient permissions to report equipment damage" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Validate required fields
      if (!req.body.gearItemId) {
        return res.status(400).json({ message: "Gear item ID is required" });
      }
      if (!req.body.damageDescription || !req.body.damageDescription.trim()) {
        return res.status(400).json({ message: "Damage description is required" });
      }
      if (!req.body.discoveredDate) {
        return res.status(400).json({ message: "Discovered date is required" });
      }
      if (!req.body.damageSeverity) {
        return res.status(400).json({ message: "Damage severity is required" });
      }
      
      // Verify the gear item belongs to this company
      const gearItem = await db.select()
        .from(gearItems)
        .where(eq(gearItems.id, req.body.gearItemId))
        .limit(1);
      
      if (!gearItem[0]) {
        return res.status(404).json({ message: "Gear item not found" });
      }
      
      if (gearItem[0].companyId !== companyId) {
        return res.status(403).json({ message: "Access denied - This equipment does not belong to your company" });
      }
      
      // If retiring equipment, require retirement reason
      if (req.body.equipmentRetired && (!req.body.retirementReason || !req.body.retirementReason.trim())) {
        return res.status(400).json({ message: "Retirement reason is required when retiring equipment" });
      }
      
      const reportData = insertEquipmentDamageReportSchema.parse({
        ...req.body,
        companyId,
        reportedBy: req.session.userId,
        reporterName: currentUser.name || currentUser.email || "Unknown User",
        equipmentType: gearItem[0].equipmentType,
        equipmentBrand: gearItem[0].brand,
        equipmentModel: gearItem[0].model,
      });
      
      const report = await storage.createEquipmentDamageReport(reportData);
      
      // If equipment was retired, handle retirement based on whether a specific serial number was selected
      if (report.equipmentRetired && report.gearItemId) {
        if (report.gearSerialNumberId) {
          // Retire only the specific serial number entry
          await db.update(gearSerialNumbers)
            .set({ 
              isRetired: true, 
              retiredAt: new Date(),
            })
            .where(eq(gearSerialNumbers.id, report.gearSerialNumberId));
        } else {
          // No specific serial number - decrement quantity by 1 (minimum 0)
          const currentItem = gearItem[0];
          const newQuantity = Math.max(0, (currentItem.quantity || 1) - 1);
          await db.update(gearItems)
            .set({ 
              quantity: newQuantity,
              inService: newQuantity > 0, // Mark as out of service if quantity is 0
              notes: `${currentItem.notes || ''}\nRetired 1 unit due to damage: ${report.damageDescription}`.trim(),
            })
            .where(eq(gearItems.id, report.gearItemId));
        }
      }
      
      res.json({ report });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create equipment damage report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Harness inspection routes
  app.post("/api/harness-inspections", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Convert empty strings to undefined for optional fields
      const cleanedBody = {
        ...req.body,
        dateInService: req.body.dateInService || undefined,
        projectId: (req.body.projectId === "none" || !req.body.projectId) ? undefined : req.body.projectId,
      };
      
      const inspectionData = insertHarnessInspectionSchema.parse({
        ...cleanedBody,
        companyId,
        workerId: req.session.userId,
      });
      
      const inspection = await storage.createHarnessInspection(inspectionData);
      res.json({ inspection });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create harness inspection error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/harness-inspections", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check sensitive documents permission
      if (!canViewSensitiveDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view sensitive documents" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const inspections = await storage.getHarnessInspectionsByCompany(companyId);
      res.json({ inspections });
    } catch (error) {
      console.error("Get harness inspections error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/my-harness-inspections", requireAuth, requireRole("rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const inspections = await storage.getHarnessInspectionsByWorker(req.session.userId!);
      res.json({ inspections });
    } catch (error) {
      console.error("Get my harness inspections error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Check if user has done a harness inspection today (any project)
  app.get("/api/harness-inspection-today", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
      
      const inspections = await storage.getHarnessInspectionsByWorker(userId);
      
      // Check if any inspection was done today (full inspection, not just "not applicable")
      const todayInspection = inspections.find((inspection: any) => {
        const inspectionDate = inspection.inspectionDate?.split('T')[0];
        return inspectionDate === today;
      });
      
      res.json({ 
        hasInspectionToday: !!todayInspection,
        inspection: todayInspection || null
      });
    } catch (error) {
      console.error("Check harness inspection today error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/harness-inspections/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await storage.deleteHarnessInspection(id);
      res.json({ message: "Harness inspection deleted successfully" });
    } catch (error) {
      console.error("Delete harness inspection error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Personal harness inspection routes (for technicians' personal safety documents)
  app.post("/api/personal-harness-inspections", requireAuth, requireRole("rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      
      // Convert empty strings to undefined for optional fields
      const cleanedBody = {
        ...req.body,
        dateInService: req.body.dateInService || undefined,
        projectId: undefined, // Personal inspections don't have projects
      };
      
      // For personal inspections, set companyId and workerId to the technician's own ID
      // and mark as personal
      const inspectionData = insertHarnessInspectionSchema.parse({
        ...cleanedBody,
        companyId: userId,
        workerId: userId,
        isPersonal: true,
      });
      
      const inspection = await storage.createHarnessInspection(inspectionData);
      res.json({ inspection });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create personal harness inspection error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/personal-harness-inspections", requireAuth, requireRole("rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const userId = req.session.userId!;
      const inspections = await storage.getPersonalHarnessInspections(userId);
      res.json({ inspections });
    } catch (error) {
      console.error("Get personal harness inspections error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/personal-harness-inspections/:id", requireAuth, requireRole("rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const userId = req.session.userId!;
      
      // Verify the inspection belongs to this user and is personal
      const inspection = await storage.getHarnessInspectionById(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }
      if (inspection.workerId !== userId || !inspection.isPersonal) {
        return res.status(403).json({ message: "Not authorized to delete this inspection" });
      }
      
      await storage.deleteHarnessInspection(id);
      res.json({ message: "Personal harness inspection deleted successfully" });
    } catch (error) {
      console.error("Delete personal harness inspection error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Toolbox meeting routes
  app.post("/api/toolbox-meetings", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Validate that all attendees have signed (using IDs for reliable matching)
      const { attendeeIds, signatures } = req.body;
      if (attendeeIds && Array.isArray(attendeeIds) && attendeeIds.length > 0) {
        // Validate signature content - ensure each signature has non-empty data
        const validSignatures = (signatures || []).filter((sig: any) => 
          sig && sig.employeeId && sig.signatureDataUrl && sig.signatureDataUrl.length > 0
        );
        const signatureEmployeeIds = validSignatures.map((sig: any) => sig.employeeId);
        const unsignedAttendeeIds = attendeeIds.filter((id: string) => !signatureEmployeeIds.includes(id));
        
        if (unsignedAttendeeIds.length > 0) {
          // Get names from storage for accurate error message (don't trust client-provided names)
          const unsignedNames: string[] = [];
          for (const id of unsignedAttendeeIds) {
            const employee = await storage.getUserById(id);
            unsignedNames.push(employee?.name || `Employee ${id}`);
          }
          return res.status(400).json({ 
            message: `All attendees must sign. Missing signatures from: ${unsignedNames.join(", ")}` 
          });
        }
      }
      
      const meetingData = insertToolboxMeetingSchema.parse({
        ...req.body,
        companyId,
        conductedBy: req.session.userId,
      });
      
      const meeting = await storage.createToolboxMeeting(meetingData);
      res.json({ meeting });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create toolbox meeting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/toolbox-meetings", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const meetings = await storage.getToolboxMeetingsByCompany(companyId);
      res.json({ meetings });
    } catch (error) {
      console.error("Get toolbox meetings error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/projects/:projectId/toolbox-meetings", requireAuth, async (req: Request, res: Response) => {
    try {
      const meetings = await storage.getToolboxMeetingsByProject(req.params.projectId);
      res.json({ meetings });
    } catch (error) {
      console.error("Get project toolbox meetings error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/toolbox-meetings/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await storage.deleteToolboxMeeting(id);
      res.json({ message: "Toolbox meeting deleted successfully" });
    } catch (error) {
      console.error("Delete toolbox meeting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Company Safety Rating (CSR) endpoint - combines all safety metrics
  // NEW LOGIC: Start at 100%, only deduct for non-compliance
  // - Documentation: -25% if either Health & Safety Manual or Company Policy is missing
  // - Toolbox Meetings: Deduct proportionally if meetings are missed (only when there are work sessions)
  // - Harness Inspections: Deduct proportionally if inspections are missed (only when required)
  // - Project Completion: Bonus metric - doesn't penalize new companies
  app.get("/api/company-safety-rating", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if user has permission to view CSR
      if (!canViewCSR(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view CSR" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // 1. Company Documentation Points (NEW SCR SYSTEM)
      // Formula: 1 point if all 3 docs uploaded (H&S Manual, Company Policy, Certificate of Insurance)
      // Partial: (Uploaded Docs / 3)
      const companyDocuments = await storage.getCompanyDocuments(companyId);
      const hasHealthSafety = companyDocuments.some((doc: any) => doc.documentType === 'health_safety_manual');
      const hasCompanyPolicy = companyDocuments.some((doc: any) => doc.documentType === 'company_policy');
      const hasInsurance = companyDocuments.some((doc: any) => doc.documentType === 'certificate_of_insurance');
      
      const companyDocsUploaded = (hasHealthSafety ? 1 : 0) + (hasCompanyPolicy ? 1 : 0) + (hasInsurance ? 1 : 0);
      const companyDocumentationPoints = Math.round((companyDocsUploaded / 3) * 100) / 100;
      
      // Legacy rating for backward compatibility
      const documentationRating = Math.round((companyDocsUploaded / 3) * 100);
      const documentationPenalty = 0;
      
      // 2. Toolbox Meeting Compliance (with 7-day coverage window)
      // A toolbox meeting covers its project for 7 days forward from the meeting date
      // Meetings can occur outside of work sessions and still provide coverage
      const TOOLBOX_COVERAGE_DAYS = 7;
      
      const projects = await storage.getProjectsByCompany(companyId);
      const meetings = await storage.getToolboxMeetingsByCompany(companyId);
      
      // Get all work sessions across projects
      const allWorkSessions: any[] = [];
      for (const project of projects) {
        const projectSessions = await storage.getWorkSessionsByProject(project.id, companyId);
        allWorkSessions.push(...projectSessions);
      }
      
      // Build meeting coverage map: for each project, store meeting dates
      const projectMeetingDates: Map<string, Date[]> = new Map();
      const otherMeetingDates: Date[] = [];
      
      meetings.forEach((meeting: any) => {
        if (meeting.meetingDate) {
          const meetingDate = new Date(meeting.meetingDate);
          if (meeting.projectId === 'other') {
            otherMeetingDates.push(meetingDate);
          } else if (meeting.projectId) {
            if (!projectMeetingDates.has(meeting.projectId)) {
              projectMeetingDates.set(meeting.projectId, []);
            }
            projectMeetingDates.get(meeting.projectId)!.push(meetingDate);
          }
        }
      });
      
      // Helper function to check if a work date is covered by a meeting within the coverage window
      const isDateCovered = (projectId: string, workDateStr: string): boolean => {
        const workDate = new Date(workDateStr);
        
        // Check project-specific meetings
        const projectMeetings = projectMeetingDates.get(projectId) || [];
        for (const meetingDate of projectMeetings) {
          const daysDiff = Math.abs(Math.floor((workDate.getTime() - meetingDate.getTime()) / (1000 * 60 * 60 * 24)));
          // Meeting covers work if within 7 days in either direction
          if (daysDiff <= TOOLBOX_COVERAGE_DAYS) {
            return true;
          }
        }
        
        // Check "other" meetings (cover all projects)
        for (const meetingDate of otherMeetingDates) {
          const daysDiff = Math.abs(Math.floor((workDate.getTime() - meetingDate.getTime()) / (1000 * 60 * 60 * 24)));
          if (daysDiff <= TOOLBOX_COVERAGE_DAYS) {
            return true;
          }
        }
        
        return false;
      };
      
      // Calculate toolbox meeting compliance using coverage window
      const workSessionDays = new Set<string>();
      allWorkSessions.forEach((session: any) => {
        if (session.projectId && session.workDate) {
          workSessionDays.add(`${session.projectId}|${session.workDate}`);
        }
      });
      
      let toolboxDaysWithMeeting = 0;
      let toolboxTotalDays = 0;
      workSessionDays.forEach((dayKey) => {
        toolboxTotalDays++;
        const [projectId, workDate] = dayKey.split('|');
        if (isDateCovered(projectId, workDate)) {
          toolboxDaysWithMeeting++;
        }
      });
      
      // If no work sessions but have meetings, give full credit
      // If no work sessions and no meetings, also full credit (nothing to comply with)
      const toolboxMeetingRating = toolboxTotalDays > 0 
        ? Math.round((toolboxDaysWithMeeting / toolboxTotalDays) * 100) 
        : 100;
      // Percentage allocation removed - no penalty applied
      const toolboxPenalty = 0;
      
      // 3. Harness Inspection Points (NEW SCR SYSTEM)
      // Formula: 1 point per project = (Completed Inspections / Total Work Sessions) per project
      const harnessInspections = await storage.getHarnessInspectionsByCompany(companyId);
      
      // Helper function to normalize date to YYYY-MM-DD string format
      const normalizeDateToString = (date: any): string => {
        if (!date) return '';
        if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
          return date;
        }
        const d = new Date(date);
        if (isNaN(d.getTime())) return '';
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
      };
      
      // Calculate harness inspection points per project
      let harnessInspectionPoints = 0;
      let harnessRequiredInspections = 0;
      let harnessCompletedInspections = 0;
      const harnessProjectBreakdown: { projectId: string; projectName: string; workSessions: number; inspections: number; points: number }[] = [];
      
      for (const project of projects) {
        if (project.status === 'deleted') continue;
        
        // Get work sessions for this project
        const projectSessions = allWorkSessions.filter((s: any) => s.projectId === project.id);
        const totalWorkSessionsForProject = projectSessions.length;
        
        if (totalWorkSessionsForProject === 0) {
          // No work sessions = no points required for this project
          continue;
        }
        
        // Count unique worker-date combinations that have harness inspections
        // Each work session requires a harness inspection for that worker on that date
        let completedInspectionsForProject = 0;
        
        for (const session of projectSessions) {
          if (!session.employeeId || !session.workDate) continue;
          
          const dateStr = normalizeDateToString(session.workDate);
          const hasInspection = harnessInspections.some((insp: any) =>
            insp.workerId === session.employeeId && 
            normalizeDateToString(insp.inspectionDate) === dateStr &&
            insp.overallStatus !== "not_applicable"
          );
          
          if (hasInspection) {
            completedInspectionsForProject++;
          }
        }
        
        harnessRequiredInspections += totalWorkSessionsForProject;
        harnessCompletedInspections += completedInspectionsForProject;
        
        // Calculate points for this project (0 to 1)
        const projectPoints = totalWorkSessionsForProject > 0 
          ? completedInspectionsForProject / totalWorkSessionsForProject 
          : 0;
        
        harnessInspectionPoints += projectPoints;
        
        harnessProjectBreakdown.push({
          projectId: project.id,
          projectName: project.name,
          workSessions: totalWorkSessionsForProject,
          inspections: completedInspectionsForProject,
          points: Math.round(projectPoints * 100) / 100
        });
      }
      
      // Round to 2 decimal places
      harnessInspectionPoints = Math.round(harnessInspectionPoints * 100) / 100;
      
      // Legacy rating for backward compatibility (percentage)
      const harnessInspectionRating = harnessRequiredInspections > 0 
        ? Math.round((harnessCompletedInspections / harnessRequiredInspections) * 100) 
        : 100;
      const harnessPenalty = 0;
      
      // 4. Employee Document Review Points (NEW SCR SYSTEM)
      // Formula: 1 point per employee who signed all available company documents
      // Points per employee = (Documents Signed by Employee / Documents Uploaded by Company)
      const documentReviews = await storage.getDocumentReviewSignaturesByCompany(companyId);
      const companyEmployees = await storage.getAllEmployees(companyId);
      
      // Include company owner in the count
      const companyOwnerForCSR = await storage.getUserById(companyId);
      const totalStaffCount = companyOwnerForCSR ? companyEmployees.length + 1 : companyEmployees.length;
      
      // Document types that require signing
      const requiredDocTypes = ['health_safety_manual', 'company_policy', 'safe_work_procedure', 'safe_work_practice'];
      const now = new Date();
      
      // Filter documents: only include docs where grace period has expired (graceEndsAt <= now) or legacy docs (no graceEndsAt)
      // Documents within grace period are NOT counted in the denominator per SCR.RATING.md
      const requiredDocs = companyDocuments.filter((doc: any) => {
        if (!requiredDocTypes.includes(doc.documentType)) {
          return false;
        }
        // If no graceEndsAt, it's a legacy document - include it
        if (!doc.graceEndsAt) {
          return true;
        }
        // If grace period has expired (graceEndsAt is in the past), include it
        const graceEnd = new Date(doc.graceEndsAt);
        return graceEnd <= now;
      });
      
      const totalEmployees = totalStaffCount;
      const totalRequiredDocs = requiredDocs.length;
      const totalRequiredSignatures = totalEmployees * totalRequiredDocs;
      
      // Calculate points per employee (1 point per employee with all docs signed)
      let employeeDocReviewPoints = 0;
      const allStaffIds = companyOwnerForCSR 
        ? [companyOwnerForCSR.id, ...companyEmployees.map((e: any) => e.id)]
        : companyEmployees.map((e: any) => e.id);
      
      for (const staffId of allStaffIds) {
        if (totalRequiredDocs === 0) {
          // No docs to sign = full credit for this employee
          employeeDocReviewPoints += 1;
          continue;
        }
        
        const signedByEmployee = documentReviews.filter((r: any) => 
          r.employeeId === staffId && r.signedAt
        ).length;
        
        // Points for this employee = docs signed / total docs available
        const employeePoints = signedByEmployee / totalRequiredDocs;
        employeeDocReviewPoints += employeePoints;
      }
      
      // Round to 2 decimal places
      employeeDocReviewPoints = Math.round(employeeDocReviewPoints * 100) / 100;
      
      // Legacy values for backward compatibility
      const signedReviews = documentReviews.filter((r: any) => r.signedAt).length;
      const pendingReviews = totalRequiredSignatures - signedReviews;
      const documentReviewRating = totalRequiredSignatures > 0 
        ? Math.round((signedReviews / totalRequiredSignatures) * 100) 
        : 100;
      const documentReviewPenalty = 0;
      
      // 5. Quiz Completion Points (NEW)
      // Formula: 1 point per quiz per employee who passed
      // Points per employee per quiz = 1 if passed, 0 if not
      const companyQuizzes = await storage.getQuizzesByCompanyId(companyId);
      const allQuizAttempts = await storage.getAllQuizAttemptsByCompanyId(companyId);
      
      let quizCompletionPoints = 0;
      const totalQuizzes = companyQuizzes.length;
      const totalQuizRequirements = totalQuizzes * totalEmployees; // Each employee should pass each quiz
      
      // Track which employees have passed which quizzes
      const passedQuizzes: Map<string, Set<string>> = new Map(); // employeeId -> Set of quizId
      
      for (const attempt of allQuizAttempts) {
        if (attempt.passed && attempt.employeeId && attempt.quizId) {
          if (!passedQuizzes.has(attempt.employeeId)) {
            passedQuizzes.set(attempt.employeeId, new Set());
          }
          passedQuizzes.get(attempt.employeeId)!.add(attempt.quizId);
        }
      }
      
      // Calculate points: 1 point per employee per quiz passed
      for (const staffId of allStaffIds) {
        const passedByEmployee = passedQuizzes.get(staffId);
        if (passedByEmployee) {
          // Count how many of the company's quizzes this employee has passed
          for (const quiz of companyQuizzes) {
            if (passedByEmployee.has(quiz.id)) {
              quizCompletionPoints += 1;
            }
          }
        }
      }
      
      // If no quizzes exist, give full credit (nothing to comply with)
      // Otherwise calculate based on passed/total
      const quizCompletionRating = totalQuizRequirements > 0 
        ? Math.round((quizCompletionPoints / totalQuizRequirements) * 100) 
        : 100;
      
      // Round to 2 decimal places
      quizCompletionPoints = Math.round(quizCompletionPoints * 100) / 100;
      
      // 6. Project Documentation Points (NEW SCR SYSTEM)
      // Formula: 1 point per project with all required docs
      // Elevation projects: 4 docs (Rope Access Plan, Anchor Inspection, Toolbox Meeting, FLHA)
      // Non-elevation projects: 2 docs (Toolbox Meeting, FLHA)
      const flhaForms = await storage.getFlhaFormsByCompany(companyId);
      const toolboxMeetings = meetings; // Already fetched above
      
      let projectDocumentationPoints = 0;
      let projectsWithAnchorInspection = 0;
      let projectsWithRopeAccessPlan = 0;
      let projectsWithFLHA = 0;
      let projectsWithToolboxMeeting = 0;
      let activeProjectCount = 0;
      let elevationProjectCount = 0;
      const projectDocBreakdown: { projectId: string; projectName: string; isElevation: boolean; docsRequired: number; docsPresent: number; points: number }[] = [];
      
      for (const project of projects) {
        if (project.status === 'deleted') continue;
        
        activeProjectCount++;
        const requiresElevation = project.requiresElevation === true;
        if (requiresElevation) {
          elevationProjectCount++;
        }
        
        // Count docs for this project
        let docsPresent = 0;
        const docsRequired = requiresElevation ? 4 : 2;
        
        // FLHA check
        const hasFlha = flhaForms.some((f: any) => f.projectId === project.id);
        if (hasFlha) {
          docsPresent++;
          projectsWithFLHA++;
        }
        
        // Toolbox Meeting check (for this project)
        const hasToolbox = toolboxMeetings.some((m: any) => m.projectId === project.id);
        if (hasToolbox) {
          docsPresent++;
          projectsWithToolboxMeeting++;
        }
        
        // Elevation-only requirements
        if (requiresElevation) {
          if (project.anchorInspectionCertificateUrl) {
            docsPresent++;
            projectsWithAnchorInspection++;
          }
          if (project.ropeAccessPlanUrl) {
            docsPresent++;
            projectsWithRopeAccessPlan++;
          }
        }
        
        // Calculate points for this project (proportional: docsPresent / docsRequired)
        const projectPoints = docsRequired > 0 ? docsPresent / docsRequired : 0;
        projectDocumentationPoints += projectPoints;
        
        projectDocBreakdown.push({
          projectId: project.id,
          projectName: project.name,
          isElevation: requiresElevation,
          docsRequired,
          docsPresent,
          points: Math.round(projectPoints * 100) / 100
        });
      }
      
      // Round to 2 decimal places
      projectDocumentationPoints = Math.round(projectDocumentationPoints * 100) / 100;
      
      // Legacy rating for backward compatibility
      const totalProjectDocsRequired = (elevationProjectCount * 4) + ((activeProjectCount - elevationProjectCount) * 2);
      const totalProjectDocsPresent = projectsWithAnchorInspection + projectsWithRopeAccessPlan + projectsWithFLHA + projectsWithToolboxMeeting;
      const projectDocumentationRating = totalProjectDocsRequired > 0
        ? Math.round((totalProjectDocsPresent / totalProjectDocsRequired) * 100)
        : 100;
      const projectDocumentationPenalty = 0;
      
      // Calculate overall CSR: Sum of all points
      // Categories: 
      // 1. Harness Inspection Points (per project)
      // 2. Project Documentation Points (per project)
      // 3. Company Documentation Points (1 max)
      // 4. Employee Document Review Points (per employee)
      // 5. Quiz Completion Points (per employee per quiz)
      const totalEarned = Math.round((
        harnessInspectionPoints + 
        projectDocumentationPoints + 
        companyDocumentationPoints + 
        employeeDocReviewPoints +
        quizCompletionPoints
      ) * 100) / 100;
      
      // Calculate maximum possible points for percentage-based rating
      // Max is derived from the SAME project/employee sets used for earned calculations
      // This ensures earned can never exceed max and percentage is always 0-100%
      // - Harness Inspections: 1 point per project that has work sessions (only those earn points)
      // - Project Documentation: 1 point per project in projectDocBreakdown (same set as earned)
      // - Company Documentation: 1 point (all 3 docs uploaded)
      // - Employee Document Review: 1 point per employee (same count as earned calculation)
      // - Quiz Completion: 1 point per quiz per employee (totalQuizzes * totalEmployees)
      const maxHarnessPoints = harnessProjectBreakdown.filter((p: any) => p.workSessions > 0).length;
      const maxProjectDocPoints = projectDocBreakdown.length; // Same projects used for earned calculation
      const maxCompanyDocPoints = 1; // Always 1 (3 docs required)
      const maxEmployeeDocPoints = totalEmployees;
      const maxQuizPoints = totalQuizRequirements; // totalQuizzes * totalEmployees
      
      const totalMax = maxHarnessPoints + maxProjectDocPoints + maxCompanyDocPoints + maxEmployeeDocPoints + maxQuizPoints;
      
      // Calculate percentage rating (avoid division by zero)
      const csrRating = totalMax > 0 ? Math.round((totalEarned / totalMax) * 100) : 100;
      const { label: csrLabel, color: csrColor } = getCsrRatingInfo(csrRating);
      
      // Legacy overallCSR for backward compatibility (raw points)
      const overallCSR = totalEarned;
      
      const response = {
        // NEW: Percentage-based rating (primary display)
        csrRating,
        csrLabel,
        csrColor,
        // Legacy: Raw point total for backward compatibility
        overallCSR,
        breakdown: {
          harnessInspection: { earned: harnessInspectionPoints, max: maxHarnessPoints },
          projectDocumentation: { earned: projectDocumentationPoints, max: maxProjectDocPoints },
          companyDocumentation: { earned: companyDocumentationPoints, max: maxCompanyDocPoints },
          employeeDocumentReview: { earned: employeeDocReviewPoints, max: maxEmployeeDocPoints },
          quizCompletion: { earned: quizCompletionPoints, max: maxQuizPoints },
          // Legacy points for backward compatibility
          harnessInspectionPoints,
          projectDocumentationPoints,
          companyDocumentationPoints,
          employeeDocReviewPoints,
          quizCompletionPoints,
          // Legacy ratings (percentages) for backward compatibility
          documentationRating,
          toolboxMeetingRating,
          harnessInspectionRating,
          documentReviewRating,
          projectDocumentationRating,
          quizCompletionRating
        },
        totalEarned,
        totalMax,
        details: {
          hasHealthSafety,
          hasCompanyPolicy,
          hasInsurance,
          companyDocsUploaded,
          toolboxDaysWithMeeting,
          toolboxTotalDays,
          harnessCompletedInspections,
          harnessRequiredInspections,
          harnessProjectBreakdown,
          documentReviewsSigned: signedReviews,
          documentReviewsPending: pendingReviews,
          documentReviewsTotal: totalRequiredSignatures,
          documentReviewsTotalEmployees: totalEmployees,
          documentReviewsTotalDocs: totalRequiredDocs,
          projectsWithAnchorInspection,
          projectsWithRopeAccessPlan,
          projectsWithFLHA,
          projectsWithToolboxMeeting,
          activeProjectCount,
          elevationProjectCount,
          projectDocBreakdown,
          quizCompletionsPassed: quizCompletionPoints,
          quizCompletionsRequired: totalQuizRequirements,
          totalQuizzes,
          totalEmployeesForQuizzes: totalEmployees
        }
      };
      
      // Record CSR history if percentage rating has changed
      const lastHistory = await storage.getLatestCsrRatingHistory(companyId);
      if (!lastHistory || lastHistory.newScore !== csrRating) {
        const previousScore = lastHistory ? lastHistory.newScore : 100;
        const delta = csrRating - previousScore;
        
        if (!lastHistory) {
          // Create detailed initial entry with percentage and breakdown
          const breakdownDetails: string[] = [];
          
          // Company Documentation (earned/max)
          const companyDocsCount = (hasHealthSafety ? 1 : 0) + (hasCompanyPolicy ? 1 : 0) + (hasInsurance ? 1 : 0);
          breakdownDetails.push(`Company Documents: ${companyDocumentationPoints.toFixed(2)} / ${maxCompanyDocPoints} (${companyDocsCount}/3 uploaded)`);
          
          // Harness Inspections (earned/max)
          breakdownDetails.push(`Harness Inspections: ${harnessInspectionPoints.toFixed(2)} / ${maxHarnessPoints} (${harnessCompletedInspections} of ${harnessRequiredInspections} completed)`);
          
          // Employee Document Reviews (earned/max)
          breakdownDetails.push(`Document Reviews: ${employeeDocReviewPoints.toFixed(2)} / ${maxEmployeeDocPoints} (${signedReviews}/${totalRequiredSignatures} signatures)`);
          
          // Project Documentation (earned/max)
          breakdownDetails.push(`Project Docs: ${projectDocumentationPoints.toFixed(2)} / ${maxProjectDocPoints}`);
          
          // Quiz Completion (earned/max)
          if (totalQuizzes > 0) {
            breakdownDetails.push(`Quiz Completion: ${quizCompletionPoints.toFixed(2)} / ${maxQuizPoints} (${quizCompletionPoints}/${totalQuizRequirements} passed)`);
          }
          
          const fullReason = `Initial safety rating recorded: ${csrRating}% (${csrLabel})\n\nBreakdown (earned/max):\n${breakdownDetails.join('\n')}\n\nTotal: ${totalEarned.toFixed(2)} / ${totalMax}`;
          
          await storage.createCsrRatingHistory({
            companyId,
            previousScore,
            newScore: csrRating,
            delta,
            category: 'initial',
            reason: fullReason
          });
        } else {
          // Record changes with percentage-based reasons
          const changes: string[] = [];
          
          // Company Documentation (earned/max)
          const companyDocsCount = (hasHealthSafety ? 1 : 0) + (hasCompanyPolicy ? 1 : 0) + (hasInsurance ? 1 : 0);
          changes.push(`Company Documents: ${companyDocumentationPoints.toFixed(2)} / ${maxCompanyDocPoints} (${companyDocsCount}/3 uploaded)`);
          
          // Harness Inspections (earned/max)
          changes.push(`Harness Inspections: ${harnessInspectionPoints.toFixed(2)} / ${maxHarnessPoints} (${harnessCompletedInspections} of ${harnessRequiredInspections} completed)`);
          
          // Employee Document Reviews (earned/max)
          changes.push(`Document Reviews: ${employeeDocReviewPoints.toFixed(2)} / ${maxEmployeeDocPoints} (${signedReviews}/${totalRequiredSignatures} signatures)`);
          
          // Project Documentation (earned/max)
          changes.push(`Project Docs: ${projectDocumentationPoints.toFixed(2)} / ${maxProjectDocPoints}`);
          
          // Quiz Completion (earned/max)
          if (totalQuizzes > 0) {
            changes.push(`Quiz Completion: ${quizCompletionPoints.toFixed(2)} / ${maxQuizPoints} (${quizCompletionPoints}/${totalQuizRequirements} passed)`);
          }
          
          const category = delta > 0 ? 'improvement' : delta < 0 ? 'decline' : 'update';
          const changeType = delta > 0 ? 'improved' : delta < 0 ? 'declined' : 'updated';
          const { label: prevLabel } = getCsrRatingInfo(previousScore);
          const reason = `Safety rating ${changeType} from ${previousScore}% (${prevLabel}) to ${csrRating}% (${csrLabel}).\n\nCurrent Status (earned/max):\n${changes.join('\n')}\n\nTotal: ${totalEarned.toFixed(2)} / ${totalMax}`;
          
          await storage.createCsrRatingHistory({
            companyId,
            previousScore,
            newScore: csrRating,
            delta,
            category,
            reason
          });
        }
      }
      
      res.json(response);
    } catch (error) {
      console.error("Get company safety rating error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // CSR Rating History endpoint
  // Returns percentage-based history with label and color for each entry
  app.get("/api/company-safety-rating/history", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!canViewCSR(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view CSR history" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const history = await storage.getCsrRatingHistoryByCompany(companyId);
      
      // Enhance each history entry with label and color based on newScore (percentage)
      const enhancedHistory = history.map((entry: any) => {
        const { label, color } = getCsrRatingInfo(entry.newScore);
        return {
          ...entry,
          // newScore is now a percentage (0-100)
          csrLabel: label,
          csrColor: color
        };
      });
      
      res.json({ history: enhancedHistory });
    } catch (error) {
      console.error("Get CSR history error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Workforce Safety Score (WSS) - Average of all employee PSRs
  // Educational metric only - does not affect CSR
  app.get("/api/workforce-safety-score", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only employers can view WSS
      if (!canViewCSR(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Only employers can view WSS" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get all active employees for this company
      const employees = await storage.getAllEmployees(companyId);
      const activeEmployees = employees.filter((e: any) => !e.isSuspended && !e.terminationDate);
      
      if (activeEmployees.length === 0) {
        return res.json({
          wssScore: 0,
          wssLabel: "No Employees",
          employeeCount: 0,
          description: "Add employees to calculate Workforce Safety Score",
        });
      }
      
      // Calculate PSR for each employee
      const today = new Date();
      const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
      const totalSafetyQuizTypes = 6;
      
      let totalPSR = 0;
      let employeesWithPSR = 0;
      
      for (const employee of activeEmployees) {
        // 1. Certification Score (25%)
        let certScore = 0;
        if (employee.irataLevel || employee.spratLevel) {
          const expirationDate = employee.irataLevel 
            ? (employee.irataExpirationDate ? new Date(employee.irataExpirationDate) : null)
            : (employee.spratExpirationDate ? new Date(employee.spratExpirationDate) : null);
          const verified = employee.irataLevel 
            ? !!employee.irataVerifiedAt 
            : !!employee.spratVerifiedAt;
          
          if (expirationDate && expirationDate > today) {
            certScore = verified ? 100 : 75;
          } else if (expirationDate && expirationDate <= today) {
            certScore = 25;
          } else {
            certScore = 50;
          }
        }
        
        // 2. Safety Documents Score (25%) - Personal harness inspections
        let docsScore = 0;
        const personalInspections = await storage.getPersonalHarnessInspections(employee.id);
        const recentInspections = personalInspections.filter((insp: any) => 
          new Date(insp.inspectionDate) >= thirtyDaysAgo
        );
        const passedInspections = recentInspections.filter((insp: any) => insp.overallStatus === "pass");
        if (recentInspections.length > 0) {
          docsScore = Math.round((passedInspections.length / recentInspections.length) * 100);
        }
        
        // 3. Safety Quizzes Score (25%)
        let quizScore = 0;
        const allAttempts = await storage.getAllQuizAttemptsByEmployee(employee.id);
        const safetyQuizAttempts = allAttempts.filter((a: any) => 
          a.quizId?.startsWith("safety_") || a.quizId?.startsWith("cert_")
        );
        const passedQuizzes = new Set(
          safetyQuizAttempts.filter((a: any) => a.passed).map((a: any) => a.quizId)
        );
        quizScore = Math.round((passedQuizzes.size / totalSafetyQuizTypes) * 100);
        
        // 4. Work History Score (25%)
        let workScore = 50; // Default for new employees
        const workSessionsList = await db.select()
          .from(workSessions)
          .where(eq(workSessions.employeeId, employee.id));
        const completedSessions = workSessionsList.filter((ws: any) => ws.endTime);
        
        const incidentReportsList = await db.select()
          .from(incidentReports)
          .where(eq(incidentReports.companyId, companyId));
        const technicianIncidents = incidentReportsList.filter((ir: any) => 
          ir.reportedById === employee.id || 
          (ir.witnesses && Array.isArray(ir.witnesses) && ir.witnesses.includes(employee.id))
        );
        
        if (completedSessions.length > 0) {
          const incidentPenalty = Math.min(technicianIncidents.length * 10, 50);
          workScore = Math.max(100 - incidentPenalty, 50);
        }
        
        // Calculate employee PSR (25% each component)
        const employeePSR = Math.round(
          (certScore * 0.25) + 
          (docsScore * 0.25) + 
          (quizScore * 0.25) + 
          (workScore * 0.25)
        );
        
        totalPSR += employeePSR;
        employeesWithPSR++;
      }
      
      // Calculate average WSS
      const wssScore = employeesWithPSR > 0 ? Math.round(totalPSR / employeesWithPSR) : 0;
      
      // Determine label
      let wssLabel = "Critical";
      if (wssScore >= 90) wssLabel = "Excellent";
      else if (wssScore >= 70) wssLabel = "Good";
      else if (wssScore >= 50) wssLabel = "Fair";
      
      res.json({
        wssScore,
        wssLabel,
        employeeCount: employeesWithPSR,
        description: "Average of all employee Personal Safety Ratings (PSR). Educational metric only - does not affect CSR.",
      });
    } catch (error) {
      console.error("Get WSS error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Workforce Safety Score Details - Individual employee PSR breakdown
  app.get("/api/workforce-safety-score/details", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      if (!canViewCSR(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Only employers can view WSS details" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const employees = await storage.getAllEmployees(companyId);
      const activeEmployees = employees.filter((e: any) => !e.isSuspended && !e.terminationDate);
      
      const today = new Date();
      const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
      const totalSafetyQuizTypes = 6;
      
      const employeePSRDetails = [];
      
      for (const employee of activeEmployees) {
        // 1. Certification Score (25%)
        let certScore = 0;
        let certStatus = "none";
        if (employee.irataLevel || employee.spratLevel) {
          const expirationDate = employee.irataLevel 
            ? (employee.irataExpirationDate ? new Date(employee.irataExpirationDate) : null)
            : (employee.spratExpirationDate ? new Date(employee.spratExpirationDate) : null);
          const verified = employee.irataLevel 
            ? !!employee.irataVerifiedAt 
            : !!employee.spratVerifiedAt;
          
          if (expirationDate && expirationDate > today) {
            certScore = verified ? 100 : 75;
            certStatus = verified ? "verified" : "unverified";
          } else if (expirationDate && expirationDate <= today) {
            certScore = 25;
            certStatus = "expired";
          } else {
            certScore = 50;
            certStatus = "no_expiry";
          }
        }
        
        // 2. Safety Documents Score (25%)
        let docsScore = 0;
        const personalInspections = await storage.getPersonalHarnessInspections(employee.id);
        const recentInspections = personalInspections.filter((insp: any) => 
          new Date(insp.inspectionDate) >= thirtyDaysAgo
        );
        const passedInspections = recentInspections.filter((insp: any) => insp.overallStatus === "pass");
        if (recentInspections.length > 0) {
          docsScore = Math.round((passedInspections.length / recentInspections.length) * 100);
        }
        
        // 3. Safety Quizzes Score (25%)
        let quizScore = 0;
        const allAttempts = await storage.getAllQuizAttemptsByEmployee(employee.id);
        const safetyQuizAttempts = allAttempts.filter((a: any) => 
          a.quizId?.startsWith("safety_") || a.quizId?.startsWith("cert_")
        );
        const passedQuizzes = new Set(
          safetyQuizAttempts.filter((a: any) => a.passed).map((a: any) => a.quizId)
        );
        quizScore = Math.round((passedQuizzes.size / totalSafetyQuizTypes) * 100);
        
        // 4. Work History Score (25%)
        let workScore = 50;
        const workSessionsList = await db.select()
          .from(workSessions)
          .where(eq(workSessions.employeeId, employee.id));
        const completedSessions = workSessionsList.filter((ws: any) => ws.endTime);
        
        const incidentReportsList = await db.select()
          .from(incidentReports)
          .where(eq(incidentReports.companyId, companyId));
        const technicianIncidents = incidentReportsList.filter((ir: any) => 
          ir.reportedById === employee.id || 
          (ir.witnesses && Array.isArray(ir.witnesses) && ir.witnesses.includes(employee.id))
        );
        
        if (completedSessions.length > 0) {
          const incidentPenalty = Math.min(technicianIncidents.length * 10, 50);
          workScore = Math.max(100 - incidentPenalty, 50);
        }
        
        // Calculate employee PSR
        const overallPSR = Math.round(
          (certScore * 0.25) + 
          (docsScore * 0.25) + 
          (quizScore * 0.25) + 
          (workScore * 0.25)
        );
        
        employeePSRDetails.push({
          id: employee.id,
          name: employee.name,
          role: employee.employeeRole || employee.role,
          overallPSR,
          components: {
            certifications: { score: certScore, status: certStatus },
            safetyDocs: { score: docsScore, recentInspections: recentInspections.length },
            quizzes: { score: quizScore, passed: passedQuizzes.size, total: totalSafetyQuizTypes },
            workHistory: { score: workScore, sessions: completedSessions.length, incidents: technicianIncidents.length },
          },
        });
      }
      
      // Sort by PSR score descending
      employeePSRDetails.sort((a, b) => b.overallPSR - a.overallPSR);
      
      res.json({ employees: employeePSRDetails });
    } catch (error) {
      console.error("Get WSS details error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get CSR for a linked vendor company
  // SIMPLIFIED: Uses the same calculation as company CSR endpoint to ensure consistency
  app.get("/api/property-managers/vendors/:linkId/csr", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      const companyId = ownedLink.companyId;
      
      // Use the shared CSR calculation function (skip history recording for PM views)
      const csrData = await calculateCompanyCSR(companyId, storage, true);
      res.json(csrData);
    } catch (error) {
      console.error("Get vendor CSR error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Property Manager: Get CSR history for a linked vendor company
  app.get("/api/property-managers/vendors/:linkId/csr/history", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      const companyId = ownedLink.companyId;
      
      // Get CSR history from storage
      const history = await storage.getCsrRatingHistoryByCompany(companyId);
      
      res.json({ history });
    } catch (error) {
      console.error("Get vendor CSR history error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Property Manager: Get vendor company documents (for viewing Certificate of Insurance, etc.)
  app.get("/api/property-managers/vendors/:linkId/documents", requireAuth, requireRole("property_manager"), async (req: Request, res: Response) => {
    try {
      const { linkId } = req.params;
      const { documentType } = req.query;
      const propertyManagerId = req.session.userId!;
      
      // Verify the link belongs to this property manager
      const links = await storage.getPropertyManagerCompanyLinks(propertyManagerId);
      const ownedLink = links.find(link => link.id === linkId);
      
      if (!ownedLink) {
        return res.status(403).json({ message: "Unauthorized: This vendor link does not belong to you" });
      }
      
      const companyId = ownedLink.companyId;
      
      // Get company documents - filter by type if specified
      let documents;
      if (documentType && typeof documentType === 'string') {
        documents = await storage.getCompanyDocumentsByType(companyId, documentType);
      } else {
        documents = await storage.getCompanyDocuments(companyId);
      }
      
      // Property managers can only see certain document types
      const allowedTypes = ['certificate_of_insurance', 'health_safety_manual', 'company_policy'];
      const filteredDocuments = documents.filter((doc: any) => allowedTypes.includes(doc.documentType));
      
      res.json({ documents: filteredDocuments });
    } catch (error) {
      console.error("Get vendor documents error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // FLHA form routes
  app.post("/api/flha-forms", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const flhaData = insertFlhaFormSchema.parse({
        ...req.body,
        companyId,
      });
      
      const flha = await storage.createFlhaForm(flhaData);
      res.json({ flha });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create FLHA form error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/flha-forms", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if user has permission to view safety documents
      if (!canViewSafetyDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - You don't have permission to view FLHA records" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const flhaForms = await storage.getFlhaFormsByCompany(companyId);
      
      // Add project names to FLHA forms (using buildingName which is the display name for projects)
      const projects = await storage.getProjectsByCompany(companyId);
      const projectMap = new Map(projects.map(p => [p.id, p.buildingName]));
      
      const flhaFormsWithProjectNames = flhaForms.map(flha => ({
        ...flha,
        projectName: projectMap.get(flha.projectId) || null,
      }));
      
      res.json({ flhaForms: flhaFormsWithProjectNames });
    } catch (error) {
      console.error("Get FLHA forms error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/projects/:projectId/flha-forms", requireAuth, async (req: Request, res: Response) => {
    try {
      const flhaForms = await storage.getFlhaFormsByProject(req.params.projectId);
      res.json({ flhaForms });
    } catch (error) {
      console.error("Get project FLHA forms error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/flha-forms/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await storage.deleteFlhaForm(id);
      res.json({ message: "FLHA form deleted successfully" });
    } catch (error) {
      console.error("Delete FLHA form error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Incident report routes
  app.post("/api/incident-reports", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const reportData = insertIncidentReportSchema.parse({
        ...req.body,
        companyId,
        reportedById: req.session.userId,
      });
      
      const report = await storage.createIncidentReport(reportData);
      res.json({ report });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create incident report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/incident-reports", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if user has permission to view sensitive documents
      if (!canViewSensitiveDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view sensitive documents" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const reports = await storage.getIncidentReportsByCompany(companyId);
      res.json({ reports });
    } catch (error) {
      console.error("Get incident reports error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/incident-reports/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check sensitive documents permission
      if (!canViewSensitiveDocuments(currentUser)) {
        return res.status(403).json({ message: "Forbidden - Insufficient permissions to view sensitive documents" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { id } = req.params;
      const report = await storage.getIncidentReportById(id);
      
      if (!report) {
        return res.status(404).json({ message: "Incident report not found" });
      }
      
      // Verify the incident report belongs to this company
      if (report.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      res.json({ report });
    } catch (error) {
      console.error("Get incident report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/incident-reports/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the incident report belongs to this company
      const existingReport = await storage.getIncidentReportById(id);
      if (!existingReport) {
        return res.status(404).json({ message: "Incident report not found" });
      }
      
      if (existingReport.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Merge server-derived companyId to prevent tampering
      const payload = { ...req.body, companyId };
      const report = await storage.updateIncidentReport(id, payload);
      res.json({ report });
    } catch (error) {
      console.error("Update incident report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/incident-reports/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the incident report belongs to this company
      const existingReport = await storage.getIncidentReportById(id);
      if (!existingReport) {
        return res.status(404).json({ message: "Incident report not found" });
      }
      
      if (existingReport.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteIncidentReport(id);
      res.json({ message: "Incident report deleted successfully" });
    } catch (error) {
      console.error("Delete incident report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== METHOD STATEMENT ROUTES ====================

  // Create method statement
  app.post("/api/method-statements", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Sanitize empty strings to null for optional fields (especially dates)
      const sanitizedBody = { ...req.body };
      const optionalFields = ['reviewDate', 'approvalDate', 'projectId', 'location', 'workDuration', 'rescuePlan', 'emergencyContacts', 'weatherRestrictions', 'workingHeightRange', 'accessMethod', 'irataLevelRequired', 'communicationMethod', 'signalProtocol', 'reviewedByName', 'approvedByName'];
      for (const field of optionalFields) {
        if (sanitizedBody[field] === '' || sanitizedBody[field] === 'none') {
          sanitizedBody[field] = null;
        }
      }
      
      const statementData = insertMethodStatementSchema.parse({
        ...sanitizedBody,
        companyId,
        preparedById: req.session.userId,
      });
      
      const statement = await storage.createMethodStatement(statementData);
      res.json({ statement });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create method statement error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all method statements for company
  app.get("/api/method-statements", requireAuth, requireRole("rope_access_tech", "operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const statements = await storage.getMethodStatementsByCompany(companyId);
      res.json({ statements });
    } catch (error) {
      console.error("Get method statements error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get method statements for specific project
  app.get("/api/projects/:projectId/method-statements", requireAuth, async (req: Request, res: Response) => {
    try {
      const statements = await storage.getMethodStatementsByProject(req.params.projectId);
      res.json({ statements });
    } catch (error) {
      console.error("Get project method statements error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get specific method statement
  app.get("/api/method-statements/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const statement = await storage.getMethodStatementById(req.params.id);
      if (!statement) {
        return res.status(404).json({ message: "Method statement not found" });
      }
      res.json({ statement });
    } catch (error) {
      console.error("Get method statement error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update method statement
  app.patch("/api/method-statements/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the method statement belongs to this company
      const existingStatement = await storage.getMethodStatementById(id);
      if (!existingStatement) {
        return res.status(404).json({ message: "Method statement not found" });
      }
      
      if (existingStatement.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Merge server-derived companyId to prevent tampering
      const payload = { ...req.body, companyId };
      const statement = await storage.updateMethodStatement(id, payload);
      res.json({ statement });
    } catch (error) {
      console.error("Update method statement error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete method statement
  app.delete("/api/method-statements/:id", requireAuth, requireRole("operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the method statement belongs to this company
      const existingStatement = await storage.getMethodStatementById(id);
      if (!existingStatement) {
        return res.status(404).json({ message: "Method statement not found" });
      }
      
      if (existingStatement.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteMethodStatement(id);
      res.json({ message: "Method statement deleted successfully" });
    } catch (error) {
      console.error("Delete method statement error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== DOCUMENT REVIEW SIGNATURES ROUTES ====================

  // Get current employee's document review requirements (pending and signed)
  app.get("/api/document-reviews/my", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the company ID
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (companyId) {
        // Auto-enroll: Check for required documents that the employee hasn't been enrolled for yet
        const requiredDocTypes = ['health_safety_manual', 'company_policy', 'safe_work_procedure', 'safe_work_practice'];
        const existingReviews = await storage.getDocumentReviewSignaturesByEmployee(currentUser.id);
        const existingDocIds = new Set(existingReviews.map(r => r.documentId).filter(Boolean));
        
        // Get all required company documents
        for (const docType of requiredDocTypes) {
          const docs = await storage.getCompanyDocumentsByType(companyId, docType);
          for (const doc of docs) {
            // Check if document targets this user's role (skip if not)
            const targetRoles = (doc.targetRoles as string[] | null) || ['rope_access_tech', 'ground_crew'];
            if (!targetRoles.includes(currentUser.role)) {
              continue; // Skip documents not targeting this user's role
            }
            
            // If employee doesn't have a review for this document, create one
            if (!existingDocIds.has(doc.id)) {
              try {
                await storage.enrollEmployeeInDocumentReviews(companyId, currentUser.id, [{
                  type: docType,
                  id: doc.id,
                  name: doc.fileName,
                  fileUrl: doc.fileUrl,
                  targetRoles: targetRoles, // Inherit targetRoles from the document
                }]);
              } catch (enrollErr) {
                // Ignore duplicate errors - another request may have created it
                console.log(`Auto-enroll skipped for ${doc.fileName}: ${enrollErr}`);
              }
            }
          }
        }
      }
      
      // Now fetch all reviews (including newly created ones)
      const allReviews = await storage.getDocumentReviewSignaturesByEmployee(currentUser.id);
      
      // Filter reviews to only include those targeting this user's role
      const reviews = allReviews.filter(r => {
        const targetRoles = (r.targetRoles as string[] | null) || ['rope_access_tech', 'ground_crew'];
        return targetRoles.includes(currentUser.role);
      });
      
      res.json({ reviews });
    } catch (error) {
      console.error("Get my document reviews error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Check if employee has pending required documents to sign (for dashboard gate)
  app.get("/api/document-reviews/pending-check", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only check for technicians and ground crew who are linked to a company
      if (!['rope_access_tech', 'ground_crew'].includes(currentUser.role) || !currentUser.companyId) {
        return res.json({ hasPendingDocuments: false, pendingCount: 0 });
      }
      
      const companyId = currentUser.companyId;
      
      // Auto-enroll: Check for required documents that the employee hasn't been enrolled for yet
      const requiredDocTypes = ['health_safety_manual', 'company_policy', 'safe_work_procedure', 'safe_work_practice'];
      const existingReviews = await storage.getDocumentReviewSignaturesByEmployee(currentUser.id);
      const existingDocIds = new Set(existingReviews.map(r => r.documentId).filter(Boolean));
      
      // Get all required company documents and auto-enroll if needed
      for (const docType of requiredDocTypes) {
        const docs = await storage.getCompanyDocumentsByType(companyId, docType);
        for (const doc of docs) {
          // Check if document targets this user's role (skip if not)
          const targetRoles = (doc.targetRoles as string[] | null) || ['rope_access_tech', 'ground_crew'];
          if (!targetRoles.includes(currentUser.role)) {
            continue; // Skip documents not targeting this user's role
          }
          
          // If employee doesn't have a review for this document, create one
          if (!existingDocIds.has(doc.id)) {
            try {
              await storage.enrollEmployeeInDocumentReviews(companyId, currentUser.id, [{
                type: docType,
                id: doc.id,
                name: doc.fileName,
                fileUrl: doc.fileUrl,
                targetRoles: targetRoles,
              }]);
            } catch (enrollErr) {
              // Ignore duplicate errors
              console.log(`Auto-enroll skipped for ${doc.fileName}: ${enrollErr}`);
            }
          }
        }
      }
      
      // Now get all reviews (including newly created ones)
      const allReviews = await storage.getDocumentReviewSignaturesByEmployee(currentUser.id);
      
      // Count pending (unsigned) documents that apply to this user's role
      const pendingReviews = allReviews.filter(r => {
        // Document is not signed yet
        if (r.signedAt) return false;
        
        // Check if document targets this user's role
        const targetRoles = r.targetRoles as string[] | null;
        if (!targetRoles || targetRoles.length === 0) {
          return true; // Legacy documents apply to everyone
        }
        
        return targetRoles.includes(currentUser.role);
      });
      
      res.json({ 
        hasPendingDocuments: pendingReviews.length > 0, 
        pendingCount: pendingReviews.length 
      });
    } catch (error) {
      console.error("Document review pending check error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all document review signatures for company (admin view)
  app.get("/api/document-reviews", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const reviews = await storage.getDocumentReviewSignaturesByCompany(companyId);
      res.json({ reviews });
    } catch (error) {
      console.error("Get company document reviews error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Enroll an employee in document reviews (creates pending review entries)
  app.post("/api/document-reviews/enroll/:employeeId", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const { employeeId } = req.params;
      const { documents } = req.body; // Array of { type, id?, name, version?, fileUrl? }
      
      // Validate documents array
      if (!Array.isArray(documents) || documents.length === 0) {
        return res.status(400).json({ message: "Documents array is required" });
      }
      
      const validDocTypes = ['health_safety_manual', 'company_policy', 'method_statement', 'safe_work_practice', 'safe_work_procedure'];
      for (const doc of documents) {
        if (!doc.type || !validDocTypes.includes(doc.type)) {
          return res.status(400).json({ message: `Invalid document type: ${doc.type}` });
        }
        if (!doc.name || typeof doc.name !== 'string') {
          return res.status(400).json({ message: "Document name is required" });
        }
      }
      
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Verify the employee belongs to this company
      const employee = await storage.getUserById(employeeId);
      if (!employee || employee.companyId !== companyId) {
        return res.status(403).json({ message: "Employee not found or access denied" });
      }
      
      // Resolve document references and validate fileUrls
      const resolvedDocuments: { type: string; id?: string; name: string; version?: string; fileUrl?: string }[] = [];
      
      for (const doc of documents) {
        let fileUrl = doc.fileUrl;
        
        // For health_safety_manual, company_policy, and safe_work_practice resolve from company documents
        if ((doc.type === 'health_safety_manual' || doc.type === 'company_policy' || doc.type === 'safe_work_practice') && !fileUrl) {
          const companyDocs = await storage.getCompanyDocumentsByType(companyId, doc.type);
          if (companyDocs.length > 0) {
            fileUrl = companyDocs[0].fileUrl;
          }
        }
        
        // For method_statement, resolve from method statements table
        if (doc.type === 'method_statement' && doc.id && !fileUrl) {
          const methodStatement = await storage.getMethodStatementById(doc.id);
          if (methodStatement && methodStatement.companyId === companyId) {
            // Method statements don't have file URLs since they're rendered in-app
            // But we can still validate the reference exists
            fileUrl = null; // Method statements are viewed in-app, not via file URL
          } else {
            return res.status(404).json({ message: `Method statement not found: ${doc.id}` });
          }
        }
        
        // Require fileUrl for health_safety_manual and company_policy
        if ((doc.type === 'health_safety_manual' || doc.type === 'company_policy') && !fileUrl) {
          return res.status(400).json({ message: `No ${doc.type.replace(/_/g, ' ')} document uploaded. Please upload the document first.` });
        }
        
        resolvedDocuments.push({
          type: doc.type,
          id: doc.id,
          name: doc.name,
          version: doc.version,
          fileUrl,
        });
      }
      
      const reviews = await storage.enrollEmployeeInDocumentReviews(companyId, employeeId, resolvedDocuments);
      res.json({ reviews });
    } catch (error) {
      console.error("Enroll employee in document reviews error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark document as viewed
  app.post("/api/document-reviews/:id/view", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the review record directly by ID
      const review = await storage.getDocumentReviewSignatureById(id);
      
      if (!review) {
        return res.status(404).json({ message: "Document review not found" });
      }
      
      // Verify ownership - employee can only view their own reviews
      if (review.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Only update if not already viewed
      if (!review.viewedAt) {
        const updated = await storage.updateDocumentReviewSignature(id, { viewedAt: new Date() });
        return res.json({ review: updated });
      }
      
      res.json({ review });
    } catch (error) {
      console.error("Mark document viewed error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Sign a document (requires it to be viewed first)
  app.post("/api/document-reviews/:id/sign", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { signatureDataUrl } = req.body;
      
      if (!signatureDataUrl || typeof signatureDataUrl !== 'string') {
        return res.status(400).json({ message: "Valid signature data URL is required" });
      }
      
      // Validate signature data URL format (base64 data URL)
      if (!signatureDataUrl.startsWith('data:image/')) {
        return res.status(400).json({ message: "Invalid signature format" });
      }
      
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get the review record directly by ID
      const review = await storage.getDocumentReviewSignatureById(id);
      
      if (!review) {
        return res.status(404).json({ message: "Document review not found" });
      }
      
      // Verify ownership - employee can only sign their own reviews
      if (review.employeeId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Ensure document was viewed before signing
      if (!review.viewedAt) {
        return res.status(400).json({ message: "Document must be viewed before signing" });
      }
      
      // Prevent re-signing already signed documents
      if (review.signedAt) {
        return res.status(400).json({ message: "Document has already been signed" });
      }
      
      const updated = await storage.signDocument(id, signatureDataUrl);
      res.json({ review: updated });
    } catch (error) {
      console.error("Sign document error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete a document review requirement (admin only)
  app.delete("/api/document-reviews/:id", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the review record directly by ID
      const review = await storage.getDocumentReviewSignatureById(id);
      
      if (!review) {
        return res.status(404).json({ message: "Document review not found" });
      }
      
      // Verify company ownership
      if (review.companyId !== companyId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      await storage.deleteDocumentReviewSignature(id);
      res.json({ message: "Document review deleted successfully" });
    } catch (error) {
      console.error("Delete document review error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Bulk enroll all employees in required document reviews (when a new document is uploaded)
  app.post("/api/document-reviews/enroll-all", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const { documents } = req.body; // Array of { type, id?, name, version?, fileUrl? }
      
      // Validate documents array
      if (!Array.isArray(documents) || documents.length === 0) {
        return res.status(400).json({ message: "Documents array is required" });
      }
      
      const validDocTypes = ['health_safety_manual', 'company_policy', 'method_statement', 'safe_work_practice', 'safe_work_procedure'];
      for (const doc of documents) {
        if (!doc.type || !validDocTypes.includes(doc.type)) {
          return res.status(400).json({ message: `Invalid document type: ${doc.type}` });
        }
        if (!doc.name || typeof doc.name !== 'string') {
          return res.status(400).json({ message: "Document name is required" });
        }
      }
      
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Resolve document references and validate fileUrls
      const resolvedDocuments: { type: string; id?: string; name: string; version?: string; fileUrl?: string }[] = [];
      
      for (const doc of documents) {
        let fileUrl = doc.fileUrl;
        
        // For health_safety_manual, company_policy, and safe_work_practice resolve from company documents
        if ((doc.type === 'health_safety_manual' || doc.type === 'company_policy' || doc.type === 'safe_work_practice') && !fileUrl) {
          const companyDocs = await storage.getCompanyDocumentsByType(companyId, doc.type);
          if (companyDocs.length > 0) {
            fileUrl = companyDocs[0].fileUrl;
          }
        }
        
        // For method_statement, resolve from method statements table
        if (doc.type === 'method_statement' && doc.id && !fileUrl) {
          const methodStatement = await storage.getMethodStatementById(doc.id);
          if (methodStatement && methodStatement.companyId === companyId) {
            fileUrl = null; // Method statements are viewed in-app
          } else {
            return res.status(404).json({ message: `Method statement not found: ${doc.id}` });
          }
        }
        
        // Require fileUrl for health_safety_manual, company_policy, and safe_work_practice
        if ((doc.type === 'health_safety_manual' || doc.type === 'company_policy' || doc.type === 'safe_work_practice') && !fileUrl) {
          return res.status(400).json({ message: `No ${doc.type.replace(/_/g, ' ')} document uploaded. Please upload the document first.` });
        }
        
        resolvedDocuments.push({
          type: doc.type,
          id: doc.id,
          name: doc.name,
          version: doc.version,
          fileUrl,
        });
      }
      
      // Get all employees for this company
      const employees = await storage.getAllEmployees(companyId);
      const results: any[] = [];
      
      for (const employee of employees) {
        const reviews = await storage.enrollEmployeeInDocumentReviews(companyId, employee.id, resolvedDocuments);
        results.push({ employeeId: employee.id, employeeName: employee.name, reviews });
      }
      
      res.json({ enrollments: results });
    } catch (error) {
      console.error("Bulk enroll employees error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Document Signature Compliance Report - get all employees and their document signature status
  app.get("/api/document-reviews/compliance-report", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get company info for header
      let companyName = "Company";
      if (currentUser.role === "company") {
        companyName = currentUser.companyName || currentUser.name || "Company";
      } else {
        const company = await storage.getUserById(companyId);
        if (company) {
          companyName = company.companyName || company.name || "Company";
        }
      }
      
      // Get all employees AND the company owner
      const employees = await storage.getAllEmployees(companyId);
      
      // Filter out suspended and terminated employees
      const activeEmployees = employees.filter((e: any) => 
        !e.suspendedAt && 
        e.connectionStatus !== 'suspended' && 
        !e.terminatedDate
      );
      
      // Also include the company owner in the compliance tracking
      const companyOwner = await storage.getUserById(companyId);
      const allStaff = companyOwner 
        ? [companyOwner, ...activeEmployees] 
        : activeEmployees;
      
      // Get all company documents
      const companyDocuments = await storage.getCompanyDocuments(companyId);
      
      // Filter to required document types
      const requiredDocTypes = ['health_safety_manual', 'company_policy', 'safe_work_procedure', 'safe_work_practice'];
      const requiredDocs = companyDocuments.filter((doc: any) => 
        requiredDocTypes.includes(doc.documentType)
      );
      
      // Get all document reviews
      const allReviews = await storage.getDocumentReviewSignaturesByCompany(companyId);
      
      // Build compliance matrix (includes company owner + all employees)
      const employeeCompliance = allStaff.map((employee: any) => {
        const employeeReviews = allReviews.filter((r: any) => r.employeeId === employee.id);
        
        const documentStatus = requiredDocs.map((doc: any) => {
          const review = employeeReviews.find((r: any) => r.documentId === doc.id);
          
          return {
            documentId: doc.id,
            documentName: doc.fileName || doc.documentType,
            documentType: doc.documentType,
            status: review?.signedAt ? 'signed' : (review?.viewedAt ? 'viewed' : 'pending'),
            viewedAt: review?.viewedAt || null,
            signedAt: review?.signedAt || null,
            signatureDataUrl: review?.signatureDataUrl || null,
          };
        });
        
        const signedCount = documentStatus.filter(d => d.status === 'signed').length;
        const totalCount = documentStatus.length;
        
        return {
          employeeId: employee.id,
          employeeName: employee.name || employee.email || 'Unknown',
          email: employee.email,
          documents: documentStatus,
          signedCount,
          totalCount,
          compliancePercent: totalCount > 0 ? Math.round((signedCount / totalCount) * 100) : 100,
        };
      });
      
      // Summary stats
      const totalSignatures = allStaff.length * requiredDocs.length;
      const completedSignatures = employeeCompliance.reduce((sum, e) => sum + e.signedCount, 0);
      const overallCompliancePercent = totalSignatures > 0 
        ? Math.round((completedSignatures / totalSignatures) * 100) 
        : 100;
      
      res.json({
        companyName,
        generatedAt: new Date().toISOString(),
        summary: {
          totalEmployees: allStaff.length,
          totalDocuments: requiredDocs.length,
          totalSignaturesRequired: totalSignatures,
          completedSignatures,
          pendingSignatures: totalSignatures - completedSignatures,
          overallCompliancePercent,
        },
        documents: requiredDocs.map((doc: any) => ({
          id: doc.id,
          name: doc.fileName || doc.documentType,
          type: doc.documentType,
        })),
        employees: employeeCompliance,
      });
    } catch (error) {
      console.error("Get compliance report error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== COMPANY DOCUMENTS ROUTES ====================

  // Upload company document (Health & Safety Manual or Company Policy)
  app.post("/api/company-documents", requireAuth, requireRole("operations_manager", "company"), upload.single('document'), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { documentType, jobType, customJobType } = req.body;
      
      if (!documentType || !['health_safety_manual', 'company_policy', 'certificate_of_insurance', 'method_statement', 'safe_work_procedure', 'safe_work_practice'].includes(documentType)) {
        return res.status(400).json({ message: "Invalid document type" });
      }

      // For method_statement, require jobType
      if (documentType === 'method_statement' && !jobType) {
        return res.status(400).json({ message: "Job type is required for method statement documents" });
      }

      // For single-document types (health_safety_manual, company_policy), we'll delete old documents
      // AFTER the new upload succeeds to prevent data loss on upload failure
      let existingDocsToReplace: any[] = [];
      if (documentType === 'health_safety_manual' || documentType === 'company_policy') {
        existingDocsToReplace = await storage.getCompanyDocumentsByType(companyId, documentType);
      }

      // Upload file to object storage first (before any deletions)
      const objectStorageService = new ObjectStorageService();
      const timestamp = Date.now();
      const filename = `company-documents/${documentType}-${timestamp}-${req.file.originalname}`;
      const fileUrl = await objectStorageService.uploadPublicFile(
        filename,
        req.file.buffer,
        req.file.mimetype
      );

      // Save new document to database first
      // Calculate grace period end date: 14 days from now for SCR calculations
      const graceEndsAt = new Date();
      graceEndsAt.setDate(graceEndsAt.getDate() + 14);
      
      const document = await storage.createCompanyDocument({
        companyId,
        documentType,
        fileName: req.file.originalname,
        fileUrl,
        uploadedById: currentUser.id,
        uploadedByName: currentUser.name || currentUser.email || "Unknown User",
        graceEndsAt,
        ...(documentType === 'method_statement' && { jobType, customJobType }),
      });

      // Now that new document is saved successfully, delete old documents and their signatures
      // This invalidates all existing signatures, requiring employees to re-sign the new version
      for (const oldDoc of existingDocsToReplace) {
        // Delete all signatures for this document first
        await storage.deleteDocumentReviewsByDocumentId(oldDoc.id);
        // Then delete the document
        await storage.deleteCompanyDocument(oldDoc.id);
        console.log(`Replaced old ${documentType} (ID: ${oldDoc.id}) with new version (ID: ${document.id})`);
      }

      // Auto-enroll all employees for Health & Safety Manual, Company Policy, Safe Work Procedure, and Safe Work Practice documents
      if (documentType === 'health_safety_manual' || documentType === 'company_policy' || documentType === 'safe_work_procedure' || documentType === 'safe_work_practice') {
        try {
          const employees = await storage.getAllEmployees(companyId);
          const docToEnroll = [{
            type: documentType,
            id: document.id,
            name: req.file.originalname,
            fileUrl,
          }];
          
          for (const employee of employees) {
            await storage.enrollEmployeeInDocumentReviews(companyId, employee.id, docToEnroll);
          }
          console.log(`Auto-enrolled ${employees.length} employees for document: ${req.file.originalname}`);
        } catch (enrollError) {
          console.error("Auto-enrollment error (non-fatal):", enrollError);
          // Continue - document was still uploaded successfully
        }
      }

      // For Certificate of Insurance, automatically extract expiry date using AI
      let extractedExpiryDate = null;
      if (documentType === 'certificate_of_insurance') {
        console.log("[COI AI] Starting insurance expiry extraction for document:", document.id);
        try {
          // Use the uploaded file buffer directly
          const pdfBase64 = req.file.buffer.toString('base64');
          console.log("[COI AI] PDF size:", req.file.buffer.byteLength, "bytes");
          
          // Use native Gemini SDK for extraction
          const { extractInsuranceExpiryDate } = await import("./gemini");
          const result = await extractInsuranceExpiryDate(pdfBase64);
          
          if (result.expiryDate) {
            extractedExpiryDate = new Date(result.expiryDate);
            if (!isNaN(extractedExpiryDate.getTime())) {
              await storage.updateCompanyDocument(document.id, { insuranceExpiryDate: extractedExpiryDate });
              console.log(`[COI AI] Extracted insurance expiry date: ${extractedExpiryDate.toISOString()}`);
            }
          } else {
            console.log("[COI AI] No expiry date found in document");
            if (result.error) {
              console.log("[COI AI] Error:", result.error);
            }
          }
        } catch (aiError: any) {
          console.error("[COI AI] Extraction error:", aiError?.message || aiError);
          // Continue - document was still uploaded successfully
        }
      }

      res.json({ document: { ...document, insuranceExpiryDate: extractedExpiryDate } });
    } catch (error) {
      console.error("Upload company document error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all company documents
  app.get("/api/company-documents", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const documents = await storage.getCompanyDocuments(companyId);
      res.json({ documents });
    } catch (error) {
      console.error("Get company documents error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete company document
  app.delete("/api/company-documents/:id", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await storage.deleteCompanyDocument(id);
      
      // Also delete any associated document review signatures
      await storage.deleteDocumentReviewsByDocumentId(id);
      
      res.json({ message: "Document deleted successfully" });
    } catch (error) {
      console.error("Delete company document error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Extract insurance expiry date from Certificate of Insurance PDF using AI
  app.post("/api/company-documents/:id/extract-insurance-expiry", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      
      // Get the document
      const document = await storage.getCompanyDocumentById(id);
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      if (document.documentType !== 'certificate_of_insurance') {
        return res.status(400).json({ message: "This endpoint only works for Certificate of Insurance documents" });
      }
      
      // Fetch the PDF file
      const pdfResponse = await fetch(document.fileUrl);
      if (!pdfResponse.ok) {
        return res.status(400).json({ message: "Failed to fetch PDF document" });
      }
      
      const pdfBuffer = await pdfResponse.arrayBuffer();
      const pdfBase64 = Buffer.from(pdfBuffer).toString('base64');
      
      // Initialize Gemini client via AI Integrations
      const gemini = new OpenAI({
        apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY,
        baseURL: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL,
      });
      
      // Use Gemini to extract the expiry date from the PDF
      const response = await gemini.chat.completions.create({
        model: "gemini-2.5-flash",
        messages: [
          {
            role: "user",
            content: [
              {
                type: "text",
                text: `Analyze this Certificate of Insurance PDF and extract the policy expiry date. 
                
Look for fields like "Policy Expiry", "Expiration Date", "Policy Period To", "Coverage Ends", or similar.

Respond with ONLY a JSON object in this exact format:
{"expiryDate": "YYYY-MM-DD", "confidence": "high" | "medium" | "low"}

If you cannot find an expiry date, respond with:
{"expiryDate": null, "confidence": "none", "reason": "brief explanation"}

Do not include any other text, just the JSON object.`
              },
              {
                type: "image_url",
                image_url: {
                  url: `data:application/pdf;base64,${pdfBase64}`
                }
              }
            ]
          }
        ],
        max_tokens: 200,
      });
      
      const aiResponse = response.choices[0]?.message?.content?.trim() || "";
      console.log("AI extraction response:", aiResponse);
      
      // Parse the AI response
      let extractedData;
      try {
        extractedData = JSON.parse(aiResponse);
      } catch (parseError) {
        console.error("Failed to parse AI response:", aiResponse);
        return res.status(500).json({ message: "Failed to parse AI response", rawResponse: aiResponse });
      }
      
      if (!extractedData.expiryDate) {
        return res.json({ 
          success: false, 
          message: extractedData.reason || "Could not extract expiry date from document",
          confidence: extractedData.confidence
        });
      }
      
      // Parse and validate the date
      const expiryDate = new Date(extractedData.expiryDate);
      if (isNaN(expiryDate.getTime())) {
        return res.json({ 
          success: false, 
          message: "Invalid date format extracted",
          rawDate: extractedData.expiryDate
        });
      }
      
      // Update the document with the extracted expiry date
      const updatedDocument = await storage.updateCompanyDocument(id, {
        insuranceExpiryDate: expiryDate
      });
      
      res.json({ 
        success: true, 
        expiryDate: expiryDate.toISOString(),
        confidence: extractedData.confidence,
        document: updatedDocument
      });
    } catch (error) {
      console.error("Extract insurance expiry error:", error);
      res.status(500).json({ message: "Failed to extract insurance expiry date" });
    }
  });

  // Initialize template safe work procedures for a company
  app.post("/api/company-documents/init-templates", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      const { templates } = req.body;
      
      if (!templates || !Array.isArray(templates)) {
        return res.status(400).json({ message: "Templates array is required" });
      }

      const createdDocs: any[] = [];
      const employees = await storage.getAllEmployees(companyId);

      for (const template of templates) {
        // Check if template already exists for this company
        const existing = await storage.getCompanyDocumentByTemplateId(companyId, template.templateId);
        
        if (!existing) {
          // Calculate grace period end date: 14 days from now for SCR calculations
          const graceEndsAt = new Date();
          graceEndsAt.setDate(graceEndsAt.getDate() + 14);
          
          // Create the template document
          const document = await storage.createCompanyDocument({
            companyId,
            documentType: 'safe_work_procedure',
            fileName: template.title,
            fileUrl: '', // Template procedures are generated on-demand, no file URL
            uploadedById: currentUser.id,
            uploadedByName: 'System Template',
            isTemplate: true,
            templateId: template.templateId,
            description: template.description,
            jobType: template.jobType,
            graceEndsAt,
          });

          createdDocs.push(document);

          // Auto-enroll all employees for this template
          const docToEnroll = [{
            type: 'safe_work_procedure',
            id: document.id,
            name: template.title,
            fileUrl: '',
          }];
          
          for (const employee of employees) {
            await storage.enrollEmployeeInDocumentReviews(companyId, employee.id, docToEnroll);
          }
        }
      }

      res.json({ 
        message: `Initialized ${createdDocs.length} template procedures`,
        documents: createdDocs,
        enrolledEmployees: employees.length
      });
    } catch (error) {
      console.error("Initialize template procedures error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Initialize template safe work PRACTICES for a company
  app.post("/api/company-documents/init-practice-templates", requireAuth, requireRole("operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      const { practices } = req.body;
      
      if (!practices || !Array.isArray(practices)) {
        return res.status(400).json({ message: "Practices array is required" });
      }

      const createdDocs: any[] = [];
      const employees = await storage.getAllEmployees(companyId);
      // Also include company owner in enrollment
      const companyOwner = await storage.getUserById(companyId);

      for (const practice of practices) {
        // Check if template already exists for this company
        const existing = await storage.getCompanyDocumentByTemplateId(companyId, practice.templateId);
        
        if (!existing) {
          // Calculate grace period end date: 14 days from now for SCR calculations
          const graceEndsAt = new Date();
          graceEndsAt.setDate(graceEndsAt.getDate() + 14);
          
          // Create the practice template document
          const document = await storage.createCompanyDocument({
            companyId,
            documentType: 'safe_work_practice',
            fileName: practice.title,
            fileUrl: '', // Template practices store content, no file URL
            uploadedById: currentUser.id,
            uploadedByName: 'System Template',
            isTemplate: true,
            templateId: practice.templateId,
            description: practice.description,
            content: practice.content, // Store the practice content
            graceEndsAt,
          });

          createdDocs.push(document);

          // Auto-enroll all employees AND company owner for this template
          const docToEnroll = [{
            type: 'safe_work_practice',
            id: document.id,
            name: practice.title,
            fileUrl: '',
          }];
          
          // Enroll company owner
          if (companyOwner) {
            await storage.enrollEmployeeInDocumentReviews(companyId, companyOwner.id, docToEnroll);
          }
          
          // Enroll all employees
          for (const employee of employees) {
            await storage.enrollEmployeeInDocumentReviews(companyId, employee.id, docToEnroll);
          }
        }
      }

      res.json({ 
        message: `Added ${createdDocs.length} safe work practice template(s)`,
        documents: createdDocs,
        enrolledEmployees: employees.length + (companyOwner ? 1 : 0)
      });
    } catch (error) {
      console.error("Initialize practice templates error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== JOB COMMENTS ROUTES ====================
  
  // Create job comment
  app.post("/api/projects/:projectId/comments", requireAuth, requireRole("rope_access_tech", "general_supervisor", "rope_access_supervisor", "supervisor", "operations_manager", "company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const commentData = insertJobCommentSchema.parse({
        projectId: req.params.projectId,
        companyId,
        userId: currentUser.id,
        userName: currentUser.name || currentUser.email || "Unknown User",
        comment: req.body.comment,
      });
      
      const comment = await storage.createJobComment(commentData);
      res.json({ comment });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create job comment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get job comments for a project
  app.get("/api/projects/:projectId/comments", requireAuth, async (req: Request, res: Response) => {
    try {
      const comments = await storage.getJobCommentsByProject(req.params.projectId);
      res.json({ comments });
    } catch (error) {
      console.error("Get job comments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== PAYROLL / PAY PERIOD ROUTES ====================
  
  // Get or create pay period configuration
  app.get("/api/payroll/config", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const config = await storage.getPayPeriodConfig(companyId);
      res.json({ config });
    } catch (error) {
      console.error("Get pay period config error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create or update pay period configuration
  app.post("/api/payroll/config", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      console.log("Payroll config request body:", JSON.stringify(req.body, null, 2));
      
      const configData = insertPayPeriodConfigSchema.parse({
        ...req.body,
        companyId,
      });
      
      const config = await storage.upsertPayPeriodConfig(configData);
      res.json({ config });
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Payroll config validation error:", JSON.stringify(error.errors, null, 2));
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create/update pay period config error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Manually add work session (for when employees forget to clock in)
  app.post("/api/payroll/add-work-session", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to add work sessions" });
      }

      const { employeeId, projectId, workDate, startTime, endTime, dropsCompletedNorth, dropsCompletedEast, dropsCompletedSouth, dropsCompletedWest, shortfallReason } = req.body;

      // Validate required fields
      if (!employeeId || !projectId || !workDate || !startTime || !endTime) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      // Verify employee belongs to company (or IS the company owner)
      const employee = await storage.getUserById(employeeId);
      if (!employee || (employee.companyId !== companyId && employee.id !== companyId)) {
        return res.status(400).json({ message: "Invalid employee" });
      }

      // Verify project belongs to company
      const project = await storage.getProjectById(projectId);
      if (!project || project.companyId !== companyId) {
        return res.status(400).json({ message: "Invalid project" });
      }

      // Validate drops
      const north = typeof dropsCompletedNorth === 'number' ? dropsCompletedNorth : 0;
      const east = typeof dropsCompletedEast === 'number' ? dropsCompletedEast : 0;
      const south = typeof dropsCompletedSouth === 'number' ? dropsCompletedSouth : 0;
      const west = typeof dropsCompletedWest === 'number' ? dropsCompletedWest : 0;

      if (north < 0 || east < 0 || south < 0 || west < 0) {
        return res.status(400).json({ message: "Invalid drops completed value" });
      }

      const totalDropsCompleted = north + east + south + west;

      // Calculate overtime breakdown for manual session
      const overtimeBreakdown = await calculateOvertimeHours(
        companyId,
        employeeId,
        new Date(workDate),
        new Date(startTime),
        new Date(endTime)
      );

      // Create complete work session with overtime hours using direct DB insert
      const result = await db.insert(workSessions).values({
        projectId,
        employeeId,
        companyId,
        workDate,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        dropsCompletedNorth: north,
        dropsCompletedEast: east,
        dropsCompletedSouth: south,
        dropsCompletedWest: west,
        shortfallReason: (project.dailyDropTarget && totalDropsCompleted < project.dailyDropTarget) ? shortfallReason : undefined,
        regularHours: overtimeBreakdown.regularHours.toString(),
        overtimeHours: overtimeBreakdown.overtimeHours.toString(),
        doubleTimeHours: overtimeBreakdown.doubleTimeHours.toString(),
      }).returning();
      const session = result[0];

      res.json({ session });
    } catch (error) {
      console.error("Add work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Manually add non-billable work session
  app.post("/api/payroll/add-non-billable-session", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to add work sessions" });
      }

      const { employeeId, workDate, startTime, endTime, description } = req.body;

      // Validate required fields
      if (!employeeId || !workDate || !startTime || !endTime || !description) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      // Verify employee belongs to company (or IS the company owner)
      const employee = await storage.getUserById(employeeId);
      if (!employee || (employee.companyId !== companyId && employee.id !== companyId)) {
        return res.status(400).json({ message: "Invalid employee" });
      }

      // Calculate overtime breakdown for manual non-billable session
      const overtimeBreakdown = await calculateOvertimeHours(
        companyId,
        employeeId,
        new Date(workDate),
        new Date(startTime),
        new Date(endTime)
      );

      // Create complete non-billable work session with overtime hours using direct DB insert
      const result = await db.insert(nonBillableWorkSessions).values({
        employeeId,
        companyId,
        workDate,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        description,
        regularHours: overtimeBreakdown.regularHours.toString(),
        overtimeHours: overtimeBreakdown.overtimeHours.toString(),
        doubleTimeHours: overtimeBreakdown.doubleTimeHours.toString(),
      }).returning();
      const session = result[0];

      res.json({ session });
    } catch (error) {
      console.error("Add non-billable session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update billable work session
  app.patch("/api/payroll/work-sessions/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to update work sessions" });
      }

      const { workDate, startTime, endTime, dropsCompletedNorth, dropsCompletedEast, dropsCompletedSouth, dropsCompletedWest, shortfallReason } = req.body;

      const updatedSession = await storage.updateWorkSession(req.params.id, {
        workDate,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        dropsCompletedNorth: dropsCompletedNorth || 0,
        dropsCompletedEast: dropsCompletedEast || 0,
        dropsCompletedSouth: dropsCompletedSouth || 0,
        dropsCompletedWest: dropsCompletedWest || 0,
        shortfallReason,
      });

      res.json({ session: updatedSession });
    } catch (error) {
      console.error("Update work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete billable work session
  app.delete("/api/payroll/work-sessions/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to delete work sessions" });
      }

      await storage.deleteWorkSession(req.params.id);

      res.json({ message: "Work session deleted successfully" });
    } catch (error) {
      console.error("Delete work session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update non-billable work session
  app.patch("/api/payroll/non-billable-sessions/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to update work sessions" });
      }

      const { workDate, startTime, endTime, description } = req.body;

      const updatedSession = await storage.updateNonBillableWorkSession(req.params.id, {
        workDate,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        description,
      });

      res.json({ session: updatedSession });
    } catch (error) {
      console.error("Update non-billable session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete non-billable work session
  app.delete("/api/payroll/non-billable-sessions/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }

      // Check if user has financial permissions
      const hasFinancialAccess = currentUser.role === "company" || currentUser.permissions?.includes("view_financial_data");
      if (!hasFinancialAccess) {
        return res.status(403).json({ message: "You don't have permission to delete work sessions" });
      }

      await storage.deleteNonBillableWorkSession(req.params.id);

      res.json({ message: "Non-billable work session deleted successfully" });
    } catch (error) {
      console.error("Delete non-billable session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Generate pay periods
  app.post("/api/payroll/generate-periods", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const numberOfPeriods = req.body.numberOfPeriods || 6;
      const clearExisting = req.body.clearExisting || false;
      
      // Clear existing pay periods if requested (typically when changing configuration)
      if (clearExisting) {
        await storage.deleteAllPayPeriodsForCompany(companyId);
      }
      
      const periods = await storage.generatePayPeriods(companyId, numberOfPeriods);
      res.json({ periods });
    } catch (error) {
      console.error("Generate pay periods error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all pay periods for company
  app.get("/api/payroll/periods", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const periods = await storage.getPayPeriodsByCompany(companyId);
      
      // Dynamically recalculate status based on current date
      const today = new Date().toISOString().split('T')[0];
      const periodsWithCurrentStatus = periods.map(period => {
        let status: string;
        if (period.startDate > today) {
          status = 'upcoming';
        } else if (period.endDate < today) {
          status = 'past';
        } else {
          status = 'current';
        }
        return { ...period, status };
      });
      
      res.json({ periods: periodsWithCurrentStatus });
    } catch (error) {
      console.error("Get pay periods error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get current pay period
  app.get("/api/payroll/current-period", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const period = await storage.getCurrentPayPeriod(companyId);
      res.json({ period });
    } catch (error) {
      console.error("Get current pay period error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get employee hours for a specific pay period
  app.get("/api/payroll/periods/:periodId/hours", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const period = await storage.getPayPeriodById(req.params.periodId);
      
      if (!period) {
        return res.status(404).json({ message: "Pay period not found" });
      }
      
      if (period.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const hoursSummary = await storage.getEmployeeHoursForPayPeriod(companyId, period.startDate, period.endDate);
      res.json({ hoursSummary, period });
    } catch (error) {
      console.error("Get employee hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get employee hours for date range
  app.get("/api/payroll/hours", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { startDate, endDate } = req.query;
      
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }
      
      const hoursSummary = await storage.getEmployeeHoursForPayPeriod(companyId, startDate as string, endDate as string);
      res.json({ hoursSummary });
    } catch (error) {
      console.error("Get employee hours error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== QUOTE ROUTES ====================
  
  // Create new quote with services (atomic transaction) - All employees can create quotes
  app.post("/api/quotes", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), async (req: Request, res: Response) => {
    let createdQuoteId: string | null = null;
    
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { services, ...quoteFields } = req.body;
      
      // Validate that at least one service is provided
      if (!services || !Array.isArray(services) || services.length === 0) {
        return res.status(400).json({ message: "At least one service is required for a quote" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      // Determine initial status based on user role
      // Workers create drafts, management creates open quotes
      const isWorker = ["rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"].includes(currentUser.role);
      const initialStatus = isWorker ? "draft" : "open";
      
      // Generate unique quote number for the company
      const existingQuotes = await storage.getQuotesByCompany(companyId);
      const nextNumber = existingQuotes.length + 1;
      const quoteNumber = `Q-${String(nextNumber).padStart(4, '0')}`;
      
      const quoteData = insertQuoteSchema.parse({
        ...quoteFields,
        companyId,
        createdBy: currentUser.id,
        status: initialStatus,
        quoteNumber,
      });
      
      // Create quote, services, and history in a single transaction
      const quoteWithServices = await db.transaction(async (tx) => {
        // Create the quote
        const [quote] = await tx.insert(quotes).values(quoteData).returning();
        createdQuoteId = quote.id;
        
        // Create all services
        for (const serviceData of services) {
          // Strip pricing fields if user doesn't have financial permissions
          const processedServiceData = canViewFinancialData 
            ? serviceData 
            : {
                ...serviceData,
                pricePerHour: undefined,
                pricePerStall: undefined,
                dryerVentPricePerUnit: undefined,
                totalHours: undefined,
                totalCost: undefined,
              };
          
          const service = insertQuoteServiceSchema.parse({
            ...processedServiceData,
            quoteId: quote.id,
          });
          await tx.insert(quoteServices).values(service);
        }
        
        // Log quote creation history (inside transaction for guaranteed audit trail)
        await tx.insert(quoteHistory).values({
          quoteId: quote.id,
          companyId,
          eventType: "created",
          actorUserId: currentUser.id,
          actorName: currentUser.name || currentUser.username,
          notes: `Quote ${quoteNumber} created`,
        });
        
        return quote;
      });
      
      // Get the complete quote with services (after transaction)
      const fullQuote = await storage.getQuoteById(quoteWithServices.id);
      
      // Link property manager and send notifications
      let smsResult: { sent: boolean; error?: string } = { sent: false };
      try {
        let propertyManager: any = null;
        
        // Check if PM was manually selected in the request
        if (req.body.recipientPropertyManagerId) {
          propertyManager = await storage.getUserById(req.body.recipientPropertyManagerId);
          if (propertyManager && propertyManager.role !== 'property_manager') {
            propertyManager = null; // Invalid - not a PM
          }
        }
        
        // If no manual selection, try auto-linking based on strata number
        if (!propertyManager && fullQuote!.strataPlanNumber) {
          const pmLinks = await db.select()
            .from(propertyManagerCompanyLinks)
            .where(
              and(
                eq(propertyManagerCompanyLinks.companyId, companyId),
                eq(propertyManagerCompanyLinks.strataNumber, fullQuote!.strataPlanNumber)
              )
            );
          
          if (pmLinks.length > 0) {
            propertyManager = await storage.getUserById(pmLinks[0].propertyManagerId);
          }
        }
        
        if (propertyManager && propertyManager.role === 'property_manager') {
            // If PM was manually selected and quote has a strata number, update/add PM's strata link
            if (req.body.recipientPropertyManagerId && fullQuote!.strataPlanNumber) {
              const existingLink = await db.select()
                .from(propertyManagerCompanyLinks)
                .where(
                  and(
                    eq(propertyManagerCompanyLinks.propertyManagerId, propertyManager.id),
                    eq(propertyManagerCompanyLinks.companyId, companyId)
                  )
                )
                .limit(1);
              
              if (existingLink.length > 0) {
                // Update existing link with the strata number if not already set or different
                if (!existingLink[0].strataNumber || existingLink[0].strataNumber !== fullQuote!.strataPlanNumber) {
                  await db.update(propertyManagerCompanyLinks)
                    .set({ strataNumber: fullQuote!.strataPlanNumber })
                    .where(eq(propertyManagerCompanyLinks.id, existingLink[0].id));
                  console.log(`[Quote] Updated PM link with strata number ${fullQuote!.strataPlanNumber} for ${propertyManager.email}`);
                }
              }
            }
            
            // Link the quote to this property manager and move to submitted stage
            await storage.updateQuote(fullQuote!.id, { 
              recipientPropertyManagerId: propertyManager.id,
              collaborationStatus: 'sent',
              sentAt: new Date(),
              pipelineStage: 'submitted',
              stageUpdatedAt: new Date()
            } as any);
            
            console.log(`[Quote] Linked quote ${fullQuote!.quoteNumber} to property manager ${propertyManager.email}`);
            
            // Save building info to PM's client record if one exists
            try {
              const pmClient = await db.select()
                .from(clients)
                .where(
                  and(
                    eq(clients.companyId, companyId),
                    eq(clients.email, propertyManager.email)
                  )
                )
                .limit(1);
              
              if (pmClient.length > 0 && fullQuote!.strataPlanNumber) {
                const existingBuildings = (pmClient[0].lmsNumbers as any[]) || [];
                
                // Check if this strata/building already exists
                const existingBuildingIndex = existingBuildings.findIndex(
                  (b: any) => b.number === fullQuote!.strataPlanNumber
                );
                
                if (existingBuildingIndex === -1) {
                  // Add the new building from the quote
                  const newBuilding = {
                    number: fullQuote!.strataPlanNumber,
                    buildingName: fullQuote!.buildingName || '',
                    address: fullQuote!.buildingAddress || '',
                    stories: fullQuote!.floorCount || null,
                    units: fullQuote!.unitCount || null,
                    parkingStalls: fullQuote!.parkingStalls || null
                  };
                  
                  await db.update(clients)
                    .set({ lmsNumbers: [...existingBuildings, newBuilding] })
                    .where(eq(clients.id, pmClient[0].id));
                  
                  console.log(`[Quote] Added building ${fullQuote!.buildingName} (${fullQuote!.strataPlanNumber}) to PM client record`);
                } else {
                  console.log(`[Quote] Building ${fullQuote!.strataPlanNumber} already exists in PM client record`);
                }
              }
            } catch (clientError: any) {
              console.warn(`[Quote] Could not update PM client record: ${clientError?.message}`);
            }
            
            // Get company name for WebSocket notification
            const companyUser = await storage.getUserById(companyId);
            const companyNameForWs = companyUser?.companyName || 'Rope Access Company';
            
            // Send real-time WebSocket notification to property manager
            wsHub.notifyQuoteCreated(propertyManager.id, {
              id: fullQuote!.id,
              quoteNumber: fullQuote!.quoteNumber,
              buildingName: fullQuote!.buildingName,
              strataPlanNumber: fullQuote!.strataPlanNumber,
              status: fullQuote!.status,
              grandTotal: fullQuote!.services?.reduce((sum: number, s: any) => sum + Number(s.totalCost || 0), 0)?.toString() || null,
              createdAt: fullQuote!.createdAt,
              companyName: companyNameForWs
            });
            
            // Send SMS notification if PM has phone and opted in
            if (propertyManager.propertyManagerPhoneNumber && propertyManager.propertyManagerSmsOptIn) {
              // Get company name for SMS
              const company = await storage.getUserById(companyId);
              const companyName = company?.companyName || 'Rope Access Company';
              
              // Extract service types from quote services
              const serviceTypes = fullQuote!.services?.map((s: any) => s.serviceType).filter(Boolean) || [];
              
              const smsResponse = await sendQuoteNotificationSMS(
                propertyManager.propertyManagerPhoneNumber,
                fullQuote!.buildingName,
                companyName,
                serviceTypes,
                fullQuote!.strataPlanNumber
              );
              
              if (smsResponse.success) {
                console.log(`[SMS] Quote notification sent to ${propertyManager.propertyManagerPhoneNumber}, SID: ${smsResponse.messageId}`);
                smsResult = { sent: true };
              } else {
                console.warn(`[SMS] Failed to send quote notification: ${smsResponse.error}`);
                smsResult = { sent: false, error: smsResponse.error };
              }
            } else if (propertyManager.propertyManagerPhoneNumber && !propertyManager.propertyManagerSmsOptIn) {
              console.log(`[SMS] Skipped - property manager ${propertyManager.email} has not opted-in to SMS notifications`);
            }
        }
      } catch (pmError: any) {
        console.error("[Quote] Auto-link property manager error (non-blocking):", pmError?.message || pmError);
      }
      
      res.json({ quote: fullQuote, sms: smsResult });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create quote error:", error);
      res.status(500).json({ message: error instanceof Error ? error.message : "Internal server error" });
    }
  });

  // Get all quotes for company - All employees can view
  app.get("/api/quotes", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      const status = req.query.status as string | undefined;
      let quotes = await storage.getQuotesByCompany(companyId, status);
      
      // Workers can only see quotes they created
      const isWorker = ["rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"].includes(currentUser.role);
      if (isWorker) {
        quotes = quotes.filter(quote => quote.createdBy === currentUser.id);
      }
      
      // Filter pricing data if user doesn't have financial permissions
      const filteredQuotes = canViewFinancialData ? quotes : quotes.map(quote => ({
        ...quote,
        services: quote.services.map(service => ({
          ...service,
          pricePerHour: null,
          pricePerStall: null,
          dryerVentPricePerUnit: null,
          totalHours: null,
          totalCost: null,
        })),
      }));
      
      res.json({ quotes: filteredQuotes });
    } catch (error) {
      console.error("Get quotes error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get quote analytics - aggregated stats for CRM dashboard (MUST be before :id route)
  app.get("/api/quotes/analytics", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get range from query params (default: month)
      const range = (req.query.range as string) || "month";
      
      // Calculate date filter based on range
      const now = new Date();
      let startDate: Date;
      
      switch (range) {
        case "week":
          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case "month":
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          break;
        case "year":
          startDate = new Date(now.getFullYear(), 0, 1);
          break;
        case "all":
          startDate = new Date(0); // Beginning of time
          break;
        default:
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      }
      
      // Get all quotes for the company
      const allQuotes = await storage.getQuotesByCompany(companyId);
      
      // Filter quotes by date range
      const quotesInRange = allQuotes.filter((q: any) => 
        new Date(q.createdAt) >= startDate
      );
      
      // Calculate aggregations
      const totalQuotes = quotesInRange.length;
      const wonQuotes = quotesInRange.filter((q: any) => q.pipelineStage === "won");
      const lostQuotes = quotesInRange.filter((q: any) => q.pipelineStage === "lost");
      const pendingQuotes = quotesInRange.filter((q: any) => 
        !["won", "lost"].includes(q.pipelineStage)
      );
      
      // Calculate total amounts
      const calculateTotal = (quotes: any[]) => 
        quotes.reduce((sum: number, q: any) => sum + (parseFloat(q.totalAmount) || 0), 0);
      
      const wonAmount = calculateTotal(wonQuotes);
      const lostAmount = calculateTotal(lostQuotes);
      const pendingAmount = calculateTotal(pendingQuotes);
      
      // Win rate calculation (only consider quotes that have a final outcome)
      const completedQuotes = wonQuotes.length + lostQuotes.length;
      const winRate = completedQuotes > 0 ? (wonQuotes.length / completedQuotes) * 100 : 0;
      
      // Stage breakdown
      const stageBreakdown = {
        draft: quotesInRange.filter((q: any) => q.pipelineStage === "draft").length,
        submitted: quotesInRange.filter((q: any) => q.pipelineStage === "submitted").length,
        review: quotesInRange.filter((q: any) => q.pipelineStage === "review").length,
        negotiation: quotesInRange.filter((q: any) => q.pipelineStage === "negotiation").length,
        approved: quotesInRange.filter((q: any) => q.pipelineStage === "approved").length,
        won: wonQuotes.length,
        lost: lostQuotes.length,
      };
      
      res.json({
        range,
        totalQuotes,
        wonCount: wonQuotes.length,
        lostCount: lostQuotes.length,
        pendingCount: pendingQuotes.length,
        wonAmount,
        lostAmount,
        pendingAmount,
        totalAmount: wonAmount + lostAmount + pendingAmount,
        winRate: Math.round(winRate * 10) / 10,
        stageBreakdown,
      });
    } catch (error) {
      console.error("Get quote analytics error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get quote by ID - All employees can view
  app.get("/api/quotes/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Workers can only view quotes they created
      const isWorker = ["rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"].includes(currentUser.role);
      if (isWorker && quote.createdBy !== currentUser.id) {
        return res.status(403).json({ message: "You can only view quotes you created" });
      }
      
      // Filter pricing data if user doesn't have financial permissions
      const filteredQuote = canViewFinancialData ? quote : {
        ...quote,
        services: quote.services.map(service => ({
          ...service,
          pricePerHour: null,
          pricePerStall: null,
          dryerVentPricePerUnit: null,
          totalHours: null,
          totalCost: null,
        })),
      };
      
      res.json({ quote: filteredQuote });
    } catch (error) {
      console.error("Get quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Export quote as PDF - Management only (requires financial access)
  app.get("/api/quotes/:id/pdf", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      if (!canViewFinancialData) {
        return res.status(403).json({ message: "Financial data access required to export quotes" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Get company info for branding
      const company = await storage.getUserById(companyId);
      if (!company) {
        return res.status(404).json({ message: "Company not found" });
      }
      
      // Check if white label branding is active
      const hasBranding = company.whitelabelBrandingActive;
      const brandColor = hasBranding && company.brandingColor ? company.brandingColor : '#3B82F6';
      const companyName = company.name || company.companyName || 'Company';
      const companyLogo = hasBranding && company.brandingLogoUrl ? company.brandingLogoUrl : null;
      
      // Service type labels
      const serviceTypeLabels: Record<string, string> = {
        window_cleaning: 'Window Cleaning',
        dryer_vent_cleaning: 'Exterior Dryer Vent Cleaning',
        building_wash: 'Building Wash - Pressure Washing',
        general_pressure_washing: 'General Pressure Washing',
        gutter_cleaning: 'Gutter Cleaning',
        parkade: 'Parkade Cleaning',
        ground_windows: 'Ground Windows',
        in_suite: 'In-Suite Dryer Vent',
        painting: 'Painting',
        custom: 'Custom Service',
      };
      
      // Calculate totals
      let grandTotal = 0;
      const serviceRows = quote.services.map(service => {
        const serviceName = service.serviceType === 'custom' 
          ? (service.customServiceName || 'Custom Service')
          : (serviceTypeLabels[service.serviceType] || service.serviceType);
        
        const cost = parseFloat(service.totalCost || '0');
        grandTotal += cost;
        
        // Build description based on service type
        let description = '';
        if (['window_cleaning', 'dryer_vent_cleaning', 'building_wash', 'painting'].includes(service.serviceType)) {
          const drops = [
            service.dropsNorth ? `N: ${service.dropsNorth}` : null,
            service.dropsEast ? `E: ${service.dropsEast}` : null,
            service.dropsSouth ? `S: ${service.dropsSouth}` : null,
            service.dropsWest ? `W: ${service.dropsWest}` : null,
          ].filter(Boolean).join(', ');
          if (drops) description = `Drops: ${drops}`;
        } else if (service.serviceType === 'parkade') {
          description = `${service.parkadeStalls || 0} stalls @ $${parseFloat(service.pricePerStall || '0').toFixed(2)}/stall`;
        } else if (service.serviceType === 'ground_windows') {
          description = `${service.groundWindowHours || 0} hours`;
        } else if (service.serviceType === 'in_suite') {
          description = `${service.suitesPerDay || 0} suites/day, ${service.floorsPerDay || 0} floors/day`;
        }
        
        return {
          name: serviceName,
          description,
          cost: cost.toFixed(2),
        };
      });

      // Calculate tax (13% HST as example)
      const taxRate = 0.13;
      const taxAmount = grandTotal * taxRate;
      const totalWithTax = grandTotal + taxAmount;
      
      // Generate PDF HTML with professional styling
      const escapeHtml = (text: string) => {
        return text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      };

      const pdfHtmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quote - ${escapeHtml(quote.buildingName)}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            font-size: 12px;
            line-height: 1.5;
            color: #1a1a1a;
            background: white;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid ${brandColor};
        }
        .company-info {
            flex: 1;
        }
        .company-logo {
            max-width: 180px;
            max-height: 80px;
            object-fit: contain;
            margin-bottom: 10px;
        }
        .company-name {
            font-size: 24px;
            font-weight: 700;
            color: ${brandColor};
            margin-bottom: 5px;
        }
        .company-tagline {
            font-size: 11px;
            color: #666;
        }
        .quote-title {
            text-align: right;
        }
        .quote-title h1 {
            font-size: 32px;
            font-weight: 700;
            color: ${brandColor};
            margin-bottom: 5px;
        }
        .quote-number {
            font-size: 14px;
            color: #666;
        }
        .quote-date {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: ${brandColor};
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e5e5e5;
        }
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .info-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
        }
        .info-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-bottom: 5px;
        }
        .info-value {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
        }
        .services-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .services-table th {
            background: ${brandColor};
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .services-table th:last-child {
            text-align: right;
        }
        .services-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e5e5e5;
        }
        .services-table td:last-child {
            text-align: right;
            font-weight: 500;
        }
        .services-table tr:last-child td {
            border-bottom: none;
        }
        .services-table .service-name {
            font-weight: 500;
        }
        .services-table .service-desc {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }
        .totals {
            margin-top: 20px;
            border-top: 2px solid #e5e5e5;
            padding-top: 15px;
        }
        .totals-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 8px 0;
        }
        .totals-label {
            width: 150px;
            text-align: right;
            padding-right: 20px;
            color: #666;
        }
        .totals-value {
            width: 100px;
            text-align: right;
            font-weight: 500;
        }
        .totals-row.grand-total {
            border-top: 2px solid ${brandColor};
            margin-top: 10px;
            padding-top: 15px;
        }
        .totals-row.grand-total .totals-label {
            font-size: 14px;
            font-weight: 600;
            color: #1a1a1a;
        }
        .totals-row.grand-total .totals-value {
            font-size: 18px;
            font-weight: 700;
            color: ${brandColor};
        }
        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #e5e5e5;
            text-align: center;
        }
        .footer-text {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .footer-company {
            font-size: 12px;
            font-weight: 600;
            color: ${brandColor};
        }
        .terms {
            margin-top: 30px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .terms-title {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }
        .terms-text {
            font-size: 10px;
            color: #888;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="company-info">
                ${companyLogo ? `<img src="${escapeHtml(companyLogo)}" alt="Company Logo" class="company-logo" />` : ''}
                <div class="company-name">${escapeHtml(companyName)}</div>
                <div class="company-tagline">Professional Rope Access & Building Maintenance</div>
            </div>
            <div class="quote-title">
                <h1>QUOTE</h1>
                <div class="quote-number">${escapeHtml(quote.quoteNumber || quote.strataPlanNumber)}</div>
                <div class="quote-date">Date: ${new Date(quote.createdAt || Date.now()).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Property Information</div>
            <div class="info-grid">
                <div class="info-box">
                    <div class="info-label">Building Name</div>
                    <div class="info-value">${escapeHtml(quote.buildingName)}</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Strata Plan Number</div>
                    <div class="info-value">${escapeHtml(quote.strataPlanNumber)}</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Address</div>
                    <div class="info-value">${escapeHtml(quote.buildingAddress)}</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Number of Floors</div>
                    <div class="info-value">${quote.floorCount} floors</div>
                </div>
            </div>
        </div>

        ${quote.strataManagerName ? `
        <div class="section">
            <div class="section-title">Property Manager</div>
            <div class="info-grid">
                <div class="info-box">
                    <div class="info-label">Manager Name</div>
                    <div class="info-value">${escapeHtml(quote.strataManagerName)}</div>
                </div>
                ${quote.strataManagerAddress ? `
                <div class="info-box">
                    <div class="info-label">Manager Address</div>
                    <div class="info-value">${escapeHtml(quote.strataManagerAddress)}</div>
                </div>
                ` : ''}
            </div>
        </div>
        ` : ''}

        <div class="section">
            <div class="section-title">Services</div>
            <table class="services-table">
                <thead>
                    <tr>
                        <th>Service</th>
                        <th>Amount</th>
                    </tr>
                </thead>
                <tbody>
                    ${serviceRows.map(row => `
                    <tr>
                        <td>
                            <div class="service-name">${escapeHtml(row.name)}</div>
                            ${row.description ? `<div class="service-desc">${escapeHtml(row.description)}</div>` : ''}
                        </td>
                        <td>$${row.cost}</td>
                    </tr>
                    `).join('')}
                </tbody>
            </table>
            
            <div class="totals">
                <div class="totals-row">
                    <span class="totals-label">Subtotal</span>
                    <span class="totals-value">$${grandTotal.toFixed(2)}</span>
                </div>
                <div class="totals-row">
                    <span class="totals-label">HST (13%)</span>
                    <span class="totals-value">$${taxAmount.toFixed(2)}</span>
                </div>
                <div class="totals-row grand-total">
                    <span class="totals-label">Total</span>
                    <span class="totals-value">$${totalWithTax.toFixed(2)}</span>
                </div>
            </div>
        </div>

        <div class="terms">
            <div class="terms-title">Terms & Conditions</div>
            <div class="terms-text">
                This quote is valid for 30 days from the date of issue. Payment terms: Net 30 days from invoice date. 
                All prices are in Canadian dollars unless otherwise specified. Work will be scheduled upon acceptance 
                of this quote. Additional charges may apply for work outside the scope of this quote.
            </div>
        </div>

        <div class="footer">
            <div class="footer-text">Thank you for considering our services</div>
            <div class="footer-company">${escapeHtml(companyName)}</div>
        </div>
    </div>
</body>
</html>`;

      // Generate PDF using Playwright
      const { chromium } = await import('playwright');
      
      let pdfBuffer: Buffer;
      try {
        const browser = await chromium.launch({ headless: true });
        const page = await browser.newPage();
        await page.setContent(pdfHtmlContent, { waitUntil: 'networkidle' });
        pdfBuffer = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' }
        });
        await browser.close();
      } catch (pdfError) {
        console.error("Quote PDF generation error:", pdfError);
        return res.status(500).json({ message: "Failed to generate PDF. Please try again." });
      }
      
      // Set headers for PDF download
      const fileName = `Quote-${quote.strataPlanNumber}-${quote.buildingName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Export quote PDF error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update quote - Management and workers with edit_quotes permission
  app.patch("/api/quotes/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if user has edit permissions
      // Management can edit any quote, workers can edit their own quotes
      const isManagement = ["company", "operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor"].includes(currentUser.role);
      const hasEditPermission = currentUser.permissions?.includes("edit_quotes");
      const isWorker = ["rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"].includes(currentUser.role);
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Workers can only edit quotes they created
      if (isWorker && quote.createdBy !== currentUser.id) {
        return res.status(403).json({ message: "You can only edit quotes you created" });
      }
      
      // Non-management without edit permission cannot edit
      if (!isManagement && !hasEditPermission && !isWorker) {
        return res.status(403).json({ message: "Forbidden - You don't have permission to edit quotes" });
      }
      
      const { services, ...quoteFields } = req.body;
      
      // Check if user has financial permissions
      const canViewFinancialData = currentUser.role === "company" || 
                                    currentUser.permissions?.includes("view_financial_data");
      
      // If services are provided, update the whole quote with services
      if (services && Array.isArray(services)) {
        // Process services to strip pricing fields if user doesn't have financial permissions
        const processedServices = services.map(serviceData => {
          const processedServiceData = canViewFinancialData 
            ? serviceData 
            : {
                ...serviceData,
                pricePerHour: undefined,
                pricePerStall: undefined,
                dryerVentPricePerUnit: undefined,
                totalHours: undefined,
                totalCost: undefined,
              };
          
          return insertQuoteServiceSchema.parse({
            ...processedServiceData,
            quoteId: quote.id,
          });
        });
        
        const updatedQuote = await storage.updateQuoteWithServices(
          req.params.id, 
          quoteFields,
          processedServices
        );
        
        // Filter pricing data from response if user doesn't have financial permissions
        const filteredQuote = canViewFinancialData ? updatedQuote : {
          ...updatedQuote,
          services: updatedQuote.services.map(service => ({
            ...service,
            pricePerHour: null,
            pricePerStall: null,
            dryerVentPricePerUnit: null,
            totalHours: null,
            totalCost: null,
          })),
        };
        
        res.json({ quote: filteredQuote });
      } else {
        // If no services, just update quote metadata
        const updatedQuote = await storage.updateQuote(req.params.id, quoteFields);
        res.json({ quote: updatedQuote });
      }
    } catch (error) {
      console.error("Update quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete quote
  app.delete("/api/quotes/:id", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      await storage.deleteQuote(req.params.id);
      res.json({ message: "Quote deleted successfully" });
    } catch (error) {
      console.error("Delete quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update quote status - Flexible endpoint for status transitions
  app.patch("/api/quotes/:id/status", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), async (req: Request, res: Response) => {
    try {
      const statusSchema = z.object({
        status: z.enum(["draft", "submitted", "open", "approved", "rejected"]),
      });
      
      const { status } = statusSchema.parse(req.body);
      
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const isManagement = ["company", "operations_manager", "general_supervisor", "rope_access_supervisor", "supervisor"].includes(currentUser.role);
      const isWorker = ["rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"].includes(currentUser.role);
      
      // Permission checks based on role and transition
      if (status === "submitted") {
        // Workers can only submit their own drafts
        if (isWorker && quote.createdBy !== currentUser.id) {
          return res.status(403).json({ message: "You can only submit quotes you created" });
        }
        // Only draft quotes can be submitted
        if (quote.status !== "draft") {
          return res.status(400).json({ message: "Only draft quotes can be submitted" });
        }
      } else if (status === "open" || status === "approved" || status === "rejected") {
        // Only management can change to these statuses
        if (!isManagement) {
          return res.status(403).json({ message: "Only management can approve, reject, or open quotes" });
        }
      }
      
      const updatedQuote = await storage.updateQuote(req.params.id, { status });
      
      res.json({ quote: updatedQuote, message: `Quote status updated to ${status}` });
    } catch (error) {
      console.error("Update quote status error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update quote pipeline stage - for Kanban-style CRM workflow
  app.patch("/api/quotes/:id/stage", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager"), async (req: Request, res: Response) => {
    try {
      const stageSchema = z.object({
        pipelineStage: z.enum(["draft", "submitted", "review", "negotiation", "approved", "won", "lost"]),
      });
      
      const { pipelineStage } = stageSchema.parse(req.body);
      
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const previousStage = quote.pipelineStage;
      
      // Update quote stage and log history in a single transaction with optimistic locking
      const updatedQuote = await db.transaction(async (tx) => {
        // Update the quote stage with optimistic locking (verify previousStage hasn't changed)
        const [updated] = await tx.update(quotes)
          .set({ 
            pipelineStage,
            stageUpdatedAt: new Date()
          })
          .where(and(eq(quotes.id, req.params.id), eq(quotes.pipelineStage, previousStage!)))
          .returning();
        
        if (!updated) {
          throw new Error("Quote stage was modified by another user. Please refresh and try again.");
        }
        
        // Log pipeline stage change history (inside transaction for guaranteed audit trail)
        await tx.insert(quoteHistory).values({
          quoteId: quote.id,
          companyId,
          eventType: "pipeline_stage_changed",
          previousStage,
          newStage: pipelineStage,
          actorUserId: currentUser.id,
          actorName: currentUser.name || currentUser.username,
          notes: `Stage changed from ${previousStage} to ${pipelineStage}`,
        });
        
        return updated;
      });
      
      res.json({ quote: updatedQuote, message: `Quote moved to ${pipelineStage}` });
    } catch (error) {
      console.error("Update quote pipeline stage error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get quote history timeline
  app.get("/api/quotes/:id/history", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const history = await storage.getQuoteHistory(req.params.id);
      res.json({ history });
    } catch (error) {
      console.error("Get quote history error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Upload quote photo(s) - All employees can upload photos - supports multiple files
  app.post("/api/quotes/:id/photo", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor", "rope_access_tech", "manager", "ground_crew", "ground_crew_supervisor"), imageUpload.array("photos", 10), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const files = req.files as Express.Multer.File[];
      if (!files || files.length === 0) {
        return res.status(400).json({ message: "No photo files uploaded" });
      }
      
      // Upload all photos
      const objectStorageService = new ObjectStorageService();
      const uploadPromises = files.map(async (file) => {
        const timestamp = Date.now();
        const randomSuffix = Math.random().toString(36).substring(7);
        const filename = `quotes/${companyId}/${timestamp}-${randomSuffix}-${file.originalname}`;
        return await objectStorageService.uploadPublicFile(
          filename,
          file.buffer,
          file.mimetype
        );
      });
      
      const newPhotoUrls = await Promise.all(uploadPromises);
      
      // Append new photos to existing photos
      const existingPhotoUrls = quote.photoUrls || [];
      const updatedPhotoUrls = [...existingPhotoUrls, ...newPhotoUrls];
      
      const updatedQuote = await storage.updateQuote(req.params.id, { photoUrls: updatedPhotoUrls });
      
      res.json({ quote: updatedQuote, photoUrls: newPhotoUrls });
    } catch (error) {
      console.error("Upload quote photo error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete quote photo
  app.delete("/api/quotes/:id/photo", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const { photoUrl } = req.body;
      if (!photoUrl) {
        return res.status(400).json({ message: "Photo URL is required" });
      }
      
      // Remove the photo from the array
      const currentPhotoUrls = quote.photoUrls || [];
      const updatedPhotoUrls = currentPhotoUrls.filter(url => url !== photoUrl);
      
      const updatedQuote = await storage.updateQuote(req.params.id, { photoUrls: updatedPhotoUrls });
      
      res.json({ quote: updatedQuote, message: "Photo deleted successfully" });
    } catch (error) {
      console.error("Delete quote photo error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== QUOTE SERVICE ROUTES ====================

  // Add service to existing quote
  app.post("/api/quotes/:id/services", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const serviceData = insertQuoteServiceSchema.parse({
        ...req.body,
        quoteId: req.params.id,
      });
      
      const service = await storage.createQuoteService(serviceData);
      res.json({ service });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create quote service error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete quote service
  app.delete("/api/quotes/:id/services/:serviceId", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const quote = await storage.getQuoteById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      await storage.deleteQuoteService(req.params.serviceId);
      res.json({ message: "Service deleted successfully" });
    } catch (error) {
      console.error("Delete quote service error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Email quote to customer with PDF attachment
  app.post("/api/quotes/:id/email", requireAuth, requireRole("company", "owner_ceo", "human_resources", "accounting", "operations_manager", "general_supervisor", "rope_access_supervisor", "account_manager", "supervisor"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get the quote with services
      const quote = await storage.getQuoteWithServicesById(req.params.id);
      
      if (!quote) {
        return res.status(404).json({ message: "Quote not found" });
      }
      
      if (quote.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Validate email address
      const { recipientEmail, recipientName, subject, message } = req.body;
      
      if (!recipientEmail || typeof recipientEmail !== 'string') {
        return res.status(400).json({ message: "Recipient email is required" });
      }
      
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(recipientEmail)) {
        return res.status(400).json({ message: "Invalid email address format" });
      }
      
      // Check if RESEND_API_KEY is configured
      if (!process.env.RESEND_API_KEY) {
        return res.status(500).json({ message: "Email service not configured. Please add RESEND_API_KEY to your environment." });
      }
      
      // Get company info for the email
      const company = await storage.getUserById(companyId);
      const companyName = company?.companyName || "Rope Access Company";
      
      // HTML escape function to prevent XSS/injection
      const escapeHtml = (text: string): string => {
        const map: Record<string, string> = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, (m) => map[m]);
      };
      
      // Sanitize user-provided message
      const sanitizedMessage = message ? escapeHtml(String(message)) : '';
      
      // Service name mapping
      const serviceNames: Record<string, string> = {
        window_cleaning: "Window Cleaning",
        dryer_vent_cleaning: "Exterior Dryer Vent Cleaning",
        building_wash: "Building Wash - Pressure washing",
        general_pressure_washing: "General Pressure Washing",
        gutter_cleaning: "Gutter Cleaning",
        parkade: "Parkade Cleaning",
        ground_windows: "Ground Windows",
        in_suite: "In-Suite Dryer Vent",
        painting: "Painting",
        custom: "Custom Service"
      };
      
      // Calculate grand total
      const grandTotal = quote.services.reduce((sum, s) => sum + Number(s.totalCost || 0), 0);
      
      // Generate professional HTML for PDF
      const pdfHtmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service Quote - ${escapeHtml(quote.strataPlanNumber)}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: 40px auto; padding: 20px; background: #f5f5f5; }
        .container { background: white; padding: 60px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { border-bottom: 3px solid #3B82F6; padding-bottom: 30px; margin-bottom: 40px; }
        .header h1 { color: #3B82F6; font-size: 32px; margin-bottom: 8px; }
        .header .subtitle { color: #71717A; font-size: 18px; }
        .info-grid { display: flex; gap: 30px; margin-bottom: 40px; }
        .info-section { flex: 1; }
        .info-section h3 { color: #3B82F6; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px; }
        .info-section p { color: #333; margin-bottom: 5px; }
        .info-section strong { font-weight: 600; }
        .services-section { margin: 40px 0; }
        .services-section h2 { color: #0A0A0A; font-size: 24px; margin-bottom: 25px; border-bottom: 2px solid #E4E4E7; padding-bottom: 10px; }
        .service-item { background: #FAFAFA; border: 1px solid #E4E4E7; border-radius: 8px; padding: 25px; margin-bottom: 20px; }
        .service-item h3 { color: #0A0A0A; font-size: 18px; margin-bottom: 15px; }
        .service-details { color: #71717A; font-size: 14px; }
        .service-details p { margin: 8px 0; padding-left: 10px; }
        .pricing-row { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid #E4E4E7; }
        .pricing-row strong { color: #0A0A0A; }
        .total-section { background: #3B82F6; color: white; padding: 30px; border-radius: 8px; text-align: right; margin-top: 30px; }
        .total-section h3 { font-size: 16px; margin-bottom: 10px; font-weight: 500; opacity: 0.9; }
        .total-section .amount { font-size: 36px; font-weight: bold; }
        .footer { margin-top: 50px; padding-top: 30px; border-top: 2px solid #E4E4E7; text-align: center; color: #71717A; font-size: 14px; }
        @media print { body { background: white; margin: 0; padding: 0; } .container { box-shadow: none; padding: 40px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SERVICE QUOTE</h1>
            <p class="subtitle">${escapeHtml(companyName)}</p>
        </div>

        <div class="info-grid">
            <div class="info-section">
                <h3>Quote Information</h3>
                <p><strong>Quote Date:</strong> ${quote.createdAt ? new Date(quote.createdAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : 'N/A'}</p>
                <p><strong>Quote Number:</strong> ${escapeHtml(quote.strataPlanNumber)}</p>
                <p><strong>Status:</strong> ${quote.status.toUpperCase()}</p>
            </div>
            <div class="info-section">
                <h3>Property Information</h3>
                <p><strong>Building:</strong> ${escapeHtml(quote.buildingName)}</p>
                <p><strong>Address:</strong> ${escapeHtml(quote.buildingAddress)}</p>
                <p><strong>Floors:</strong> ${quote.floorCount}</p>
            </div>
        </div>

        ${quote.strataManagerName || quote.strataManagerAddress ? `
        <div class="info-grid">
            <div class="info-section">
                <h3>Strata Property Manager</h3>
                ${quote.strataManagerName ? `<p><strong>Name:</strong> ${escapeHtml(quote.strataManagerName)}</p>` : ''}
                ${quote.strataManagerAddress ? `<p><strong>Address:</strong> ${escapeHtml(quote.strataManagerAddress)}</p>` : ''}
            </div>
        </div>
        ` : ''}

        <div class="services-section">
            <h2>Services Proposed</h2>
            ${quote.services.map((service, index) => {
              const serviceName = escapeHtml(service.customServiceName || serviceNames[service.serviceType] || service.serviceType);
              let details: string[] = [];

              if (service.dropsNorth || service.dropsEast || service.dropsSouth || service.dropsWest) {
                details.push(`<p><strong>Elevation Drops:</strong> North: ${service.dropsNorth || 0}, East: ${service.dropsEast || 0}, South: ${service.dropsSouth || 0}, West: ${service.dropsWest || 0}</p>`);
                if (service.dropsPerDay) details.push(`<p><strong>Drops per Day:</strong> ${service.dropsPerDay}</p>`);
              }

              if (service.parkadeStalls) {
                details.push(`<p><strong>Parking Stalls:</strong> ${service.parkadeStalls}</p>`);
              }

              if (service.groundWindowHours) {
                details.push(`<p><strong>Estimated Hours:</strong> ${service.groundWindowHours}</p>`);
              }

              return `
                <div class="service-item">
                    <h3>${index + 1}. ${serviceName}</h3>
                    <div class="service-details">
                        ${details.join('')}
                        ${service.totalHours ? `<p><strong>Total Hours:</strong> ${service.totalHours}</p>` : ''}
                    </div>
                    ${service.totalCost ? `
                    <div class="pricing-row">
                        <strong>Service Total</strong>
                        <strong>$${Number(service.totalCost).toFixed(2)}</strong>
                    </div>
                    ` : ''}
                </div>
              `;
            }).join('')}
        </div>

        <div class="total-section">
            <h3>TOTAL INVESTMENT</h3>
            <div class="amount">$${grandTotal.toFixed(2)}</div>
        </div>

        <div class="footer">
            <p><strong>${escapeHtml(companyName)}</strong></p>
            <p>Professional Rope Access & High-Rise Maintenance Services</p>
            <p style="margin-top: 15px; font-size: 12px;">This quote is valid for 30 days from the date of issue. All work will be completed in accordance with IRATA standards and local safety regulations.</p>
        </div>
    </div>
</body>
</html>`;

      // Generate PDF using Playwright
      const { chromium } = await import('playwright');
      
      let pdfBuffer: Buffer;
      try {
        const browser = await chromium.launch({ headless: true });
        const page = await browser.newPage();
        await page.setContent(pdfHtmlContent, { waitUntil: 'networkidle' });
        pdfBuffer = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' }
        });
        await browser.close();
      } catch (pdfError) {
        console.error("PDF generation error:", pdfError);
        return res.status(500).json({ message: "Failed to generate PDF. Please try again." });
      }
      
      // Generate email body HTML (simpler version for email clients)
      const emailHtmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="background: white; padding: 30px; border-radius: 8px; border: 1px solid #E4E4E7;">
        <div style="border-bottom: 2px solid #3B82F6; padding-bottom: 15px; margin-bottom: 20px;">
            <h1 style="color: #3B82F6; font-size: 24px; margin: 0 0 5px 0;">Service Quote</h1>
            <p style="color: #71717A; font-size: 14px; margin: 0;">${escapeHtml(companyName)}</p>
        </div>

        ${sanitizedMessage ? `<div style="background: #F3F4F6; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
            <p style="margin: 0; color: #374151;">${sanitizedMessage}</p>
        </div>` : ''}

        <p style="margin-bottom: 15px;">Please find attached the service quote for <strong>${escapeHtml(quote.buildingName)}</strong>.</p>
        
        <div style="background: #F9FAFB; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
            <p style="margin: 5px 0;"><strong>Quote Number:</strong> ${escapeHtml(quote.quoteNumber || quote.strataPlanNumber)}</p>
            <p style="margin: 5px 0;"><strong>Building:</strong> ${escapeHtml(quote.buildingName)}</p>
            <p style="margin: 5px 0;"><strong>Total:</strong> $${grandTotal.toFixed(2)}</p>
        </div>

        <p style="color: #71717A; font-size: 13px;">The detailed quote is attached as a PDF for your records.</p>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #E4E4E7; text-align: center; color: #71717A; font-size: 12px;">
            <p style="margin: 0;"><strong>${escapeHtml(companyName)}</strong></p>
            <p style="margin: 3px 0;">Professional Rope Access & High-Rise Maintenance Services</p>
        </div>
    </div>
</body>
</html>`;

      // Initialize Resend and send email with PDF attachment
      const resend = new Resend(process.env.RESEND_API_KEY);
      
      const emailSubject = subject ? escapeHtml(String(subject)) : `Service Quote for ${escapeHtml(quote.buildingName)} - ${escapeHtml(quote.quoteNumber || quote.strataPlanNumber)}`;
      const quoteIdentifier = quote.quoteNumber || quote.strataPlanNumber;
      const pdfFilename = `Quote_${quoteIdentifier.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      
      const { data, error } = await resend.emails.send({
        from: 'OnRopePro <quotes@onropepro.com>',
        to: recipientEmail,
        subject: emailSubject,
        html: emailHtmlContent,
        attachments: [
          {
            filename: pdfFilename,
            content: pdfBuffer.toString('base64'),
          }
        ],
      });
      
      if (error) {
        console.error("Resend email error:", error);
        return res.status(500).json({ message: `Failed to send email: ${error.message}` });
      }
      
      console.log(`Quote ${quote.strataPlanNumber} emailed to ${recipientEmail} with PDF attachment, message ID: ${data?.id}`);
      
      // SMS notification to property manager (non-blocking, failures don't affect email delivery)
      let smsResult: { sent: boolean; error?: string } = { sent: false };
      try {
        // Look up if recipient is a property manager with a phone number
        const propertyManager = await storage.getUserByEmail(recipientEmail);
        if (propertyManager?.role === 'property_manager') {
          // Link the quote to this property manager so they can view it
          await storage.updateQuote(quote.id, { recipientPropertyManagerId: propertyManager.id } as any);
          
          // If they have a phone number AND opted-in to SMS, send SMS notification
          if (propertyManager.propertyManagerPhoneNumber && propertyManager.propertyManagerSmsOptIn) {
            // Extract service types from quote services
            const serviceTypes = quote.services?.map((s: any) => s.serviceType).filter(Boolean) || [];
            
            const smsResponse = await sendQuoteNotificationSMS(
              propertyManager.propertyManagerPhoneNumber,
              quote.buildingName,
              companyName,
              serviceTypes,
              quote.strataPlanNumber
            );
            if (smsResponse.success) {
              console.log(`[SMS] Quote notification sent to ${propertyManager.propertyManagerPhoneNumber}, SID: ${smsResponse.messageId}`);
              smsResult = { sent: true };
            } else {
              console.warn(`[SMS] Failed to send quote notification: ${smsResponse.error}`);
              smsResult = { sent: false, error: smsResponse.error };
            }
          } else if (propertyManager.propertyManagerPhoneNumber && !propertyManager.propertyManagerSmsOptIn) {
            console.log(`[SMS] Skipped - property manager ${recipientEmail} has not opted-in to SMS notifications`);
          }
        }
      } catch (smsError: any) {
        console.error("[SMS] Quote notification error (non-blocking):", smsError?.message || smsError);
        smsResult = { sent: false, error: smsError?.message || 'SMS sending failed' };
      }
      
      res.json({ 
        message: "Quote sent successfully with PDF attachment",
        emailId: data?.id,
        sms: smsResult
      });
    } catch (error) {
      console.error("Email quote error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== WEATHER ROUTES ====================

  // Get weather data from Open-Meteo (free, no API key required)
  app.get("/api/weather", requireAuth, requireRole("company", "employee", "rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager", "labourer"), async (req: Request, res: Response) => {
    try {
      const lat = parseFloat(req.query.lat as string);
      const lon = parseFloat(req.query.lon as string);
      
      if (isNaN(lat) || isNaN(lon)) {
        return res.status(400).json({ message: "Invalid coordinates. Please provide lat and lon query parameters." });
      }
      
      // Fetch from Open-Meteo API - free, no key required
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m&timezone=auto&forecast_days=2`;
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Open-Meteo API error: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Transform the data for easier frontend consumption
      const current = {
        temperature: data.current?.temperature_2m,
        temperatureUnit: data.current_units?.temperature_2m || "Â°C",
        humidity: data.current?.relative_humidity_2m,
        weatherCode: data.current?.weather_code,
        windSpeed: data.current?.wind_speed_10m,
        windSpeedUnit: data.current_units?.wind_speed_10m || "km/h",
        windDirection: data.current?.wind_direction_10m,
        windGusts: data.current?.wind_gusts_10m,
        time: data.current?.time,
      };
      
      // Build hourly forecast
      const hourly = [];
      if (data.hourly?.time) {
        for (let i = 0; i < data.hourly.time.length; i++) {
          hourly.push({
            time: data.hourly.time[i],
            temperature: data.hourly.temperature_2m?.[i],
            weatherCode: data.hourly.weather_code?.[i],
            windSpeed: data.hourly.wind_speed_10m?.[i],
            windDirection: data.hourly.wind_direction_10m?.[i],
            windGusts: data.hourly.wind_gusts_10m?.[i],
          });
        }
      }
      
      res.json({
        current,
        hourly,
        timezone: data.timezone,
        location: { lat, lon },
      });
    } catch (error) {
      console.error("Weather API error:", error);
      res.status(500).json({ message: "Failed to fetch weather data" });
    }
  });

  // ==================== SCHEDULING ROUTES ====================

  // Get all scheduled jobs for the company
  app.get("/api/schedule", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const jobs = await storage.getScheduledJobsByCompany(companyId);
      
      // DEBUG: Log what we're returning for Dryer vent job
      const dryerJob = jobs.find(j => j.title?.includes("Dryer"));
      if (dryerJob) {
        console.log("=== SERVER DEBUG: Dryer vent job ===");
        console.log("Title:", dryerJob.title);
        console.log("Start:", dryerJob.startDate, "End:", dryerJob.endDate);
        console.log("employeeAssignments count:", dryerJob.employeeAssignments?.length);
        console.log("employeeAssignments:", JSON.stringify(dryerJob.employeeAssignments, null, 2));
      }
      
      res.json({ jobs });
    } catch (error) {
      console.error("Get scheduled jobs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get today's schedule for dashboard
  app.get("/api/schedule/today", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      // Get company for timezone
      const company = await storage.getUserById(companyId);
      const companyTimezone = company?.companyTimezone || 'America/Vancouver';
      
      // Get all scheduled jobs for the company
      const allJobs = await storage.getScheduledJobsByCompany(companyId);
      
      // Filter to jobs happening today in company timezone using project utility
      const { startOfDay: todayStartUtc, endOfDay: todayEndUtc } = getZonedDayBounds(companyTimezone);
      
      let todayJobs = allJobs.filter(job => {
        const jobStart = new Date(job.startDate);
        const jobEnd = new Date(job.endDate);
        // Job overlaps with today if it starts before end of today AND ends after start of today
        return jobStart <= todayEndUtc && jobEnd >= todayStartUtc;
      });
      
      // Role-based filtering:
      // - company role sees all jobs
      // - manager/supervisor roles with schedule access see all jobs
      // - employees/technicians see only their assigned jobs
      const canViewAllSchedule = currentUser.role === "company" || 
        (currentUser.companyRole && ['manager', 'supervisor', 'operations_coordinator', 'safety_officer'].includes(currentUser.companyRole));
      
      if (!canViewAllSchedule) {
        todayJobs = todayJobs.filter(job => {
          const isAssigned = job.assignedEmployees?.some((emp: any) => emp.id === currentUser.id) ||
                            job.employeeAssignments?.some((assignment: any) => assignment.employee?.id === currentUser.id);
          return isAssigned;
        });
      }
      
      // Format for dashboard display - only expose initials and color, not sensitive data
      const scheduleItems = todayJobs.map(job => {
        const startTime = new Date(job.startDate);
        const colors = ['bg-blue-500', 'bg-green-500', 'bg-purple-500', 'bg-orange-500', 'bg-teal-500', 'bg-rose-500', 'bg-amber-500'];
        
        // Helper to generate initials from employee data with fallbacks
        const getInitialsFromEmployee = (emp: any): { initials: string; color: string } | null => {
          if (!emp) return null;
          
          // Check for pre-existing initials field first
          let initials = emp.initials || '';
          
          // If no initials field, try to generate from name
          if (!initials && (emp.firstName || emp.lastName)) {
            initials = `${(emp.firstName || '')[0] || ''}${(emp.lastName || '')[0] || ''}`.toUpperCase();
          }
          
          // Fall back to email
          if (!initials && emp.email) {
            initials = emp.email.substring(0, 2).toUpperCase();
          }
          
          // Last resort fallback
          if (!initials) initials = 'NA';
          
          // Use pre-existing color if available, otherwise generate from id/email
          if (emp.color && typeof emp.color === 'string' && emp.color.startsWith('bg-')) {
            return { initials, color: emp.color };
          }
          const colorSeed = emp.id || emp.email || initials;
          const colorIndex = colorSeed.charCodeAt(0) % colors.length;
          return { initials, color: colors[colorIndex] };
        };
        
        // Try employeeAssignments first, fall back to assignedEmployees
        let technicians: Array<{initials: string; color: string}> = [];
        
        if (job.employeeAssignments && job.employeeAssignments.length > 0) {
          technicians = job.employeeAssignments
            .map((assignment: any) => getInitialsFromEmployee(assignment.employee))
            .filter(Boolean) as Array<{initials: string; color: string}>;
        } else if (job.assignedEmployees && job.assignedEmployees.length > 0) {
          technicians = job.assignedEmployees
            .map((emp: any) => getInitialsFromEmployee(emp))
            .filter(Boolean) as Array<{initials: string; color: string}>;
        }
        
        return {
          id: job.id,
          time: startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: companyTimezone }),
          title: job.title,
          location: job.location || job.project?.buildingName || 'TBD',
          technicians,
          status: job.status,
          jobType: job.jobType,
        };
      }).sort((a, b) => a.time.localeCompare(b.time));
      
      res.json({ scheduleItems });
    } catch (error) {
      console.error("Get today's schedule error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get scheduled jobs assigned to current employee
  app.get("/api/schedule/my-jobs", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only employees should call this endpoint
      if (currentUser.role === "company" || currentUser.role === "resident") {
        return res.status(400).json({ message: "Invalid endpoint for this role" });
      }
      
      const jobs = await storage.getScheduledJobsByEmployee(currentUser.id);
      res.json({ jobs });
    } catch (error) {
      console.error("Get employee scheduled jobs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create new scheduled job
  app.post("/api/schedule", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { employeeIds, forceAssignment, ...jobFields } = req.body;
      
      const jobData = insertScheduledJobSchema.parse({
        ...jobFields,
        companyId,
        createdBy: currentUser.id,
      });
      
      const job = await storage.createScheduledJob(jobData);
      
      // Assign employees if provided
      if (employeeIds && Array.isArray(employeeIds) && employeeIds.length > 0) {
        // Check for double-booking conflicts (unless forceAssignment is true)
        if (!forceAssignment) {
          const conflicts = await storage.checkEmployeeConflicts(employeeIds, job.startDate, job.endDate, job.id);
          
          if (conflicts.length > 0) {
            // Delete the job we just created since we can't assign
            await storage.deleteScheduledJob(job.id);
            return res.status(409).json({
              message: "Schedule conflict detected",
              conflicts,
            });
          }
        }
        
        await storage.replaceJobAssignments(job.id, employeeIds, currentUser.id);
      }
      
      // Return job with assignments
      const jobWithAssignments = await storage.getScheduledJobWithAssignments(job.id);
      res.json({ job: jobWithAssignments });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create scheduled job error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update scheduled job
  app.put("/api/schedule/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.id);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const { employeeIds, ...jobFields } = req.body;
      
      const updateData = insertScheduledJobSchema.partial().parse(jobFields);
      const updatedJob = await storage.updateScheduledJob(req.params.id, updateData);
      
      // Update employee assignments if provided
      if (employeeIds !== undefined && Array.isArray(employeeIds)) {
        // Get the job dates for conflict checking
        const jobForDates = updatedJob || job;
        
        // Check for double-booking conflicts
        const conflicts = await storage.checkEmployeeConflicts(employeeIds, jobForDates.startDate, jobForDates.endDate, req.params.id);
        
        if (conflicts.length > 0) {
          return res.status(409).json({
            message: "Schedule conflict detected",
            conflicts,
          });
        }
        
        await storage.replaceJobAssignments(req.params.id, employeeIds, currentUser.id);
      }
      
      // Return job with assignments
      const jobWithAssignments = await storage.getScheduledJobWithAssignments(req.params.id);
      res.json({ job: jobWithAssignments });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Update scheduled job error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete scheduled job
  app.delete("/api/schedule/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.id);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      await storage.deleteScheduledJob(req.params.id);
      res.json({ message: "Job deleted successfully" });
    } catch (error) {
      console.error("Delete scheduled job error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Assign employees to a job
  app.post("/api/schedule/:id/assign", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.id);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const { employeeIds, forceAssignment } = req.body;
      
      if (!Array.isArray(employeeIds)) {
        return res.status(400).json({ message: "employeeIds must be an array" });
      }
      
      // Check for double-booking conflicts (unless forceAssignment is true)
      if (!forceAssignment) {
        const conflicts = await storage.checkEmployeeConflicts(employeeIds, job.startDate, job.endDate, req.params.id);
        
        if (conflicts.length > 0) {
          return res.status(409).json({ 
            message: "Schedule conflict detected",
            conflicts: conflicts.map(c => ({
              employeeId: c.employeeId,
              employeeName: c.employeeName,
              conflictingJob: c.conflictingJobTitle,
            }))
          });
        }
      }
      
      // Remove existing assignments and add new ones
      await storage.replaceJobAssignments(req.params.id, employeeIds, currentUser.id);
      
      const updatedJob = await storage.getScheduledJobWithAssignments(req.params.id);
      res.json({ job: updatedJob });
    } catch (error) {
      console.error("Assign employees error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get assignments for a specific job
  app.get("/api/schedule/:id/assignments", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.id);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const assignments = await storage.getJobAssignments(req.params.id);
      res.json({ assignments });
    } catch (error) {
      console.error("Get job assignments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create or update individual assignment with date range
  app.post("/api/schedule/:jobId/assign-employee", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.jobId);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      const { employeeId, startDate, endDate, forceAssignment } = req.body;
      
      console.log("[ASSIGN EMPLOYEE] Received request body:", req.body);
      console.log("[ASSIGN EMPLOYEE] employeeId:", employeeId);
      console.log("[ASSIGN EMPLOYEE] startDate:", startDate);
      console.log("[ASSIGN EMPLOYEE] endDate:", endDate);
      console.log("[ASSIGN EMPLOYEE] forceAssignment:", forceAssignment);
      
      if (!employeeId) {
        return res.status(400).json({ message: "employeeId is required" });
      }
      
      // Parse dates properly - handle empty strings
      const parsedStartDate = startDate && startDate.trim() !== '' ? new Date(startDate) : null;
      const parsedEndDate = endDate && endDate.trim() !== '' ? new Date(endDate) : null;
      
      console.log("[ASSIGN EMPLOYEE] Parsed startDate:", parsedStartDate);
      console.log("[ASSIGN EMPLOYEE] Parsed endDate:", parsedEndDate);
      
      // Check for double-booking conflicts (unless forceAssignment is true)
      if (!forceAssignment) {
        const checkStartDate = parsedStartDate || job.startDate;
        const checkEndDate = parsedEndDate || job.endDate;
        
        const conflicts = await storage.checkEmployeeConflicts([employeeId], checkStartDate, checkEndDate, req.params.jobId);
        
        if (conflicts.length > 0) {
          return res.status(409).json({ 
            message: "Schedule conflict detected",
            conflicts: conflicts.map(c => ({
              employeeId: c.employeeId,
              employeeName: c.employeeName,
              conflictingJob: c.conflictingJobTitle,
            }))
          });
        }
      }
      
      // Check if assignment already exists
      const existingAssignments = await storage.getJobAssignments(req.params.jobId);
      const existingAssignment = existingAssignments.find(a => a.employeeId === employeeId);
      
      if (existingAssignment) {
        // Update existing assignment
        console.log("[ASSIGN EMPLOYEE] Updating existing assignment:", existingAssignment.id);
        await db.update(jobAssignments)
          .set({
            startDate: parsedStartDate,
            endDate: parsedEndDate,
          })
          .where(eq(jobAssignments.id, existingAssignment.id));
      } else {
        // Create new assignment
        console.log("[ASSIGN EMPLOYEE] Creating new assignment");
        await storage.createJobAssignment({
          jobId: req.params.jobId,
          employeeId,
          startDate: parsedStartDate as any,
          endDate: parsedEndDate as any,
          assignedBy: currentUser.id,
        });
      }
      
      const updatedJob = await storage.getScheduledJobWithAssignments(req.params.jobId);
      res.json({ job: updatedJob });
    } catch (error) {
      console.error("Assign employee error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete specific assignment
  app.delete("/api/schedule/:jobId/assignments/:assignmentId", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const job = await storage.getScheduledJobById(req.params.jobId);
      
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      if (job.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      await storage.deleteJobAssignment(req.params.assignmentId);
      
      const updatedJob = await storage.getScheduledJobWithAssignments(req.params.jobId);
      res.json({ job: updatedJob });
    } catch (error) {
      console.error("Delete assignment error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== EMPLOYEE TIME OFF ROUTES ====================

  // Get employee time off entries
  app.get("/api/employee-time-off", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const startDate = req.query.startDate as string | undefined;
      const endDate = req.query.endDate as string | undefined;
      
      const timeOffEntries = await storage.getEmployeeTimeOffByCompany(companyId, startDate, endDate);
      res.json({ timeOff: timeOffEntries });
    } catch (error) {
      console.error("Get employee time off error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create employee time off entry
  app.post("/api/employee-time-off", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only management roles can create time off entries
      const managementRoles = ["company", "owner_ceo", "operations_manager", "supervisor"];
      if (!managementRoles.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only management can schedule time off" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const { employeeId, date, timeOffType, notes } = req.body;
      
      if (!employeeId || !date || !timeOffType) {
        return res.status(400).json({ message: "employeeId, date, and timeOffType are required" });
      }
      
      // Verify the employee belongs to this company
      const employee = await storage.getUserById(employeeId);
      if (!employee || (employee.companyId !== companyId && employee.id !== companyId)) {
        return res.status(403).json({ message: "Employee not found or not in your company" });
      }
      
      const timeOff = await storage.createEmployeeTimeOff({
        companyId,
        employeeId,
        date,
        timeOffType,
        notes: notes || null,
        createdBy: currentUser.id,
      });
      
      res.json({ timeOff });
    } catch (error) {
      console.error("Create employee time off error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete employee time off entry
  app.delete("/api/employee-time-off/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Only management roles can delete time off entries
      const managementRoles = ["company", "owner_ceo", "operations_manager", "supervisor"];
      if (!managementRoles.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only management can delete time off" });
      }
      
      const companyId = currentUser.role === "company" ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Unable to determine company" });
      }
      
      const timeOff = await storage.getEmployeeTimeOffById(req.params.id);
      if (!timeOff) {
        return res.status(404).json({ message: "Time off entry not found" });
      }
      
      if (timeOff.companyId !== companyId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      await storage.deleteEmployeeTimeOff(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete employee time off error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================================================
  // FEATURE REQUEST ROUTES
  // ============================================================================

  // Get all feature requests for a company (company owners only)
  app.get("/api/feature-requests", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      let requests;
      if (currentUser.role === "superuser") {
        // Superusers see all requests
        requests = await storage.getFeatureRequestsWithMessages();
      } else {
        // Company owners see only their own requests
        requests = await storage.getFeatureRequestsWithMessages(currentUser.id);
      }

      res.json({ requests });
    } catch (error) {
      console.error("Get feature requests error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get unread message count (MUST be before /:id route)
  app.get("/api/feature-requests/unread-count", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const count = await storage.getUnreadFeatureRequestMessageCount(
        currentUser.role === "superuser" ? undefined : currentUser.id
      );

      res.json({ count });
    } catch (error) {
      console.error("Get unread count error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single feature request with messages
  app.get("/api/feature-requests/:id", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const request = await storage.getFeatureRequestWithMessages(req.params.id);
      if (!request) {
        return res.status(404).json({ message: "Feature request not found" });
      }

      // Verify ownership or superuser access
      if (currentUser.role !== "superuser" && request.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Mark messages as read
      await storage.markFeatureRequestMessagesAsRead(req.params.id, currentUser.id);

      res.json({ request });
    } catch (error) {
      console.error("Get feature request error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get my feedback requests (for technicians)
  app.get("/api/my-feedback", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get all feature requests submitted by this user
      const requests = await db.select().from(featureRequests)
        .where(eq(featureRequests.companyId, currentUser.id))
        .orderBy(desc(featureRequests.createdAt));

      // Get messages for each request
      const requestsWithMessages = await Promise.all(requests.map(async (req) => {
        const messages = await db.select().from(featureRequestMessages)
          .where(eq(featureRequestMessages.requestId, req.id))
          .orderBy(featureRequestMessages.createdAt);
        
        // Count unread messages from superuser
        const unreadCount = messages.filter(m => 
          m.senderRole === 'superuser' && !m.isRead
        ).length;
        
        return {
          ...req,
          messages,
          unreadCount
        };
      }));

      res.json({ requests: requestsWithMessages });
    } catch (error) {
      console.error("Get my feedback error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark feedback messages as read (for technicians)
  app.post("/api/my-feedback/:id/mark-read", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const request = await storage.getFeatureRequestById(req.params.id);
      if (!request || request.companyId !== currentUser.id) {
        return res.status(404).json({ message: "Feedback not found" });
      }

      // Mark all messages from superuser as read
      await db.update(featureRequestMessages)
        .set({ isRead: true })
        .where(and(
          eq(featureRequestMessages.requestId, req.params.id),
          eq(featureRequestMessages.senderRole, 'superuser'),
          eq(featureRequestMessages.isRead, false)
        ));

      res.json({ success: true });
    } catch (error) {
      console.error("Mark feedback read error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Technician reply to feedback (for two-way communication)
  app.post("/api/my-feedback/:id/reply", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const request = await storage.getFeatureRequestById(req.params.id);
      if (!request || request.companyId !== currentUser.id) {
        return res.status(404).json({ message: "Feedback not found" });
      }

      const { message } = req.body;
      if (!message?.trim()) {
        return res.status(400).json({ message: "Message is required" });
      }

      const messageData = insertFeatureRequestMessageSchema.parse({
        requestId: req.params.id,
        senderId: currentUser.id,
        senderRole: currentUser.role,
        senderName: currentUser.name || currentUser.email || 'User',
        message: message.trim(),
      });

      const newMessage = await storage.createFeatureRequestMessage(messageData);
      res.json({ message: newMessage });
    } catch (error) {
      console.error("Reply to feedback error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create new feature request (company owners and technicians)
  app.post("/api/feature-requests", requireAuth, requireRole("company", "rope_access_tech"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const requestData = insertFeatureRequestSchema.parse({
        ...req.body,
        companyId: currentUser.id,
        contactName: currentUser.name || currentUser.email || "Unknown",
        contactEmail: currentUser.email,
        companyName: currentUser.role === 'rope_access_tech' ? "Technician Feedback" : (currentUser.companyName || "Unknown Company"),
      });

      const request = await storage.createFeatureRequest(requestData);
      res.json({ request });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create feature request error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update feature request status (superusers only)
  app.patch("/api/feature-requests/:id", requireAuth, requireRole("superuser"), async (req: Request, res: Response) => {
    try {
      const { status } = req.body;
      
      const validStatuses = ["pending", "reviewing", "in_progress", "completed", "declined"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const updates: any = { status };
      if (status === "completed" || status === "declined") {
        updates.resolvedAt = new Date();
      }

      const request = await storage.updateFeatureRequest(req.params.id, updates);
      res.json({ request });
    } catch (error) {
      console.error("Update feature request error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Add message to feature request
  app.post("/api/feature-requests/:id/messages", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const request = await storage.getFeatureRequestById(req.params.id);
      if (!request) {
        return res.status(404).json({ message: "Feature request not found" });
      }

      // Verify ownership or superuser access
      if (currentUser.role !== "superuser" && request.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const messageData = insertFeatureRequestMessageSchema.parse({
        requestId: req.params.id,
        senderId: currentUser.id,
        senderRole: currentUser.role === "superuser" ? "superuser" : "company",
        senderName: currentUser.name || currentUser.email || "Unknown",
        message: req.body.message,
        isRead: false,
      });

      const message = await storage.createFeatureRequestMessage(messageData);
      res.json({ message });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create feature request message error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user preferences
  app.get("/api/user-preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const preferences = await storage.getUserPreferences(req.session.userId!);
      res.json({ preferences });
    } catch (error) {
      console.error("Get user preferences error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update user preferences
  app.post("/api/user-preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const { dashboardCardOrder, hoursAnalyticsCardOrder } = req.body;
      
      const preferences = await storage.updateUserPreferences(req.session.userId!, {
        dashboardCardOrder,
        hoursAnalyticsCardOrder,
      });
      
      res.json({ preferences });
    } catch (error) {
      console.error("Update user preferences error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================================================
  // JOB BOARD ROUTES
  // ============================================================================

  // List all job postings (different views for different roles)
  app.get("/api/job-postings", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      let result;
      
      if (currentUser.role === "superuser") {
        // SuperUser sees all job postings (platform-wide)
        result = await db.select().from(jobPostings).orderBy(sql`${jobPostings.createdAt} DESC`);
      } else if (currentUser.role === "company") {
        // Company owners see their own postings
        result = await db.select().from(jobPostings)
          .where(eq(jobPostings.companyId, currentUser.id))
          .orderBy(sql`${jobPostings.createdAt} DESC`);
      } else {
        // Technicians/employees see all active job postings (platform + company)
        // Also filter out expired postings
        result = await db.select({
          job: jobPostings,
          companyName: users.companyName,
        }).from(jobPostings)
          .leftJoin(users, eq(jobPostings.companyId, users.id))
          .where(and(
            eq(jobPostings.status, "active"),
            sql`(${jobPostings.expiresAt} IS NULL OR ${jobPostings.expiresAt} > NOW())`
          ))
          .orderBy(sql`${jobPostings.createdAt} DESC`);
        
        // Flatten the result for technicians
        result = result.map(r => ({
          ...r.job,
          companyName: r.companyName || "Platform",
        }));
      }

      res.json({ jobPostings: result });
    } catch (error) {
      console.error("Get job postings error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Public job postings - for technicians to browse (only active jobs)
  // IMPORTANT: This route must come BEFORE /api/job-postings/:id to avoid "public" being treated as an ID
  app.get("/api/job-postings/public", requireAuth, async (req: Request, res: Response) => {
    try {
      // Get only active, non-expired job postings
      const now = new Date();
      const positionType = req.query.positionType as string | undefined;
      
      // Build conditions array
      const conditions: any[] = [
        eq(jobPostings.status, "active"),
        or(
          isNull(jobPostings.expiresAt),
          gt(jobPostings.expiresAt, now)
        )
      ];
      
      // Add position type filter if specified
      if (positionType && (positionType === "rope_access" || positionType === "ground_crew")) {
        conditions.push(eq(jobPostings.positionType, positionType));
      }
      
      const activeJobs = await db.select({
        job: jobPostings,
        companyName: users.companyName,
      }).from(jobPostings)
        .leftJoin(users, eq(jobPostings.companyId, users.id))
        .where(and(...conditions))
        .orderBy(desc(jobPostings.createdAt));

      // Get CSR ratings for all companies that have job postings
      const companyIds = [...new Set(activeJobs.map(item => item.job.companyId).filter(Boolean))];
      const csrMap = new Map<string, number>();
      
      for (const companyId of companyIds) {
        if (companyId) {
          const [latestCsr] = await db.select({
            newScore: csrRatingHistory.newScore,
          }).from(csrRatingHistory)
            .where(eq(csrRatingHistory.companyId, companyId))
            .orderBy(desc(csrRatingHistory.createdAt))
            .limit(1);
          
          if (latestCsr) {
            csrMap.set(companyId, latestCsr.newScore);
          }
        }
      }

      const jobsWithCompany = activeJobs.map(item => ({
        ...item.job,
        companyName: item.job.isPlatformPost ? "OnRopePro Platform" : (item.companyName || "Unknown Company"),
        companyCsr: item.job.companyId ? csrMap.get(item.job.companyId) ?? null : null,
      }));

      res.json({ jobPostings: jobsWithCompany });
    } catch (error) {
      console.error("Fetch public job postings error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single job posting
  app.get("/api/job-postings/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const [job] = await db.select({
        job: jobPostings,
        companyName: users.companyName,
      }).from(jobPostings)
        .leftJoin(users, eq(jobPostings.companyId, users.id))
        .where(eq(jobPostings.id, req.params.id));

      if (!job) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      res.json({ 
        jobPosting: {
          ...job.job,
          companyName: job.companyName || "Platform",
        }
      });
    } catch (error) {
      console.error("Get job posting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create job posting (SuperUser or Company owner)
  app.post("/api/job-postings", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const isPlatformPost = currentUser.role === "superuser";
      
      // Convert date strings to Date objects if provided
      const bodyWithParsedDates = {
        ...req.body,
        expiresAt: req.body.expiresAt ? new Date(req.body.expiresAt) : null,
        startDate: req.body.startDate ? new Date(req.body.startDate) : null,
      };
      
      const jobData = insertJobPostingSchema.parse({
        ...bodyWithParsedDates,
        companyId: isPlatformPost ? null : currentUser.id,
        isPlatformPost,
      });

      const [newJob] = await db.insert(jobPostings).values(jobData).returning();
      
      res.json({ jobPosting: newJob });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Create job posting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update job posting (SuperUser or owning Company)
  app.patch("/api/job-postings/:id", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get existing job to verify ownership
      const [existingJob] = await db.select().from(jobPostings).where(eq(jobPostings.id, req.params.id));
      if (!existingJob) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      // Verify ownership (company can only edit their own, superuser can edit platform posts)
      if (currentUser.role === "company" && existingJob.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (currentUser.role === "superuser" && !existingJob.isPlatformPost) {
        return res.status(403).json({ message: "SuperUser can only edit platform posts" });
      }

      const allowedUpdates: any = {
        title: req.body.title,
        description: req.body.description,
        requirements: req.body.requirements,
        location: req.body.location,
        isRemote: req.body.isRemote,
        jobType: req.body.jobType,
        employmentType: req.body.employmentType,
        salaryMin: req.body.salaryMin,
        salaryMax: req.body.salaryMax,
        salaryPeriod: req.body.salaryPeriod,
        requiredIrataLevel: req.body.requiredIrataLevel,
        requiredSpratLevel: req.body.requiredSpratLevel,
        status: req.body.status,
        expiresAt: req.body.expiresAt ? new Date(req.body.expiresAt) : req.body.expiresAt,
        startDate: req.body.startDate ? new Date(req.body.startDate) : req.body.startDate,
        benefits: req.body.benefits,
        workDays: req.body.workDays,
        experienceRequired: req.body.experienceRequired,
        updatedAt: new Date(),
      };

      // Remove undefined values
      Object.keys(allowedUpdates).forEach(key => {
        if (allowedUpdates[key] === undefined) {
          delete allowedUpdates[key];
        }
      });

      const [updatedJob] = await db.update(jobPostings)
        .set(allowedUpdates)
        .where(eq(jobPostings.id, req.params.id))
        .returning();

      res.json({ jobPosting: updatedJob });
    } catch (error) {
      console.error("Update job posting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete job posting (SuperUser or owning Company)
  app.delete("/api/job-postings/:id", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get existing job to verify ownership
      const [existingJob] = await db.select().from(jobPostings).where(eq(jobPostings.id, req.params.id));
      if (!existingJob) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      // Verify ownership
      if (currentUser.role === "company" && existingJob.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (currentUser.role === "superuser" && !existingJob.isPlatformPost) {
        return res.status(403).json({ message: "SuperUser can only delete platform posts" });
      }

      await db.delete(jobPostings).where(eq(jobPostings.id, req.params.id));

      res.json({ message: "Job posting deleted successfully" });
    } catch (error) {
      console.error("Delete job posting error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // =====================================================================
  // JOB APPLICATIONS ENDPOINTS
  // =====================================================================

  // Get applications for a technician (their own applications)
  app.get("/api/job-applications/my", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const applications = await db.select()
        .from(jobApplications)
        .where(eq(jobApplications.technicianId, currentUser.id))
        .orderBy(desc(jobApplications.appliedAt));

      // Fetch job posting details and company info for each application
      const applicationsWithJobs = await Promise.all(
        applications.map(async (app) => {
          const [job] = await db.select().from(jobPostings).where(eq(jobPostings.id, app.jobPostingId));
          let companyName = null;
          if (job?.companyId) {
            const [company] = await db.select({ 
              companyName: users.companyName, 
              name: users.name 
            }).from(users).where(eq(users.id, job.companyId));
            companyName = company?.companyName || company?.name || null;
          }
          return { ...app, jobPosting: job ? { ...job, companyName } : null };
        })
      );

      res.json({ applications: applicationsWithJobs });
    } catch (error) {
      console.error("Get my applications error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get application counts for company's job postings
  app.get("/api/job-applications/counts", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get the company's job postings
      let companyJobs;
      if (currentUser.role === "superuser") {
        // SuperUser sees platform posts
        companyJobs = await db.select({ id: jobPostings.id })
          .from(jobPostings)
          .where(eq(jobPostings.isPlatformPost, true));
      } else {
        // Company sees their own posts
        companyJobs = await db.select({ id: jobPostings.id })
          .from(jobPostings)
          .where(eq(jobPostings.companyId, currentUser.id));
      }

      const jobIds = companyJobs.map(j => j.id);
      if (jobIds.length === 0) {
        return res.json({ counts: [] });
      }

      // Count only UNVIEWED applications per job (for notification badge)
      const counts = await Promise.all(
        jobIds.map(async (jobId) => {
          const apps = await db.select()
            .from(jobApplications)
            .where(
              and(
                eq(jobApplications.jobPostingId, jobId),
                isNull(jobApplications.viewedByEmployerAt)
              )
            );
          return { jobPostingId: jobId, count: apps.length };
        })
      );

      res.json({ counts });
    } catch (error) {
      console.error("Get application counts error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get applications for a job posting (for company/superuser)
  app.get("/api/job-applications/job/:jobId", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Verify ownership of job posting
      const [job] = await db.select().from(jobPostings).where(eq(jobPostings.id, req.params.jobId));
      if (!job) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      if (currentUser.role === "company" && job.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const applications = await db.select()
        .from(jobApplications)
        .where(eq(jobApplications.jobPostingId, req.params.jobId))
        .orderBy(desc(jobApplications.appliedAt));

      // Fetch technician details for each application
      const applicationsWithTechnicians = await Promise.all(
        applications.map(async (app) => {
          const technician = await storage.getUserById(app.technicianId);
          if (!technician) return { ...app, technician: null };
          return {
            ...app,
            technician: {
              id: technician.id,
              firstName: technician.firstName,
              lastName: technician.lastName,
              name: technician.name,
              photoUrl: technician.photoUrl,
              irataLevel: technician.irataLevel,
              spratLevel: technician.spratLevel,
              employeeCity: technician.employeeCity,
              employeeProvinceState: technician.employeeProvinceState,
              ropeAccessStartDate: technician.ropeAccessStartDate,
              resumeDocuments: technician.resumeDocuments,
            },
          };
        })
      );

      // Send response first with original viewedByEmployerAt values
      res.json({ applications: applicationsWithTechnicians });

      // Then asynchronously mark unviewed applications as viewed (fire-and-forget)
      const hasUnviewed = applications.some(app => !app.viewedByEmployerAt);
      if (hasUnviewed) {
        db.update(jobApplications)
          .set({ viewedByEmployerAt: new Date() })
          .where(
            and(
              eq(jobApplications.jobPostingId, req.params.jobId),
              isNull(jobApplications.viewedByEmployerAt)
            )
          )
          .catch(err => console.error("Failed to mark applications as viewed:", err));
      }
    } catch (error) {
      console.error("Get job applications error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all sent offers for a company (to track offered/refused/hired)
  app.get("/api/job-applications/sent-offers", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get all job postings for this company
      const companyJobs = await db.select()
        .from(jobPostings)
        .where(eq(jobPostings.companyId, currentUser.id));

      const jobIds = companyJobs.map(j => j.id);
      if (jobIds.length === 0) {
        return res.json({ offers: [] });
      }

      // Get all applications with status "offered", "refused", or "hired" for these jobs
      const offers = await db.select()
        .from(jobApplications)
        .where(
          and(
            inArray(jobApplications.jobPostingId, jobIds),
            inArray(jobApplications.status, ["offered", "refused", "hired"])
          )
        )
        .orderBy(desc(jobApplications.statusUpdatedAt));

      // Enrich with technician and job posting details
      const offersWithDetails = await Promise.all(
        offers.map(async (offer) => {
          const technician = await storage.getUserById(offer.technicianId);
          const job = companyJobs.find(j => j.id === offer.jobPostingId);
          return {
            ...offer,
            technician: technician ? {
              id: technician.id,
              name: technician.name,
              firstName: technician.firstName,
              lastName: technician.lastName,
              photoUrl: technician.photoUrl,
              irataLevel: technician.irataLevel,
              spratLevel: technician.spratLevel,
            } : null,
            jobPosting: job ? {
              id: job.id,
              title: job.title,
              location: job.location,
            } : null,
          };
        })
      );

      res.json({ offers: offersWithDetails });
    } catch (error) {
      console.error("Get sent offers error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Apply to a job (technician)
  app.post("/api/job-applications", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only technician roles can apply
      const EMPLOYEE_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager"];
      if (!EMPLOYEE_ROLES.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only technicians can apply to jobs" });
      }

      const { jobPostingId, coverMessage } = req.body;
      if (!jobPostingId) {
        return res.status(400).json({ message: "Job posting ID is required" });
      }

      // Check if job exists and is active
      const [job] = await db.select().from(jobPostings).where(eq(jobPostings.id, jobPostingId));
      if (!job) {
        return res.status(404).json({ message: "Job posting not found" });
      }
      if (job.status !== "active") {
        return res.status(400).json({ message: "This job is no longer accepting applications" });
      }

      // Check if already applied
      const existingApplication = await db.select()
        .from(jobApplications)
        .where(and(
          eq(jobApplications.jobPostingId, jobPostingId),
          eq(jobApplications.technicianId, currentUser.id)
        ));

      if (existingApplication.length > 0) {
        return res.status(400).json({ message: "You have already applied to this job" });
      }

      const [newApplication] = await db.insert(jobApplications)
        .values({
          jobPostingId,
          technicianId: currentUser.id,
          coverMessage: coverMessage || null,
          status: "applied",
        })
        .returning();

      res.json({ application: newApplication, message: "Application submitted successfully" });
    } catch (error) {
      console.error("Apply to job error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update application status (company/superuser)
  app.patch("/api/job-applications/:id", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const [application] = await db.select()
        .from(jobApplications)
        .where(eq(jobApplications.id, req.params.id));

      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }

      // Verify ownership via job posting
      const [job] = await db.select().from(jobPostings).where(eq(jobPostings.id, application.jobPostingId));
      if (!job) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      if (currentUser.role === "company" && job.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { status, employerNotes } = req.body;
      const validStatuses = ["applied", "reviewing", "interviewed", "offered", "hired", "rejected"];
      if (status && !validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const updates: any = {
        statusUpdatedAt: new Date(),
      };
      if (status) updates.status = status;
      if (employerNotes !== undefined) updates.employerNotes = employerNotes;
      if (status === "reviewing" && !application.reviewedAt) {
        updates.reviewedAt = new Date();
      }

      const [updatedApplication] = await db.update(jobApplications)
        .set(updates)
        .where(eq(jobApplications.id, req.params.id))
        .returning();

      res.json({ application: updatedApplication });
    } catch (error) {
      console.error("Update application error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Withdraw/Delete application (technician or employer)
  app.delete("/api/job-applications/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const [application] = await db.select()
        .from(jobApplications)
        .where(eq(jobApplications.id, req.params.id));

      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }

      // Check if user is the technician who applied
      const isTechnician = application.technicianId === currentUser.id;

      // Check if user is the employer who owns the job posting
      let isEmployer = false;
      if (currentUser.role === "company") {
        const [job] = await db.select()
          .from(jobPostings)
          .where(eq(jobPostings.id, application.jobPostingId));
        if (job && job.companyId === currentUser.companyId) {
          isEmployer = true;
        }
      }

      if (!isTechnician && !isEmployer) {
        return res.status(403).json({ message: "Access denied" });
      }

      await db.delete(jobApplications).where(eq(jobApplications.id, req.params.id));

      res.json({ message: "Application deleted successfully" });
    } catch (error) {
      console.error("Delete application error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Refuse a job offer (technician only)
  app.post("/api/job-applications/:id/refuse", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const [application] = await db.select()
        .from(jobApplications)
        .where(eq(jobApplications.id, req.params.id));

      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }

      // Only the technician can refuse their own offer
      if (application.technicianId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Can only refuse if status is "offered"
      if (application.status !== "offered") {
        return res.status(400).json({ message: "Can only refuse offers with 'offered' status" });
      }

      const [updatedApplication] = await db.update(jobApplications)
        .set({
          status: "refused",
          statusUpdatedAt: new Date(),
        })
        .where(eq(jobApplications.id, req.params.id))
        .returning();

      // Get job posting to find the company owner
      const [job] = await db.select()
        .from(jobPostings)
        .where(eq(jobPostings.id, application.jobPostingId));

      if (job) {
        // Create notification for company owner
        await db.insert(notifications).values({
          companyId: job.companyId,
          actorId: currentUser.id,
          type: "job_offer_refused",
          payload: {
            applicationId: application.id,
            jobPostingId: job.id,
            jobTitle: job.title,
            technicianId: currentUser.id,
            technicianName: currentUser.name || "Unknown Technician",
          },
          isRead: false,
        });
      }

      res.json({ application: updatedApplication });
    } catch (error) {
      console.error("Refuse offer error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send job offer to technician (employer-initiated)
  app.post("/api/job-applications/offer", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only company owners can send job offers
      if (currentUser.role !== "company") {
        return res.status(403).json({ message: "Only employers can send job offers" });
      }

      // Validate request body
      const offerSchema = z.object({
        technicianId: z.string().min(1),
        jobPostingId: z.string().min(1),
        message: z.string().optional(),
      });

      const parseResult = offerSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ message: "technicianId and jobPostingId are required" });
      }

      const { technicianId, jobPostingId, message } = parseResult.data;

      // Verify the job posting belongs to this company and is active
      const [job] = await db.select()
        .from(jobPostings)
        .where(
          and(
            eq(jobPostings.id, jobPostingId),
            eq(jobPostings.companyId, currentUser.id)
          )
        );

      if (!job) {
        return res.status(404).json({ message: "Job posting not found" });
      }

      if (job.status !== "active") {
        return res.status(400).json({ message: "Job posting is not active" });
      }

      // Verify the technician exists
      const technician = await storage.getUserById(technicianId);
      if (!technician) {
        return res.status(404).json({ message: "Technician not found" });
      }

      // Verify the technician has opted into visibility (privacy requirement)
      const EMPLOYEE_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager"];
      if (!EMPLOYEE_ROLES.includes(technician.role)) {
        return res.status(403).json({ message: "Target user is not a technician" });
      }

      if (!technician.isVisibleToEmployers) {
        return res.status(403).json({ message: "This technician is no longer available" });
      }

      // Check if an application/offer already exists
      const [existingApplication] = await db.select()
        .from(jobApplications)
        .where(
          and(
            eq(jobApplications.technicianId, technicianId),
            eq(jobApplications.jobPostingId, jobPostingId)
          )
        );

      if (existingApplication) {
        // If already exists, just update status to 'offered'
        const [updatedApplication] = await db.update(jobApplications)
          .set({
            status: "offered",
            employerNotes: message || existingApplication.employerNotes,
            statusUpdatedAt: new Date(),
          })
          .where(eq(jobApplications.id, existingApplication.id))
          .returning();

        return res.json({ application: updatedApplication, message: "Job offer sent" });
      }

      // Create new application with 'offered' status (employer-initiated)
      const [newApplication] = await db.insert(jobApplications).values({
        technicianId,
        jobPostingId,
        status: "offered",
        employerNotes: message || null,
        appliedAt: new Date(),
        statusUpdatedAt: new Date(),
      }).returning();

      res.status(201).json({ application: newApplication, message: "Job offer sent" });
    } catch (error) {
      console.error("Send job offer error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // =====================================================================
  // END JOB APPLICATIONS ENDPOINTS
  // =====================================================================

  // Get technician's Personal Safety Rating (PSR)
  app.get("/api/technician/psr", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const ALLOWED_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager", "company"];
      if (!ALLOWED_ROLES.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only technicians can view PSR" });
      }

      // 1. Certification Score (25% of total)
      let certScore = 0;
      let certStatus = "none";
      let certDetails: any = { level: null, expirationDate: null, daysUntilExpiry: null, verified: false };
      
      const today = new Date();
      if (currentUser.irataLevel || currentUser.spratLevel) {
        const certType = currentUser.irataLevel ? "IRATA" : "SPRAT";
        const level = currentUser.irataLevel || currentUser.spratLevel;
        const expirationDate = currentUser.irataLevel 
          ? (currentUser.irataExpirationDate ? new Date(currentUser.irataExpirationDate) : null)
          : (currentUser.spratExpirationDate ? new Date(currentUser.spratExpirationDate) : null);
        const verified = currentUser.irataLevel 
          ? !!currentUser.irataVerifiedAt 
          : !!currentUser.spratVerifiedAt;

        certDetails = {
          type: certType,
          level,
          expirationDate: expirationDate?.toISOString() || null,
          daysUntilExpiry: expirationDate ? Math.ceil((expirationDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)) : null,
          verified,
        };

        if (expirationDate && expirationDate > today) {
          certScore = verified ? 100 : 75;
          certStatus = verified ? "verified" : "unverified";
        } else if (expirationDate && expirationDate <= today) {
          certScore = 25;
          certStatus = "expired";
        } else {
          certScore = 50;
          certStatus = "no_expiry_date";
        }
      }

      // 2. Safety Documents Score (25% of total) - Personal harness inspections
      let docsScore = 0;
      let docsStatus = "none";
      const personalInspections = await storage.getPersonalHarnessInspections(currentUser.id);
      
      const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
      const recentInspections = personalInspections.filter((insp: any) => 
        new Date(insp.inspectionDate) >= thirtyDaysAgo
      );
      
      const passedInspections = recentInspections.filter((insp: any) => insp.overallStatus === "pass");
      const inspectionCount = recentInspections.length;
      
      if (inspectionCount === 0) {
        docsScore = 0;
        docsStatus = "none";
      } else {
        docsScore = Math.round((passedInspections.length / Math.max(inspectionCount, 1)) * 100);
        docsStatus = docsScore >= 80 ? "good" : docsScore >= 50 ? "fair" : "poor";
      }

      const docsDetails = {
        totalInspections: personalInspections.length,
        recentInspections: inspectionCount,
        passedRecent: passedInspections.length,
        last30Days: inspectionCount,
      };

      // 3. Safety Quizzes Score (25% of total)
      let quizScore = 0;
      let quizStatus = "none";
      const allAttempts = await storage.getAllQuizAttemptsByEmployee(currentUser.id);
      
      const safetyQuizAttempts = allAttempts.filter((a: any) => 
        a.quizId?.startsWith("safety_") || a.quizId?.startsWith("cert_")
      );
      
      const passedQuizzes = new Set(
        safetyQuizAttempts.filter((a: any) => a.passed).map((a: any) => a.quizId)
      );
      
      const totalSafetyQuizTypes = 6;
      quizScore = Math.round((passedQuizzes.size / totalSafetyQuizTypes) * 100);
      quizStatus = quizScore >= 80 ? "good" : quizScore >= 50 ? "fair" : quizScore > 0 ? "started" : "none";

      const quizDetails = {
        totalAttempts: safetyQuizAttempts.length,
        passedQuizTypes: passedQuizzes.size,
        totalQuizTypes: totalSafetyQuizTypes,
        quizzesPassed: Array.from(passedQuizzes),
      };

      // 4. Work History Score (25% of total) - Only for employer-linked technicians
      let workScore = 0;
      let workStatus = "not_applicable";
      let workDetails: any = { isLinked: false };

      const connections = await db.select()
        .from(technicianEmployerConnections)
        .where(
          and(
            eq(technicianEmployerConnections.technicianId, currentUser.id),
            eq(technicianEmployerConnections.status, "active")
          )
        );

      if (connections.length > 0 || currentUser.companyId) {
        workDetails.isLinked = true;
        const companyId = currentUser.companyId || connections[0]?.companyId;
        
        if (companyId) {
          const workSessions = await storage.getAllWorkSessionsByEmployee(currentUser.id);
          const completedSessions = workSessions.filter((ws: any) => ws.endTime);
          
          const incidentReportsList = await db.select()
            .from(incidentReports)
            .where(eq(incidentReports.companyId, companyId));
          
          const technicianIncidents = incidentReportsList.filter((ir: any) => 
            ir.reportedById === currentUser.id || 
            (ir.witnesses && Array.isArray(ir.witnesses) && ir.witnesses.includes(currentUser.id))
          );

          workDetails = {
            isLinked: true,
            totalSessions: completedSessions.length,
            incidentCount: technicianIncidents.length,
          };

          if (completedSessions.length === 0) {
            workScore = 50;
            workStatus = "new";
          } else {
            const incidentPenalty = Math.min(technicianIncidents.length * 10, 50);
            workScore = Math.max(100 - incidentPenalty, 50);
            workStatus = workScore >= 90 ? "excellent" : workScore >= 70 ? "good" : "fair";
          }
        }
      }

      // Calculate overall PSR
      const weights = { cert: 0.25, docs: 0.25, quiz: 0.25, work: 0.25 };
      
      let overallScore: number;
      if (!workDetails.isLinked) {
        overallScore = Math.round(
          (certScore * 0.33) + 
          (docsScore * 0.33) + 
          (quizScore * 0.34)
        );
      } else {
        overallScore = Math.round(
          (certScore * weights.cert) + 
          (docsScore * weights.docs) + 
          (quizScore * weights.quiz) + 
          (workScore * weights.work)
        );
      }

      res.json({
        overallScore,
        isLinkedToEmployer: workDetails.isLinked,
        components: {
          certifications: {
            score: certScore,
            status: certStatus,
            details: certDetails,
            weight: workDetails.isLinked ? 25 : 33,
          },
          safetyDocs: {
            score: docsScore,
            status: docsStatus,
            details: docsDetails,
            weight: workDetails.isLinked ? 25 : 33,
          },
          quizzes: {
            score: quizScore,
            status: quizStatus,
            details: quizDetails,
            weight: workDetails.isLinked ? 25 : 34,
          },
          workHistory: {
            score: workScore,
            status: workStatus,
            details: workDetails,
            weight: workDetails.isLinked ? 25 : 0,
          },
        },
      });
    } catch (error) {
      console.error("Get technician PSR error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Toggle technician visibility to employers
  app.patch("/api/technician/visibility", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Technicians and company owners (who often also work as techs) can toggle their visibility
      const ALLOWED_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager", "company"];
      if (!ALLOWED_ROLES.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only technicians and company owners can update visibility" });
      }

      const { isVisible } = req.body;
      
      const updates: any = {
        isVisibleToEmployers: isVisible,
      };
      
      // Set timestamp when visibility is enabled
      if (isVisible) {
        updates.visibilityEnabledAt = new Date();
      }

      const [updatedUser] = await db.update(users)
        .set(updates)
        .where(eq(users.id, currentUser.id))
        .returning();

      res.json({ 
        isVisibleToEmployers: updatedUser.isVisibleToEmployers,
        visibilityEnabledAt: updatedUser.visibilityEnabledAt,
      });
    } catch (error) {
      console.error("Update technician visibility error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update technician expected salary
  app.patch("/api/technician/expected-salary", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Technicians and company owners (who often also work as techs) can update their expected salary
      const ALLOWED_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager", "company"];
      if (!ALLOWED_ROLES.includes(currentUser.role)) {
        return res.status(403).json({ message: "Only technicians and company owners can update expected salary" });
      }

      const { minSalary, maxSalary, salaryPeriod } = req.body;
      
      const updates: any = {
        expectedSalaryMin: minSalary || null,
        expectedSalaryMax: maxSalary || null,
        expectedSalaryPeriod: salaryPeriod || null,
      };

      const [updatedUser] = await db.update(users)
        .set(updates)
        .where(eq(users.id, currentUser.id))
        .returning();

      res.json({ 
        expectedSalaryMin: updatedUser.expectedSalaryMin,
        expectedSalaryMax: updatedUser.expectedSalaryMax,
        expectedSalaryPeriod: updatedUser.expectedSalaryPeriod,
      });
    } catch (error) {
      console.error("Update expected salary error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper function to calculate individual technician safety rating
  // quizAttempts parameter is optional - if provided, quiz points are calculated
  function calculateTechnicianSafetyRating(tech: any, quizAttempts?: any[]): { safetyRating: number; safetyLabel: string; safetyColor: string; safetyBreakdown: any } {
    const now = new Date();
    let totalPoints = 0;
    let maxPoints = 0;
    
    const breakdown: any = {
      irataValid: false,
      spratValid: false,
      hasValidCertification: false,
      certificationPoints: 0,
      certificationMax: 40,
      yearsExperience: 0,
      experiencePoints: 0,
      experienceMax: 15,
      hasResume: false,
      resumePoints: 0,
      resumeMax: 5,
      quizzesPassed: 0,
      quizPoints: 0,
      quizMax: 20,
    };
    
    // 1. Certification Score (up to 40 points) - BEST OF IRATA or SPRAT
    // Having both certifications is a personal/regional choice, not a safety advantage
    // We use the best score from either certification
    maxPoints += 40;
    
    let irataScore = 0;
    let spratScore = 0;
    
    // Calculate IRATA score
    if (tech.irataLevel) {
      const irataExpDate = tech.irataExpirationDate ? new Date(tech.irataExpirationDate) : null;
      if (irataExpDate && irataExpDate > now) {
        // Valid IRATA certification - full points
        irataScore = 40;
        breakdown.irataValid = true;
      } else if (irataExpDate && irataExpDate <= now) {
        // Expired - partial credit (10 points for having it at all)
        irataScore = 10;
      }
    }
    
    // Calculate SPRAT score
    if (tech.spratLevel) {
      const spratExpDate = tech.spratExpirationDate ? new Date(tech.spratExpirationDate) : null;
      if (spratExpDate && spratExpDate > now) {
        // Valid SPRAT certification - full points
        spratScore = 40;
        breakdown.spratValid = true;
      } else if (spratExpDate && spratExpDate <= now) {
        // Expired - partial credit (10 points for having it at all)
        spratScore = 10;
      }
    }
    
    // Use the BEST score from either certification
    const certificationScore = Math.max(irataScore, spratScore);
    totalPoints += certificationScore;
    breakdown.certificationPoints = certificationScore;
    
    // If they have any valid certification, mark it
    if (breakdown.irataValid || breakdown.spratValid) {
      breakdown.hasValidCertification = true;
    }
    
    // If no certifications at all, give baseline score (20 out of 40)
    if (!tech.irataLevel && !tech.spratLevel) {
      totalPoints = 20; // Baseline for no certification
      breakdown.certificationPoints = 20;
    }
    
    // 2. Experience points (up to 15 points)
    maxPoints += 15;
    if (tech.ropeAccessStartDate) {
      const startDate = new Date(tech.ropeAccessStartDate);
      const yearsExp = Math.floor((now.getTime() - startDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
      breakdown.yearsExperience = yearsExp;
      // 3 points per year, max 15
      const expPoints = Math.min(15, yearsExp * 3);
      totalPoints += expPoints;
      breakdown.experiencePoints = expPoints;
    }
    
    // 3. Resume uploaded (5 points)
    maxPoints += 5;
    if (tech.resumeDocuments && tech.resumeDocuments.length > 0) {
      totalPoints += 5;
      breakdown.hasResume = true;
      breakdown.resumePoints = 5;
    }
    
    // 4. Quiz Completion (up to 20 points) - 2 points per unique quiz passed, max 10 quizzes
    // Only include quiz points in calculation when quiz data is explicitly provided
    if (quizAttempts !== undefined) {
      maxPoints += 20;
      if (quizAttempts.length > 0) {
        // Use Set to count unique passed quizzes (prevents farming)
        const passedQuizIds = new Set<string>();
        for (const attempt of quizAttempts) {
          if (attempt.passed && attempt.quizId) {
            passedQuizIds.add(attempt.quizId);
          }
        }
        const quizzesPassed = passedQuizIds.size;
        breakdown.quizzesPassed = quizzesPassed;
        // 2 points per quiz, max 20 points (10 quizzes)
        const quizPts = Math.min(20, quizzesPassed * 2);
        totalPoints += quizPts;
        breakdown.quizPoints = quizPts;
      }
    }
    
    // Calculate percentage
    const safetyRating = maxPoints > 0 ? Math.round((totalPoints / maxPoints) * 100) : 0;
    
    // Determine label and color
    let safetyLabel: string;
    let safetyColor: string;
    if (safetyRating >= 90) {
      safetyLabel = "Excellent";
      safetyColor = "green";
    } else if (safetyRating >= 70) {
      safetyLabel = "Good";
      safetyColor = "yellow";
    } else if (safetyRating >= 50) {
      safetyLabel = "Fair";
      safetyColor = "orange";
    } else {
      safetyLabel = "Needs Attention";
      safetyColor = "red";
    }
    
    return { safetyRating, safetyLabel, safetyColor, safetyBreakdown: breakdown };
  }

  // Get visible technicians (for companies browsing)
  app.get("/api/visible-technicians", requireAuth, requireRole("company", "superuser"), async (req: Request, res: Response) => {
    try {
      const EMPLOYEE_ROLES = ["rope_access_tech", "ground_crew", "ground_crew_supervisor", "supervisor", "operations_manager", "manager"];
      
      // Get technicians who opted in to visibility
      const visibleTechs = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        name: users.name,
        photoUrl: users.photoUrl,
        irataLevel: users.irataLevel,
        irataLicenseNumber: users.irataLicenseNumber,
        irataExpirationDate: users.irataExpirationDate,
        spratLevel: users.spratLevel,
        spratLicenseNumber: users.spratLicenseNumber,
        spratExpirationDate: users.spratExpirationDate,
        ropeAccessStartDate: users.ropeAccessStartDate,
        resumeDocuments: users.resumeDocuments,
        employeeCity: users.employeeCity,
        employeeProvinceState: users.employeeProvinceState,
        employeeCountry: users.employeeCountry,
        visibilityEnabledAt: users.visibilityEnabledAt,
        expectedSalaryMin: users.expectedSalaryMin,
        expectedSalaryMax: users.expectedSalaryMax,
        expectedSalaryPeriod: users.expectedSalaryPeriod,
        ropeAccessSpecialties: users.ropeAccessSpecialties,
      }).from(users)
        .where(and(
          eq(users.isVisibleToEmployers, true),
          sql`${users.role} = ANY(ARRAY['rope_access_tech', 'ground_crew', 'ground_crew_supervisor', 'supervisor', 'operations_manager', 'manager'])`
        ))
        .orderBy(sql`${users.visibilityEnabledAt} DESC`);

      // Fetch all quiz attempts for visible technicians (for PSR calculation)
      const techIds = visibleTechs.map(t => t.id);
      const allQuizAttempts = techIds.length > 0 
        ? await db.select().from(quizAttempts).where(inArray(quizAttempts.employeeId, techIds))
        : [];
      
      
      // Fetch all certifications for visible technicians
      const allCertifications = techIds.length > 0
        ? await db.select().from(userCertifications).where(inArray(userCertifications.userId, techIds))
        : [];
      
      // Group certifications by user ID
      const certificationsByUser = new Map<string, any[]>();
      for (const cert of allCertifications) {
        if (!certificationsByUser.has(cert.userId)) {
          certificationsByUser.set(cert.userId, []);
        }
        certificationsByUser.get(cert.userId)!.push({
          id: cert.id,
          description: cert.description,
          fileUrl: cert.fileUrl,
          expiryDate: cert.expiryDate,
          createdAt: cert.createdAt,
        });
      }
      // Group quiz attempts by employee ID
      const quizAttemptsByEmployee = new Map<string, any[]>();
      for (const attempt of allQuizAttempts) {
        if (attempt.employeeId) {
          if (!quizAttemptsByEmployee.has(attempt.employeeId)) {
            quizAttemptsByEmployee.set(attempt.employeeId, []);
          }
          quizAttemptsByEmployee.get(attempt.employeeId)!.push(attempt);
        }
      }

      // Add safety rating to each technician (with quiz data)
      const techniciansWithRating = visibleTechs.map(tech => {
        const techQuizAttempts = quizAttemptsByEmployee.get(tech.id) || [];
        const { safetyRating, safetyLabel, safetyColor, safetyBreakdown } = calculateTechnicianSafetyRating(tech, techQuizAttempts);
        return {
          ...tech,
          safetyRating,
          safetyLabel,
          safetyColor,
          safetyBreakdown,
          certifications: certificationsByUser.get(tech.id) || [],
        };
      });

      res.json({ technicians: techniciansWithRating });
    } catch (error) {
      console.error("Get visible technicians error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get notifications for company owner
  app.get("/api/notifications", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const unreadOnly = req.query.unread === "true";

      let query = db.select()
        .from(notifications)
        .where(eq(notifications.companyId, currentUser.id))
        .orderBy(desc(notifications.createdAt));

      if (unreadOnly) {
        query = db.select()
          .from(notifications)
          .where(and(
            eq(notifications.companyId, currentUser.id),
            eq(notifications.isRead, false)
          ))
          .orderBy(desc(notifications.createdAt));
      }

      const results = await query;

      res.json({ notifications: results });
    } catch (error) {
      console.error("Get notifications error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get unread notification count
  app.get("/api/notifications/unread-count", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const result = await db.select({ count: sql<number>`count(*)` })
        .from(notifications)
        .where(and(
          eq(notifications.companyId, currentUser.id),
          eq(notifications.isRead, false)
        ));

      res.json({ count: Number(result[0]?.count || 0) });
    } catch (error) {
      console.error("Get unread count error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark notification as read
  app.patch("/api/notifications/:id/read", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const [notification] = await db.select()
        .from(notifications)
        .where(eq(notifications.id, req.params.id));

      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }

      // Only the company owner can mark their own notifications as read
      if (notification.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const [updated] = await db.update(notifications)
        .set({ isRead: true })
        .where(eq(notifications.id, req.params.id))
        .returning();

      res.json({ notification: updated });
    } catch (error) {
      console.error("Mark notification read error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark all notifications as read
  app.patch("/api/notifications/read-all", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      await db.update(notifications)
        .set({ isRead: true })
        .where(and(
          eq(notifications.companyId, currentUser.id),
          eq(notifications.isRead, false)
        ));

      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Mark all read error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== QUIZ ROUTES ====================

  // Generate quiz from document (AI) - Company owners only
  app.post("/api/quiz/generate/:documentId", requireAuth, requireRole("company"), async (req: Request, res: Response) => {
    try {
      const { documentId } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Get the document
      const document = await storage.getCompanyDocumentById(documentId);
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Verify ownership
      if (document.companyId !== currentUser.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Check document type is valid for quiz generation
      const validDocTypes = ['health_safety_manual', 'company_policy'];
      if (!validDocTypes.includes(document.documentType)) {
        return res.status(400).json({ message: "Quiz generation is only available for Health & Safety Manual and Company Policy documents" });
      }

      // Check if quiz already exists for this document
      const existingQuiz = await storage.getQuizByDocumentId(documentId);
      if (existingQuiz) {
        return res.status(400).json({ message: "A quiz already exists for this document. Delete it first to regenerate." });
      }

      // Get the document file from object storage
      const objectStorage = new ObjectStorageService();
      const fileBuffer = await objectStorage.downloadPublicFileAsBuffer(document.fileUrl);
      if (!fileBuffer) {
        return res.status(404).json({ message: "Document file not found in storage" });
      }

      // Convert to base64
      const pdfBase64 = fileBuffer.toString('base64');

      // Generate quiz using AI
      const quizResult = await generateQuizFromDocument(pdfBase64, document.documentType);

      if (!quizResult.success || quizResult.questions.length < 10) {
        return res.status(400).json({ 
          message: quizResult.error || "Failed to generate quiz. Document may be too short or unclear.",
          questionsGenerated: quizResult.questions.length
        });
      }

      // Save quiz to database
      const quiz = await storage.createDocumentQuiz({
        companyId: currentUser.id,
        documentId: documentId,
        documentType: document.documentType,
        questions: quizResult.questions,
      });

      res.json({ 
        quiz,
        questionsGenerated: quizResult.questions.length,
        message: `Quiz generated successfully with ${quizResult.questions.length} questions`
      });
    } catch (error) {
      console.error("Generate quiz error:", error);
      res.status(500).json({ message: "Failed to generate quiz" });
    }
  });

  // Get all quizzes for company (company owners/operations managers only)
  app.get("/api/quiz/company", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Only company owners and operations managers can access this
      if (currentUser.role !== 'company' && currentUser.role !== 'operations_manager') {
        return res.status(403).json({ message: "Access denied" });
      }

      const companyId = currentUser.role === 'company' ? currentUser.id : currentUser.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "No company associated with this account" });
      }

      const quizzes = await storage.getQuizzesByCompanyId(companyId);
      res.json({ quizzes });
    } catch (error) {
      console.error("Get company quizzes error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get available quizzes for current employee
  app.get("/api/quiz/available", requireAuth, async (req: Request, res: Response) => {
    try {
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Employees see quizzes from their company
      const companyId = currentUser.role === 'company' ? currentUser.id : currentUser.companyId;
      
      // Get company quizzes if user has a company
      let companyQuizzesWithStatus: any[] = [];
      if (companyId) {
        const quizzes = await storage.getQuizzesByCompanyId(companyId);
        companyQuizzesWithStatus = await Promise.all(
          quizzes.map(async (quiz) => {
            const hasPassed = await storage.hasEmployeePassedQuiz(currentUser.id, quiz.id);
            const attempts = await storage.getQuizAttemptsByEmployee(currentUser.id, quiz.id);
            return {
              id: quiz.id,
              documentType: quiz.documentType,
              questionCount: Array.isArray(quiz.questions) ? quiz.questions.length : 0,
              createdAt: quiz.createdAt,
              hasPassed,
              attemptCount: attempts.length,
              lastAttempt: attempts.length > 0 ? attempts[0].completedAt : null,
              quizCategory: 'company',
            };
          })
        );
      }

      // Get certification quizzes based on user's IRATA/SPRAT level
      // Company owners see ALL certification quizzes so they can test the system
      const { certificationQuizzes, getQuizzesForUser } = await import('./certificationQuizzes');
      const certQuizzes = currentUser.role === 'company' 
        ? certificationQuizzes 
        : getQuizzesForUser(currentUser.irataLevel, currentUser.spratLevel);
      
      const certQuizzesWithStatus = await Promise.all(
        certQuizzes.map(async (certQuiz) => {
          const certQuizId = `cert_${certQuiz.quizType}`;
          const hasPassed = await storage.hasEmployeePassedQuiz(currentUser.id, certQuizId);
          const attempts = await storage.getQuizAttemptsByEmployee(currentUser.id, certQuizId);
          return {
            id: certQuizId,
            documentType: certQuiz.quizType,
            title: certQuiz.title,
            certification: certQuiz.certification,
            level: certQuiz.level,
            questionCount: certQuiz.questions.length,
            createdAt: null,
            hasPassed,
            attemptCount: attempts.length,
            lastAttempt: attempts.length > 0 ? attempts[0].completedAt : null,
            quizCategory: 'certification',
          };
        })
      );

      // Get safety practice quizzes (SWP, FLHA, Harness Inspection)
      // All users can access safety quizzes
      const { safetyQuizzes } = await import('./safetyQuizzes');
      const safetyQuizzesWithStatus = await Promise.all(
        safetyQuizzes.map(async (safetyQuiz) => {
          const safetyQuizId = `safety_${safetyQuiz.quizType}`;
          const hasPassed = await storage.hasEmployeePassedQuiz(currentUser.id, safetyQuizId);
          const attempts = await storage.getQuizAttemptsByEmployee(currentUser.id, safetyQuizId);
          return {
            id: safetyQuizId,
            documentType: safetyQuiz.quizType,
            title: safetyQuiz.title,
            category: safetyQuiz.category,
            jobType: safetyQuiz.jobType,
            questionCount: safetyQuiz.questions.length,
            createdAt: null,
            hasPassed,
            attemptCount: attempts.length,
            lastAttempt: attempts.length > 0 ? attempts[0].completedAt : null,
            quizCategory: 'safety',
          };
        })
      );

      // Combine all types of quizzes
      const allQuizzes = [...companyQuizzesWithStatus, ...certQuizzesWithStatus, ...safetyQuizzesWithStatus];

      res.json({ quizzes: allQuizzes });
    } catch (error) {
      console.error("Get available quizzes error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get quiz questions (without correct answers for taking)
  app.get("/api/quiz/:quizId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { quizId } = req.params;
      const lang = (req.query.lang as string) || 'en';
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Import translation function
      const { getTranslatedQuestion } = await import('./quizTranslations');

      // Handle certification quizzes (IDs start with "cert_")
      if (quizId.startsWith("cert_")) {
        const { certificationQuizzes, getQuizzesForUser } = await import('./certificationQuizzes');
        const quizType = quizId.replace("cert_", "");
        const certQuiz = certificationQuizzes.find(q => q.quizType === quizType);
        
        if (!certQuiz) {
          return res.status(404).json({ message: "Certification quiz not found" });
        }

        // Verify user has the required certification level (company owners can access all)
        const isCompanyOwner = currentUser.role === 'company';
        if (!isCompanyOwner) {
          const userQuizzes = getQuizzesForUser(currentUser.irataLevel, currentUser.spratLevel);
          const hasAccess = userQuizzes.some(q => q.quizType === quizType);
          if (!hasAccess) {
            return res.status(403).json({ message: "You do not have access to this certification quiz" });
          }
        }

        // Return questions WITHOUT correct answers, with translation if available
        const questionsForTaking = certQuiz.questions.map((q) => {
          const translation = getTranslatedQuestion(quizType, q.questionNumber, lang);
          return {
            questionNumber: q.questionNumber,
            question: translation?.question || q.question,
            options: translation?.options || q.options,
          };
        });

        return res.json({
          quiz: {
            id: quizId,
            documentType: certQuiz.quizType,
            title: certQuiz.title,
            certification: certQuiz.certification,
            level: certQuiz.level,
            quizCategory: 'certification',
            questions: questionsForTaking,
          }
        });
      }

      // Handle safety quizzes (IDs start with "safety_")
      if (quizId.startsWith("safety_")) {
        const { safetyQuizzes } = await import('./safetyQuizzes');
        const quizType = quizId.replace("safety_", "");
        const safetyQuiz = safetyQuizzes.find(q => q.quizType === quizType);
        
        if (!safetyQuiz) {
          return res.status(404).json({ message: "Safety quiz not found" });
        }

        // Return questions WITHOUT correct answers, with translation if available
        const questionsForTaking = safetyQuiz.questions.map((q) => {
          const translation = getTranslatedQuestion(quizType, q.questionNumber, lang);
          return {
            questionNumber: q.questionNumber,
            question: translation?.question || q.question,
            options: translation?.options || q.options,
          };
        });

        return res.json({
          quiz: {
            id: quizId,
            documentType: safetyQuiz.quizType,
            title: safetyQuiz.title,
            category: safetyQuiz.category,
            jobType: safetyQuiz.jobType,
            quizCategory: 'safety',
            questions: questionsForTaking,
          }
        });
      }

      // Handle company quizzes (from database)
      const quiz = await storage.getQuizById(quizId);
      if (!quiz) {
        return res.status(404).json({ message: "Quiz not found" });
      }

      // Verify user belongs to the company
      const userCompanyId = currentUser.role === 'company' ? currentUser.id : currentUser.companyId;
      if (quiz.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Return questions WITHOUT correct answers
      const questionsForTaking = (quiz.questions as any[]).map((q: any) => ({
        questionNumber: q.questionNumber,
        question: q.question,
        options: q.options,
      }));

      res.json({
        quiz: {
          id: quiz.id,
          documentType: quiz.documentType,
          quizCategory: 'company',
          questions: questionsForTaking,
        }
      });
    } catch (error) {
      console.error("Get quiz error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Submit quiz answers and get results
  app.post("/api/quiz/:quizId/submit", requireAuth, async (req: Request, res: Response) => {
    try {
      const { quizId } = req.params;
      const { answers } = req.body; // Array of { questionNumber, selectedAnswer }

      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      if (!answers || !Array.isArray(answers)) {
        return res.status(400).json({ message: "Answers are required as an array" });
      }

      // Handle certification quizzes (IDs start with "cert_")
      if (quizId.startsWith("cert_")) {
        const { certificationQuizzes, getQuizzesForUser } = await import('./certificationQuizzes');
        const quizType = quizId.replace("cert_", "");
        const certQuiz = certificationQuizzes.find(q => q.quizType === quizType);
        
        if (!certQuiz) {
          return res.status(404).json({ message: "Certification quiz not found" });
        }
        
        // Verify access based on user's certification level (company owners can access all)
        const isCompanyOwner = currentUser.role === 'company';
        if (!isCompanyOwner) {
          const userQuizzes = getQuizzesForUser(currentUser.irataLevel, currentUser.spratLevel);
          const hasAccess = userQuizzes.some(q => q.quizType === quizType);
          if (!hasAccess) {
            return res.status(403).json({ message: "Access denied - insufficient certification level" });
          }
        }
        
        // Convert answers array to lookup object
        const answersMap: Record<number, string> = {};
        for (const ans of answers) {
          answersMap[ans.questionNumber] = ans.selectedAnswer;
        }
        
        // Grade the quiz
        const questions = certQuiz.questions;
        let correctCount = 0;
        const gradedAnswers: any[] = [];

        for (const question of questions) {
          const userAnswer = answersMap[question.questionNumber];
          const isCorrect = userAnswer === question.correctAnswer;
          if (isCorrect) correctCount++;

          gradedAnswers.push({
            questionNumber: question.questionNumber,
            selected: userAnswer || null,
            correct: question.correctAnswer,
            isCorrect,
          });
        }

        const totalQuestions = questions.length;
        const score = Math.round((correctCount / totalQuestions) * 100);
        const passed = score >= 80;

        // Save the attempt (use quizId as the cert_ ID)
        // Note: companyId can be null for unaffiliated technicians (self-resigned or never linked)
        const attempt = await storage.createQuizAttempt({
          quizId: quizId,
          employeeId: currentUser.id,
          companyId: currentUser.companyId || null,
          score,
          passed,
          answers: gradedAnswers,
        });

        return res.json({
          score,
          passed,
          correctAnswers: correctCount,
          totalQuestions,
          answers: gradedAnswers,
        });
      }

      // Handle safety practice quizzes (IDs start with "safety_")
      if (quizId.startsWith("safety_")) {
        const { safetyQuizzes } = await import('./safetyQuizzes');
        const quizType = quizId.replace("safety_", "");
        const safetyQuiz = safetyQuizzes.find(q => q.quizType === quizType);
        
        if (!safetyQuiz) {
          return res.status(404).json({ message: "Safety quiz not found" });
        }
        
        // Convert answers array to lookup object
        const answersMap: Record<number, string> = {};
        for (const ans of answers) {
          answersMap[ans.questionNumber] = ans.selectedAnswer;
        }
        
        // Grade the quiz
        const questions = safetyQuiz.questions;
        let correctCount = 0;
        const gradedAnswers: any[] = [];

        for (const question of questions) {
          const userAnswer = answersMap[question.questionNumber];
          const isCorrect = userAnswer === question.correctAnswer;
          if (isCorrect) correctCount++;

          gradedAnswers.push({
            questionNumber: question.questionNumber,
            selected: userAnswer || null,
            correct: question.correctAnswer,
            isCorrect,
          });
        }

        const totalQuestions = questions.length;
        const score = Math.round((correctCount / totalQuestions) * 100);
        const passed = score >= 80;

        // Save the attempt (use quizId as the safety_ ID)
        // Note: companyId can be null for unaffiliated technicians (self-resigned or never linked)
        const attempt = await storage.createQuizAttempt({
          quizId: quizId,
          employeeId: currentUser.id,
          companyId: currentUser.companyId || null,
          score,
          passed,
          answers: gradedAnswers,
        });

        return res.json({
          score,
          passed,
          correctAnswers: correctCount,
          totalQuestions,
          answers: gradedAnswers,
        });
      }

      // Handle company quizzes (from database)
      const quiz = await storage.getQuizById(quizId);
      if (!quiz) {
        return res.status(404).json({ message: "Quiz not found" });
      }

      // Verify user belongs to the company
      const userCompanyId = currentUser.role === 'company' ? currentUser.id : currentUser.companyId;
      if (quiz.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Convert answers array to lookup object
      const answersMap: Record<number, string> = {};
      for (const ans of answers) {
        answersMap[ans.questionNumber] = ans.selectedAnswer;
      }

      // Grade the quiz
      const questions = quiz.questions as any[];
      let correctCount = 0;
      const gradedAnswers: any[] = [];

      for (const question of questions) {
        const userAnswer = answersMap[question.questionNumber];
        const isCorrect = userAnswer === question.correctAnswer;
        if (isCorrect) correctCount++;

        gradedAnswers.push({
          questionNumber: question.questionNumber,
          selected: userAnswer || null,
          correct: question.correctAnswer,
          isCorrect,
        });
      }

      const totalQuestions = questions.length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      const passed = score >= 80; // 80% pass rate

      // Save the attempt
      const attempt = await storage.createQuizAttempt({
        quizId: quiz.id,
        employeeId: currentUser.id,
        companyId: quiz.companyId,
        score,
        passed,
        answers: gradedAnswers,
      });

      res.json({
        score,
        passed,
        correctAnswers: correctCount,
        totalQuestions,
        answers: gradedAnswers,
      });
    } catch (error) {
      console.error("Submit quiz error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get employee's quiz results
  app.get("/api/quiz/:quizId/results", requireAuth, async (req: Request, res: Response) => {
    try {
      const { quizId } = req.params;
      const currentUser = await storage.getUserById(req.session.userId!);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      const quiz = await storage.getQuizById(quizId);
      if (!quiz) {
        return res.status(404).json({ message: "Quiz not found" });
      }

      // Verify user belongs to the company
      const userCompanyId = currentUser.role === 'company' ? currentUser.id : currentUser.companyId;
      if (quiz.companyId !== userCompanyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const attempts = await storage.getQuizAttemptsByEmployee(currentUser.id, quizId);
      const hasPassed = attempts.some(a => a.passed);

      res.json({
        quizId,
        documentType: quiz.documentType,
        attempts,
        hasPassed,
        attemptCount: attempts.length,
        bestScore: attempts.length > 0 ? Math.max(...attempts.map(a => a.score)) : null,
      });
    } catch (error) {
      console.error("Get quiz results error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  const httpServer = createServer(app);
  
  // Start background workers
  runBucketHealthCheck().then(healthy => {
    if (healthy) {
      startPhotoUploadWorker();
    } else {
      console.warn("[PhotoWorker] Worker not started - bucket health check failed. Photos will queue but not upload until bucket is accessible.");
    }
  });
  
  return httpServer;
}
